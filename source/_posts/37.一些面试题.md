---
title: 三十七、 一些面试题
date: 2020-12-15
tags:
  - 面试
---

### 基本数据类型和引用数据类型

 ##### 一：基本数据类型 Number、String 、Boolean、Null、Undefine Symbol、BigInt
1. 基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值，存放在栈中.
```javascript  
var a = 10;
var b = a;
b = 20;
console.log(a); // 10值
```
##### 二： 引用类型数据 对象类型Object type，比如：Object 、Array 、Function 、Data等。
 1. 引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址，存放在栈堆中.
 ```javascript  
var obj1 = new Object();
var obj2 = obj1;
obj2.name = "我有名字了";
console.log(obj1.name); // 我有名字了
```
##### 三： 使用typeof 可以判断类型

##### 四：区别
1. 基本数据类型的值是不可变的; 引用类型的值是可以改变的
```javascript
var name = "change";
name = "change1";
console.log(name)//change1
```
    `改变只是“指针的指向改变”, 基础类型指的是"change"，而不是name，要区分清楚`

2. 基本数据类型不可以添加属性和方法; 引用类型可以添加属性和方法

3. 基本数据类型的比较是值的比较; 引用类型的比较是引用的比较

4. 基本数据类型是存放在栈区的; 引用类型是同时保存在栈区和堆区中的

### instanceOf 的实现原理

- obj instanceof Object;//true 实例obj在不在Object构造函数中


    1.instanceof主要用于判断某个实例是否属于某个类型，也可用于判断某个实例是否是其父类型或者祖先类型的实例，
    2.instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。
    因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false。

 ```javascript
    const instanceOf = ( left, right ) => {
        let leftVal = left.__proto__;
        let rightVal = right.prototype;
        // 若找不到就到一直循环到父类型或祖类型
        while(true){
            if( leftVal === null ){ return false };
            if( leftVal === rightVal ){
                return true;
            }
            leftVal = leftVal.__proto__; // 获取祖类型的__proto__
        }
    }

 ```


 ### 爬楼梯
 - 每次爬 1 或 2 个台阶，爬上n阶有几种爬法？


    1.一个台阶是1种 ，2个台阶是 2种....

  ```javascript
    const climbStairs = (n) => {
        let dp = new Array(n).fill(0);
        dp[1] = 1; 
        dp[2] = 2; 
        for(let i = 3; i <= n; i++){
            dp[i] = dp[i - 1] + dp[ i - 2];
        }
        return dp[n]
    }

  ```


### prototype 与 `__proto__`

- prototype 与 `__proto__`

   //首先明确的是函数有prototype
   //对象有_proto_
   //万物皆对象所以其实函数也有_proto_属性

  1.__proto__ 就是JavaScript中所谓的原型.  
  一个对象的 __proto__ 属性和自己的内部属性[[Prototype]]指向一个相同的值 (通常称这个值为原型),
    原型的值可以是一个对象值也可以是null(比如说Object.prototype.__proto__ 的值就是null).
    该属性可能会引发一些错误,因为用户可能会不知道该属性的特殊性,而给它赋值,从而改变了这个对象的原型. 
    如果需要访问一个对象的原型,应该使用方法Object.getPrototypeOf.


  2. prototype 是function中特有的;
    ```javascript
        function A(name){
            this.name = name;
        }
        console.dir(A);
    ```
    ![](/images/BZ7ZzaR.png)

    `首先看A是一个函数,自然A的原型链就应该指向一个函数对象.
    其次我们还看到当我们定义了function A的时候,A上会有一个 prototype 的属性.
    这个属性是我们定义function的时候就默认带上的.A的 prototype 指向一个对象,
    这个对象的包含一个 constructor 属性以及一个 __proto__ ( __proto__ 指向Object表示这是一个对象).
    默认的constructor属性指向function A.`

  3. __proto__ 是原型,
    prototype是函数默认的一个属性,它指向一个对象,这个对象的constructor属性指向函数本身.



- new之后发生了什么?

```javascript
    // 当我们执行 const o =  new A('testa')的时候
    1. var o = new Object();
    2. o. __proto__ = A.prototype;
    3. A.call(o) //由于这里this是指向o,可以把什么this.name/getName绑定到o上.
    4. 把这个o返回给a;//完成var a = new A()的过程.
```

```javascript
    function fn(){
        this.a=1;
    }
    var A = new fn();
    console.log(A.a)=>1
    //在new之后究竟发生了什么呢？
    //var A={}; A._proto_ = fn.prototype; fn.call(A); 最后返回一个新的对象
```

```javascript
// 手写new
function New(Super, ...args) {
    // 创建一个继承构造函数原型的对象
    let obj = Object.create(Super.prototype);
    // res是表示构造函数返回的结果
    let res = Super.call(obj, ...args);
    // 第一个条件是返回对象
    // 第二个条件是返回函数
    if ((res !== null && typeof res === 'object') || typeof res === 'function') {
        return res;
    }
    // 返回新对象
    return obj;
}
```

### 给一数组和一数字，求数组中出现次数大于数组长度除该数字的项

```javascript
    const arrCount  = (arr, n) => {
        const dp = new Array(arr.length).fill(0); // 新建一个记录数字次数的数组
        const num = arr.length / n; // 数组长度除该数字
        let res = -1; // 存在返回数字， 不存在返回-1
        
        for(let i = 0; i< arr.length; i++){
            const item = arr[i];
            dp[item]++; //记录arr 数字出现的次数，数字对应下标
        }
        // console.log(dp)
        for(let i = 0 ; i< dp.length; i++){
            if( dp[i] > num ){
                res = i;
            }
        }

        return res;

    }
    console.log( res([1,2,3,3,3,3,5,4,2], 3) )

```


### 零钱兑换

 - 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。


    1.输入：coins = [1, 2, 5], amount = 11
    输出：3 
    解释：11 = 5 + 5 + 1

    2.输入：coins = [2], amount = 3
    输出：-1

    3.输入：coins = [1], amount = 0
    输出：0


```javascript
const coinChange = ( coins, amount ) => {
    const dp = new Array(amount + 1).fill(amount+1);
    dp[0] = 0 ;
    for(let i = 1; i <= amount; i++ ){
        for(let j = 0 ; j < coins.length; j++  ){
            if( coins[j] <= i ){
                dp[i] = Math.min( dp[ i - coins[j] ] + 1 , dp[i] )
            }
        }
    }

    return dp[amount] > amount ? -1 : dp[amount] ;
}


console.log( coinChange( [1, 2, 5], 11 ) ) // 3
```


### 类型判断

```javascript
const isType = (type) => {
    return (target) => {
        return Object.prototype.toString.call(target) === `[object ${type}]`
    }
}

const isArray = isType('Array'); // 首字母大写

console.log( isArray([]) )
```


### 实现数组 非零非负 最小值index

- 例如：[10,21,0,-7,35,7,9,23,18] 输出5,    7最小

```javascript
function getIndex(arr){
    const allNum =  arr.filter((item) => {
        return  item > 0 ; 
    })

    const minIndex = Math.min.apply(null, allNum);

    return arr.findIndex((item) => item === minIndex)
    
}

console.log( getIndex([10,21,0,-7,35,3,9,23,18]) ) // 5
```

### 冒泡排序

```javascript
// 最外层循环控制的内容是循环次数
// 最后一个元素已经是最大的了，所以最后一个元素不用比较 
const sort = (arr) => {
    for(let i = 0; i < arr.length - 1; i++){
        for(let j = 0; j < arr.length - i - 1 ; j++){
            console.log(' arr.length - i - 1', arr.length - i - 1)

            if( arr[j] > arr[j+1] ){
                [ arr[j], arr[j+1] ] = [ arr[j+1], arr[j] ]
            }
        }
    }
    return arr;
}

let arr = [2, 9, 6, 7, 4, 3, 1, 7,1,2,3]
console.log(sort(arr, 1)); // [1, 1, 2, 2, 3, 3, 4, 6, 7, 7, 9]
```

### 去重

```javascript
// 相邻比较 
const unique = (arr) => {
    for(let i = 0; i < arr.length ; i++){
        for(let j = i + 1; j < arr.length ; j++ ){
            if( arr[i] == arr[j] ){
                arr.splice(j, 1);
                j--;
            }
        }
    }
    return arr;
}


let arr = [2, 9, 6, 7, 4, 3, 1, 7,1,2,3]
console.log(unique(arr, 1)) // [1, 2, 3, 4, 6, 7, 9]
```


### 实现 Promise.retry，成功后 resolve 结果，失败后重试，尝试超过一定次数才真正的 reject

```javascript
Promise.retry = function( promiseFn, timers = 3 ){
    return new Promise(async ( resole,  reject ) => {
        while( timers-- ){
            try{
                const res = await promiseFn();
                resole(res);
                console.log(res)
                timers = 0;
                break
            }catch(e){
                if( !timers ){ reject(e) }
            }
        }
    })
}

function getProm() {
    const n = Math.random();
    return new Promise((resolve, reject) => {
        setTimeout(() =>  n > 0.9 ? resolve(n) : reject(n), 1000);
    });
}

Promise.retry(getProm, 3);
```


### 用最简洁代码实现indexOf方法
```javascript
function indexOf(a, b){
    const reg = new RegExp(`${b}`, 'ig');
    const result = reg.exec(a);
    console.log(result); // ["b", index: 1, input: "abc", groups: undefined]

    return result ? result.index : -1;
}

 indexOf('abc', 'b'); // 1  
```


### 二分法实现indexOf

```javascript
// 正序排列
function indexOf( arr, target, start, end ){
    start = start || 0;
    end = end ||  arr.length - 1;
    let mid = Math.floor(( start + end ) / 2); // 中位数
    if( start > end ){
        return -1;
    }

    if( arr[mid] > target ){ // 中位数 大于目标值，|_ _ _ _|____|   end = mid - 1;
        end = mid - 1;
        return indexOf( arr, target, start, end )
    } else if( arr[mid] < target ){  // 中位数 小于于目标值，|____|_ _ _ _|  start = mid + 1;
        start = mid + 1;       
        return indexOf( arr, target, start, end )

    } else {
        return mid;
    }
}

let a = [ 0,1,2,3,4,5,6,434,435 ];
indexOf(a,12)     //-1

indexOf([0,1,2,3,4,5,6,434,435], 5); // 5
```


### 获取N个数组的交集

```js
/**
 * 获取N个数组的交集
 * arrays ===>  const arrays = [arr1, arr2, arr3];
 *
 * */
export function getArrayIntersection(arrays: any[]) {
	if (arrays.length === 0) {
		return [];
	}

	return arrays.reduce((result, currentArray) => {
		return result.filter((item: any) => {
			return currentArray.some((currentItem: any) => {
				return item.value === currentItem.value;
			});
		});
	});
}


// getArrayIntersection([[1],[1,2],[1,3]])
//  ---> [1]

```


### 将多维数组转化为一维

```js
let arr = [
	[0, 1],
	[2, 3],
	[4, [5, 6, 7]],
];

function flatArr(arr) {
	return arr.reduce(function (pre, cur) {
		const flat = Array.isArray(cur) ? flatArr(cur) : cur;
		return pre.concat(flat);
	}, []);
}

console.error(flatArr(arr)); //60

```