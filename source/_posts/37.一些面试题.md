---
title: 三十七、 一些面试题
date: 2020-12-15
tags:
  - 面试
---

### 基本数据类型和引用数据类型

 ##### 一：基本数据类型 Number、String 、Boolean、Null、Undefine Symbol、BigInt
1. 基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值，存放在栈中.
```javascript  
var a = 10;
var b = a;
b = 20;
console.log(a); // 10值
```
##### 二： 引用类型数据 对象类型Object type，比如：Object 、Array 、Function 、Data等。
 1. 引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址，存放在栈堆中.
 ```javascript  
var obj1 = new Object();
var obj2 = obj1;
obj2.name = "我有名字了";
console.log(obj1.name); // 我有名字了
```
##### 三： 使用typeof 可以判断类型

##### 四：区别
1. 基本数据类型的值是不可变的; 引用类型的值是可以改变的
```javascript
var name = "change";
name = "change1";
console.log(name)//change1
```
    `改变只是“指针的指向改变”, 基础类型指的是"change"，而不是name，要区分清楚`

2. 基本数据类型不可以添加属性和方法; 引用类型可以添加属性和方法

3. 基本数据类型的比较是值的比较; 引用类型的比较是引用的比较

4. 基本数据类型是存放在栈区的; 引用类型是同时保存在栈区和堆区中的

### instanceOf 的实现原理

- obj instanceof Object;//true 实例obj在不在Object构造函数中


    1.instanceof主要用于判断某个实例是否属于某个类型，也可用于判断某个实例是否是其父类型或者祖先类型的实例，
    2.instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。
    因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false。

 ```javascript
    const instanceOf = ( left, right ) => {
        let leftVal = left.__proto__;
        let rightVal = right.prototype;
        // 若找不到就到一直循环到父类型或祖类型
        while(true){
            if( leftVal === null ){ return false };
            if( leftVal === rightVal ){
                return true;
            }
            leftVal = leftVal.__proto__; // 获取祖类型的__proto__
        }
    }

 ```


 ### 爬楼梯
 - 每次爬 1 或 2 个台阶，爬上n阶有几种爬法？


    1.一个台阶是1种 ，2个台阶是 2种....

  ```javascript
    const climbStairs = (n) => {
        let dp = new Array(n).fill(0);
        dp[1] = 1; 
        dp[2] = 2; 
        for(let i = 3; i <= n; i++){
            dp[i] = dp[i - 1] + dp[ i - 2];
        }
        return dp[n]
    }

  ```


### new之后发生了什么

- prototype 与 `__proto__`

  1.__proto__ 就是JavaScript中所谓的原型.  
  一个对象的 __proto__ 属性和自己的内部属性[[Prototype]]指向一个相同的值 (通常称这个值为原型),
    原型的值可以是一个对象值也可以是null(比如说Object.prototype.__proto__ 的值就是null).
    该属性可能会引发一些错误,因为用户可能会不知道该属性的特殊性,而给它赋值,从而改变了这个对象的原型. 
    如果需要访问一个对象的原型,应该使用方法Object.getPrototypeOf.


  2. prototype 是function中特有的;
    ```javascript
        function A(name){
            this.name = name;
        }
        console.dir(A);
    ```
    ![](/images/BZ7ZzaR.png)

    `首先看A是一个函数,自然A的原型链就应该指向一个函数对象.
    其次我们还看到当我们定义了function A的时候,A上会有一个 prototype 的属性.
    这个属性是我们定义function的时候就默认带上的.A的 prototype 指向一个对象,
    这个对象的包含一个 constructor 属性以及一个 __proto__ ( __proto__ 指向Object表示这是一个对象).
    默认的constructor属性指向function A.`

  3. __proto__ 是原型,
    prototype是函数默认的一个属性,它指向一个对象,这个对象的constructor属性指向函数本身.



- new之后发生了什么?

```javascript
    // 当我们执行 new A('testa')的时候
    1. var o = new Object();
    2. o. __proto__ = A.prototype;
    3. A.call(o) //由于这里this是指向o,可以把什么this.name/getName绑定到o上.
    4. 把这个o返回给a;//完成var a = new A()的过程.
```


### 给一数组和一数字，求数组中出现次数大于数组长度除该数字的项

```javascript
    const arrCount  = (arr, n) => {
        const dp = new Array(arr.length).fill(0); // 新建一个记录数字次数的数组
        const num = arr.length / n; // 数组长度除该数字
        let res = -1; // 存在返回数字， 不存在返回-1
        
        for(let i = 0; i< arr.length; i++){
            const item = arr[i];
            dp[item]++; //记录arr 数字出现的次数，数字对应下标
        }
        // console.log(dp)
        for(let i = 0 ; i< dp.length; i++){
            if( dp[i] > num ){
                res = i;
            }
        }

        return res;

    }
    console.log( res([1,2,3,3,3,3,5,4,2], 3) )

```