---
title: 十、节日头像小挂件
date: 2020-1-5
tags:
  - canvas
  - 小挂件
---

## 实现思路：
[参考大佬链接](https://juejin.im/post/5e00f66751882512773663dd)
![效果](/images/christmas.png)

上传的头像和小挂件要匹配到一起，利用canvas生成图片，并下载。

<!-- more -->

## 实现代码


- 首先把html写好，再加上一顿CSS操作，样式如下
```javascript
// html
const { targetUrl, loading } = this.state;

<div className={ `${styleCss.avatarBox} ` }>
<div className={ `${styleCss.avatar_main} ${loading ? styleCss.loader : ''}` }>
    <img onClick={ () => this.handleArrowChange('LEFT') } className={ styleCss.arrowLeft } src={ require('@/assets/img/avatar/arrowLeft.svg') } alt=""/>
	<img onClick={ () => this.handleArrowChange('RIGHT') }  className={ styleCss.arrowRight } src={ require('@/assets/img/avatar/arrowRight.svg') } alt=""/>
</div>
<input type="file"   accept="image/*" onChange={ (e) => this.handleUploadImgInit(e) }/>
<img src={ targetUrl } alt="" className={ styleCss.avatar_target }/>
</div>

<canvas className={ styleCss.canvas } ref="canvas" />
```
![](/images/christmas1.png)


### 核心代码

-  1、定义相关变量
```javascript
  const CANVANS_SIZE = 256;
  // 小挂件数组,style位置和大小信息需要自己试验一下
  const imgSourceList = [{
      source: require('@/assets/img/avatar/1.png'),
      style: {
          width: 108,
          height: 88,
          top: `${CANVANS_SIZE - 88}`,
          left: `${CANVANS_SIZE - 108}`
      }
  }, {
      source: require('@/assets/img/avatar/2.png'),
      style: {
          width: 128,
          height: 128,
          top: `${CANVANS_SIZE - 108}`,
          left: `${CANVANS_SIZE - 118}`
      }
  }, {
      source: require('@/assets/img/avatar/3.png'),
      style: {
          width: 96,
          height: 108,
          top: `${CANVANS_SIZE - 128}`,
          left: `${CANVANS_SIZE - 86}`
      }
  }, {
      source: require('@/assets/img/avatar/4.png'),
      style: {
          width: CANVANS_SIZE,
          height: 226,
          top: -38,
          left: 0
      }
  }, {
      source: require('@/assets/img/avatar/5.png'),
      style: {
          width: 100,
          height: 126,
          top: 0,
          left: CANVANS_SIZE / 3
      }
  }];

  this.state={
      decorationCurrent: imgSourceList[0], // 小挂件1
      decorationList: imgSourceList, // 小挂件数组
      currentIndex:0, // 当前挂件下标
      loading:false // 是否显示加载
  }
```
-  2、初始化canvas
```javascript
  componentDidMount(){
    const { decorationCurrent } = this.state;
    // 初始化挂载小挂件
    this.handleMakeImage(null, decorationCurrent).then(targetUrl => {
        this.setState({
            targetUrl
        });
    });
	// 挂载canvas
    this.initCanvas();
  }

  initCanvas() {
    const { canvas } = this.refs;
    canvas.width = CANVANS_SIZE;
    canvas.height = CANVANS_SIZE;
  }
```

- 3、上传图片
```javascript
  async handleUploadImgInit(e){
    const _this = this;
    const target = e.target;
    const { canvas } = this.refs;
    const { decorationCurrent } = this.state;
    const context = canvas.getContext('2d');
    const files = e.target.files[0]; // 上传的图片
    const base64Url = await this.handleBase64Img(files);
    const imgObj = await this.createImage(base64Url);

	// 调整用户图片尺寸
	// 无论宽大于高还是宽小于高，都会进行等比缩放
    const type = imgObj.width - imgObj.height;
    if (type > 0) { // 宽 > 高
        const w = imgObj.width * CANVANS_SIZE / imgObj.height;
        context.drawImage(imgObj, 0, 0, w, CANVANS_SIZE);
    } else if (type < 0) { // 宽 < 高
        const h = imgObj.height * CANVANS_SIZE / imgObj.width;
        context.drawImage(imgObj, 0, 0, CANVANS_SIZE, h);
    } else {
        context.drawImage(imgObj, 0, 0, CANVANS_SIZE, CANVANS_SIZE);
	}
	// canvas转图片
    const imgUrl = canvas.toDataURL('image/png');
    this.setState({
        imgUrl:imgUrl
    },() => {
        target.value = ''; // 可以重复上传同一张图片
    })

    this.handleMakeImage(imgUrl, decorationCurrent).then(targetUrl => {
        this.setState({
            targetUrl
        });
    });
  }

  // 上传图片base64转化
  handleBase64Img(files){
      return new Promise((resolve,reject) => {
          let reads = new FileReader();
          reads.readAsDataURL(files);
          reads.onload = function(e) {
              resolve(this.result);
          };
      })
      
  }

  // 创建图片
  createImage(imgUrl) {
      return new Promise((resolve, rejest) => {
          const imgObj = new Image();
          imgObj.src = imgUrl;
          imgObj.onload = (e) => {
              resolve(imgObj);
          };
      });
  }

```
- 4、把头像和挂件组合在一起，生成图片链接（关键）
```javascript
  /**
   *  @param { string } imgUrl -- 处理的用户图片url
   *  @param { object } decorationCurrent -- 小挂件
   * */ 
  async handleMakeImage(imgUrl, decorationCurrent){
    if (!(imgUrl || decorationCurrent)) { return ''; }
    const { source, style } = decorationCurrent;
    const { width, height, top, left } = style;
    const { canvas } = this.refs;
    this.clearCanvas(canvas);
    const context = canvas.getContext('2d');
    if (imgUrl) {
        const bgImg = await this.createImage(imgUrl);
        context.drawImage(bgImg, 0, 0, bgImg.width, bgImg.height);
    }
    if (decorationCurrent && source) {
        const imgObj = await this.createImage(source);
        context.drawImage(imgObj, left, top, width, height);
    }
    const targetUrl = canvas.toDataURL('image/png');
    return targetUrl;
  }

  clearCanvas(targetCanvans) {
      let ctx = targetCanvans.getContext('2d');
      ctx.clearRect(0, 0, targetCanvans.width, targetCanvans.height);
  }
```
- 5、左右切换小挂件
```javascript
  handleArrowChange(type){
        const { decorationList  } = this.state;
        const length = decorationList.length - 1;
        let index = 0;
        this.setState((prvState) =>{
            if(type === 'LEFT'){ // 左
                index = --prvState.currentIndex < 0  ? length : prvState.currentIndex;
            } else { // 右
                index = ++prvState.currentIndex > length ? 0 : prvState.currentIndex;
            }
            return {
                loading:true,
                currentIndex:index,
                decorationCurrent: imgSourceList[index],
            }
        }, () => {
            const { imgUrl, decorationCurrent} = this.state;
            this.handleMakeImage(imgUrl, decorationCurrent).then(targetUrl => {
                this.setState({
                    targetUrl,
                    loading:false,
                });
            });
        })
    }
```