---
title: 三十四、 canvas学习
date: 2020-10-15
tags:
  - canvas
  - 雷达图
---

- [MDN链接](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes)

### 1.矩形

1. 填充以(x,y)为起点宽高分别为width、height的矩形 默认为黑色
 - fillRect( x , y , width , height)
2. 绘制一个空心以(x,y)为起点宽高分别为width、height的矩形
 - stokeRect( x , y , width , height)
3. 清除以(x,y)为起点宽高分别为width、height的矩形 为透明 
 - clearRect( x, y , width , height ) 

### 2.路径

1. 新建一条路径一旦创建成功 绘制命令将转移到新建的路径上
 - beginPath()
2. 闭合路径，将绘制指令重新转移到上下文
 - closePath()
3. 将绘制的路径进行描边
 - stroke()
4. 将绘制的封闭区域进行填充
 - fill()

 > 注意：当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。

5. 移动画笔到(x , y) 点开始后面的绘制工作
 - moveTo(x, y)
6. 绘制一条从当前位置到指定x以及y位置的直线
 - lineTo(x, y)

### 3.圆弧

1. 以(x,y)为圆心 r为半径的圆  绘制startAngle弧度 到endAngle弧度的圆弧 anticlosewise默认为false 即顺时针方向 true为逆时针方向
 - arc( x , y , r , startAngle , endAngle ,  anticlosewise )

2. 根据 两个控制点 (x1,y1) 和 (x2, y2)以及半径绘制弧线 同时连接两个控制点
 - arcTo( x1 , y1 , x2 , y2 , radius )

### 4.文本

1.  在(x,y)位置绘制text文本  最大宽度为maxWidth(可选)
 - fillText( text , x , y , [,maxWidth])
2. 在(x,y)位置绘制text文本边框  最大宽度为maxWidth(可选)
 - strokeText( text ,x ,y ,[,maxWidth])
3. 文本大小、字体
 - font = '20px sans'
4. 文本颜色
 - fillStyle = color

### 5.绘制图片

1. image为图片对象、从(x,y)处放置宽高分别为width height的图片
 - drawImage( image , x , y , width , height ) 
 - eg: 
```javascript
const img = new Image();
img.src = require(`@/assets/img/nation/lottery/img.png`);
context.drawImage( img , -20 , 42 , 45 , 20);
```

### 6.动作

1. 将canvas原点的移动到 (x,y)     （save&restore保存初始状态！！！）
 - translate( x , y )
2. 顺时针方向旋转坐标轴 angle弧度
 - rotate( angle )
3. 将图形横向缩放x倍、纵向缩放y倍   
 - scale(x,y)

### 7. 状态保存 恢复

1. 状态保存
 - save()
2. 状态恢复
 - restore()

### 定时执行

1. requestAnimationFrame()
2. id && window.cancelAnimationFrame(id)

***

### 雷达图

- [雷达图](https://juejin.im/post/6844903854966849550)

![](/images/leida.png)

```javascript
  // html:
  <canvas ref={ currCanvas } height="1000" width="600"></canvas>

  // js:
  const canvas = currCanvas.current;
  const bgCanvas = document.createElement('canvas')
  const offCanvas = document.createElement('canvas')

  const bgCtx = bgCanvas.getContext('2d')
  const offCtx = offCanvas.getContext('2d')

  const canvasW = canvas.width
  const canvasH = canvas.height

  offCanvas.width = bgCanvas.width = canvasW
  offCanvas.height = bgCanvas.height = canvasH
  
  // 重新映射 canvas的 (0, 0)，映射的结果是让canvas的坐标原点位于 canvas的中心位置
  // 主要是为了后续方便绘图
  bgCtx.translate(canvasW / 2, canvasH / 2)
  ctx.translate(canvasW / 2, canvasH / 2)
  offCtx.translate(canvasW / 2, canvasH / 2)

  // 雷达图数据
  const mData = [
      { titleList: ['爱心传递至', '3个城市'], score: 3, fullScore: 5 },
      { titleList: ['帮助了8人'], score: 5, fullScore: 10 },
      { titleList: [`收到5感谢`], score: 5, fullScore: 10 },
      { titleList: ['获得', '15人点赞'], score: 15, fullScore: 15 },
      { titleList: [`可赠送10件闲置`], score: 10, fullScore: 20 },
      { titleList: [`11111`], score: 200, fullScore: 100 }

  ]

  // 多边形的边数
  const mCount = mData.length
  // 最外层多边形边长
  const prismW = 200
  // 最外层多边形外接圆半径
  const mRadius = prismW / 2 / Math.cos(108 / 2 / 180 * Math.PI)
  // 多边形的内角角度
  const mAngle = Math.PI * 2 / mCount
  // 需要多少个多边形线框
  const polygonCount = 5
  const sAngle = (90 / mCount) / 180 * Math.PI

  // 需要旋转多少度，才能将多边形旋转到底边平行于 X轴，奇多边形才需要，偶多边形不需要旋转
  // 主要是为了方便计算坐标
  const rotateAngle = mCount % 2 === 0 ? 0 : (sAngle * (mCount % 4 === 3 ? -1 : 1))
  bgCtx.rotate(-rotateAngle)
  offCtx.rotate(-rotateAngle)

  // 保存最外层多边形各个顶点的坐标
  const polygonPoints = []
  // 雷达区域顶点坐标
  const radarVertex = []
  // 多边形线颜色
  bgCtx.strokeStyle = '#ccc'
  // 雷达区域边线 width
  offCtx.lineWidth = 1

  // 绘制多边形，包括多边形对角顶点之间的连线
  drawPolygon()
  // ctx.drawImage(bgCanvas, -canvasW / 2, -canvasH / 2, canvasW, canvasH)
  // 绘制多边形顶点处文案
  drawVertexTxt()
  // 绘制雷达区域
  drawRadar()

  // 绘制多边形
  function drawPolygon () {
      // #region 绘制多边形
      const r = mRadius / polygonCount
      let currentRadius = 0
      for (let i = 0; i < polygonCount; i++) {
      bgCtx.beginPath()
      currentRadius = r * (i + 1)
      for (let j = 0; j < mCount; j++) {
          const x = currentRadius * Math.cos(mAngle * j)
          const y = currentRadius * Math.sin(mAngle * j)
          // 记录最外层多边形各个顶点的坐标
          if (i === polygonCount - 1) {
          polygonPoints.push([x, y])
          }
          j === 0 ? bgCtx.moveTo(x, y) : bgCtx.lineTo(x, y)
      }
      bgCtx.closePath()
      bgCtx.stroke()
    }
      // #endregion

      // #region 绘制多边形对角连线
      for (let i = 0; i < polygonPoints.length; i++) {
      bgCtx.moveTo(0, 0)
      bgCtx.lineTo(polygonPoints[i][0], polygonPoints[i][1])
      }
      bgCtx.stroke()
      // #endregion
  }

  // 绘制多边形对角连线
  function drawDiagonal () {
      bgCtx.save()
      for (let i = 0; i < polygonPoints.length; i++) {
      bgCtx.moveTo(0, 0)
      bgCtx.lineTo(polygonPoints[i][0], polygonPoints[i][1])
      }
      bgCtx.stroke()
      bgCtx.restore()
  }

  // 绘制多边形顶点处文案
  function drawVertexTxt () {
      bgCtx.font = 'normal normal lighter 16px Arial'
      bgCtx.fillStyle = '#333'
      // 奇数多边形，距离设备顶边最近的点（即最高点的那一点），需要专门设置一下 textAlign
      const topPointIndex = mCount - Math.round(mCount / 4)
      for (let i = 0; i < polygonPoints.length; i++) {
      bgCtx.save()
      bgCtx.translate(polygonPoints[i][0], polygonPoints[i][1])
      bgCtx.rotate(rotateAngle)
      let indentX = 0
      let indentY = 0
      if (i === topPointIndex) {
          // 最高点
          bgCtx.textAlign = 'center'
          indentY = -8
      } else {
          if (polygonPoints[i][0] > 0 && polygonPoints[i][1] >= 0) {
          bgCtx.textAlign = 'start'
          indentX = 10
          } else if (polygonPoints[i][0] < 0) {
          bgCtx.textAlign = 'end'
          indentX = -10
          }
      }
      // 如果是正四边形，则需要单独处理最低点
      if (mCount === 4 && i === 1) {
          bgCtx.textAlign = 'center'
          indentY = 10
      }
      // 开始绘制文案
      mData[i].titleList.forEach((item, index) => {
          bgCtx.fillText(item, indentX, indentY + index * 20)
      })
      bgCtx.restore()
      }
  }

  // 绘制雷达区域
  function drawRadar () {
      let score = null
      let xList = []
      let yList = []
      // 计算并存储雷达区域顶点坐标
      for (let i = 0; i < mCount; i++) {
      // score不能超过 fullScore
          score = Math.min(mData[i].score, mData[i].fullScore)
          xList.push(Math.cos(mAngle * i) * score / mData[i].fullScore)
          yList.push(Math.sin(mAngle * i) * score / mData[i].fullScore)
          radarVertex.push([mRadius * xList[i], mRadius * yList[i]])
      }
      // 裁剪选区，比真实的雷达区域大一圈(indentV)，这是为了保证完全遮罩
      const indentV = 40
      offCtx.beginPath()
      for (let i = 0; i < mCount; i++) {
          score = Math.min(mData[i].score, mData[i].fullScore)
          const x = (mRadius + indentV) * xList[i]
          const y = (mRadius + indentV) * yList[i]
          i === 0 ? offCtx.moveTo(x, y) : offCtx.lineTo(x, y)
      }
      offCtx.closePath()
      offCtx.clip()

      const toAngle = 2 * Math.PI
      const canvasMaxSize = Math.max(canvasW, canvasH)
      // 将离屏 canvas上的 雷达图区域画到主 canvas上，用圆来填充，产生视觉上的雷达图逐渐填充的效果
      const ltX = -canvasW / 2
      const ltY = -canvasH / 2
      const rqDraw = currentAngle => {
      ctx.clearRect(ltX, ltY, canvasW, canvasH)
      offCtx.clearRect(ltX, ltY, canvasW, canvasH)

      // #region 绘制雷达区域
      offCtx.beginPath()
      for (let i = 0; i < mCount; i++) {
          i === 0
          ? offCtx.moveTo(radarVertex[i][0], radarVertex[i][1])
          : offCtx.lineTo(radarVertex[i][0], radarVertex[i][1])
      }
      offCtx.fillStyle = 'rgba(204,0,0,0.3)'
      offCtx.strokeStyle = 'red'
      offCtx.closePath()
      offCtx.stroke()
      offCtx.fill()
      // #endregion
      
      // #region 绘制覆盖雷达区域的遮罩
      offCtx.save()
      offCtx.beginPath()
      offCtx.globalCompositeOperation = 'destination-in'
      offCtx.moveTo(0, 0)
      offCtx.arc(0, 0, canvasMaxSize, 0, currentAngle)
      offCtx.closePath()
      offCtx.fillStyle = 'blue'
      offCtx.fill()
      offCtx.restore()
      // #endregion

      ctx.drawImage(bgCanvas, ltX, ltY)
      ctx.drawImage(offCanvas, ltX, ltY)
      // 动态雷达图绘制完毕的标识
      if (currentAngle === toAngle) {
          return drawVertexDot()
      }
      let newAngle = currentAngle + 0.25
      if (newAngle > toAngle) newAngle = toAngle
      // requestAnimationFrame(() => {
      //   rqDraw(newAngle)
      // })
          setTimeout(() => {
              rqDraw(newAngle)
          }, 16)
      }
      rqDraw(0)
  }

  // 雷达图绘制结束后，在雷达区域的顶点处绘制小圆点
  function drawVertexDot () {
      ctx.rotate(-rotateAngle)
      ctx.fillStyle = '#fe5c5b'
      const dotRadius = 4
      const len = radarVertex.length
      // 画点
      const rqDrawDox = currentDotRadius => {
      for (let i = 0; i < len; i++) {
          ctx.beginPath()
          ctx.arc(radarVertex[i][0], radarVertex[i][1], currentDotRadius, 0, 2 * Math.PI)
          ctx.fill()
      }
      if (currentDotRadius < dotRadius) {
          requestAnimationFrame(() => {
              rqDrawDox(currentDotRadius + 0.5)
          })
      }
      }
      rqDrawDox(1)
  }
```


***

### 弹幕

```javascript

class Barrage {
    constructor(canvas) {
        this.canvas = currCanvas.current;
        let rect = this.canvas.getBoundingClientRect();
        this.w = rect.right - rect.left;
        this.h = rect.bottom - rect.top;
        this.ctx = this.canvas.getContext('2d');
        this.ctx.font = '20px Microsoft YaHei';
        this.barrageList = [];
    }

    //添加弹幕列表
    shoot(value) {
        let top = this.getTop();
        let color = this.getColor();
        let offset = this.getOffset();
        let width = Math.ceil(this.ctx.measureText(value).width);

        let barrage = {
            value: value,
            top: top,
            left: this.w,
            color: color,
            offset: offset,
            width: width
        }
        this.barrageList.push(barrage);
    }

    //开始绘制
    draw() {
        if (this.barrageList.length) {
            // 清除绘制内容
            this.ctx.clearRect(0, 0, this.w, this.h);
            for (let i = 0; i < this.barrageList.length; i++) {
                let b = this.barrageList[i];
                // 当文本超出画布时移出弹幕列表
                if (b.left + b.width <= 0) {
                    this.barrageList.splice(i, 1);
                    i--;
                    continue;
                }
                b.left -= b.offset;
                this.drawText(b);
            }
        }
        requestAnimationFrame(this.draw.bind(this));
    }

    //绘制文字
    drawText(barrage) {
        this.ctx.fillStyle = barrage.color;
        this.ctx.fillText(barrage.value, barrage.left, barrage.top);
    }

    //获取随机颜色
    getColor() {
        return '#' + Math.floor(Math.random() * 0xffffff).toString(16);
    }

    //获取随机top
    getTop() {
        //canvas绘制文字x,y坐标是按文字左下角计算，预留30px
        return Math.floor(Math.random() * (this.h - 30)) + 30;
    }

    //获取偏移量
    getOffset() {
        return +(Math.random() * 4).toFixed(1) + 1;
    }

}

let barrage = new Barrage('canvas');
barrage.draw();

const textList = ['弹幕', '666', '233333333', 
    'javascript', 'html', 'css', '前端框架', 'Vue', 'React',
    'Angular','测试弹幕效果',
];

textList.forEach((t) => {
    barrage.shoot(t);
})

```