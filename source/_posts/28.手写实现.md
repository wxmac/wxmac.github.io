---
title: 二十八、手写实现
date: 2020-8-10
tags:
  - 手写实现
---

### 1.手写reduce
```javascript
Array.prototype.reduce = function(fn, val) {
    // 很好理解，就判断val是否有传入值
    for (let i = 0; i < this.length; i++) {
        // 没有传入值
        if (typeof val === 'undefined') {
            // total对应this[i], cur对应this[i + 1]
            // index当前索引i + 1, array数组本尊是this
            val = fn(this[i], this[i + 1], i + 1, this);
        } else { // 有传入val值
            // total就是初始值val，之后的依次传入对应
            val = fn(val, this[i], i, this);
        }
    }
    return val;
};
```

### 手写call 和 apply

- 区别点是传递的第2个参数的形式，apply必须是数组，call则是任意类型而且可传多个参数。

```javascript
// call实现
Function.prototype.call = function(context, ...args) {
    // 执行上下文都保证是对象类型，如果不是就是window
    context = Object(context) || window;
    // 创建一个额外的变量当做context的属性
    const fn = Symbol();
    // 给这个fn属性赋值为当前的函数
    context[fn] = this;
    // 执行函数把...args传入
    const result = context[fn](...args);
    // 删除使用过的fn属性
    delete context[fn];
    // 返回函数执行结果
    return result;
};

// apply实现
Function.prototype.apply = function(context, arrArgs) {
    context = Object(context) || window;
    const fn = Symbol();
    context[fn] = this;
    // 需要把传入apply的数组进行展开运算
    // 所以在这里性能会有些消耗相比call来讲
    const result = context[fn](...arrArgs);
    delete context[fn];
    return result;
}

```

### 手写bind
```javascript
Function.prototype.bind = function(context, ...args) {
    // context为要改变的执行上下文
    // ...args为传入bind函数的其余参数
    return (...newArgs) => {
        // 这里返回一个新的函数
        // 通过调用call方法改变this指向并且把老参和新参一并传入
        return this.call(context, ...args, ...newArgs);
    }
};

```

### 手写New
```javascript
// 手写new
function New(Super, ...args) {
    // 创建一个继承构造函数原型的对象
    let obj = Object.create(Super.prototype);
    // res是表示构造函数返回的结果
    let res = Super.call(obj, ...args);
    // 第一个条件是返回对象
    // 第二个条件是返回函数
    if ((res !== null && typeof res === 'object') || typeof res === 'function') {
        return res;
    }
    // 返回新对象
    return obj;
}

```


### 手写柯里化函数

```javascript
// 柯里化函数
function curry(fn, ...args) {
    // 如果传递的参数还没有达到要执行的函数fn的个数
    // 就继续返回新的函数(高阶函数)
    // 并且返回curry函数传递剩下的参数
    if (fn.length == args.length) {
        return fn(...args)
    }

    return function(...newArgs) {
        return curry(fn, ...args, ...newArgs)
    }

}


function add(a, b) {
    return a + b
}

console.log(curry(add, 1)(2)) // 3
console.log(curry(add, 1, 2)) // 3
```
