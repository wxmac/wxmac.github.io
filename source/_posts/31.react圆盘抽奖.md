---
title: 三十一、 react圆盘抽奖
date: 2020-9-15
tags:
  - react
  - 抽奖
---

- 使用

```javascript

 const awardsList = [
	{gift_value: "140", index_num: 1, gift_name: "140元加油券", product_no: "FO-100438-14"},
	{gift_value: "2999", index_num: 2, gift_name: "2999元空气净化器"},
	{gift_value: "210", index_num: 3, gift_name: "210元加油券", product_no: "FO-100438-16"},
	{gift_value: "50", index_num: 4, gift_name: "50元美容养护券", product_no: "CW"},
	{gift_value: "200", index_num: 5, gift_name: "200元加油券", product_no: "FO-100438-09"},
	{gift_value: "144", index_num: 6, gift_name: "144元车载香薰"},
	{gift_value: "80", index_num: 7, gift_name: "80元加油券", product_no: "FO-100438-07"},
	{gift_value: "15", index_num: 8, gift_name: "15元洗车券", product_no: "CW"},
	{gift_value: "70", index_num: 9, gift_name: "70元加油券", product_no: "FO-100438-13"},
	{gift_value: "549", index_num: 10, gift_name: "549元行车记录仪"},
	{gift_value: "350", index_num: 11, gift_name: "350元加油券", product_no: "FO-100438-18"},
	{gift_value: "0", index_num: 12, gift_name: "谢谢参与"}
]

<Lottery lotteryStart = { () => {
    console.log('start')
} } 
hasChange = { true } 
resultIndex = { currIndex }
awardsList={ awardsList } 
handleLotterySuccess={ (curr) => {
  onsole.log(curr)
} } />
```

- HTML + js

```javascript

/************ data.js ***************/ 
// i等于奖品下标
let Imgconfig = []; 
let rewardLength = 12; // 奖品长度
for( let i = 0; i < rewardLength; i++ ){
    Imgconfig[i] = new Image();
    Imgconfig[i].src = require(`@/assets/img/nation/lottery/img${i}.png`);
}

export default Imgconfig;

/************ index.js ***************/  
/*
 * @Author: hwh
 * @Date: 2020-04-23 18:50:20
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2020-09-25 11:44:52
 *  圆盘抽奖组件
 */ 
import React, { useState, useRef, useEffect } from 'react'
import styleCss from './style.less';
import  '@/units/isLoginApp';
import Imgconfig from './data';
import { getParams, getFuncId, getPostData, isApp, trackEvent } from '@/units/common';


class Lottery extends React.Component {
    constructor(props){
      	super(props);
		this.state = {
				awards: [],//大转盘的奖品列表
				animation: true,
				fileRootPath: "",//"http://co.dev.touty.io"
				startRadian: -90 * Math.PI / 180,//大转盘的开始弧度(canvas绘制圆从水平方向开始，所以这里调整为垂直方向) 弧度计算公式：角度*Math.PI/180
				canBeClick: true,//判断抽奖有没有结束
				canvas: '',
				content: '',
				resultIndex: -1
		}
	}

	// // 获取配置
	componentWillReceiveProps(props){
		// 奖品配置列表
		if( props.awardsList && props.awardsList.length > 0 ){
			this.setState({
				awards:  props.awardsList
			})
			this.onLoadPage( props.awardsList ); // 初始化配置
		}
		// 是否可以点击
		// console.log('props.hasChange', props.hasChange)
		this.setState({
			canBeClick: props.hasChange
		})

		// console.log('resultIndex',props.resultIndex && props.resultIndex > -1  )
		// 获取抽奖下标
		if( props.resultIndex && props.resultIndex > -1  ){
			this.setState({
				resultIndex: props.resultIndex - 1
			}, () => {
				this.draw()
			})
		}
    

	}
	//   初始化配置	
    onLoadPage(awards) {
		let { startRadian } = this.state;
		let canvas = document.getElementById("wheelcanvas");
		// 获取canvas的上下文,context含有各种api用来操作canvas
		let context = canvas.getContext('2d');
		this.setState({canvas: canvas, context: context});
		context.save();
		// 新建一个路径,画笔的位置回到默认的坐标(0,0)的位置
		// 保证了当前的绘制不会影响到之前的绘制
		context.beginPath();
		// 设置填充转盘用的颜色,fill是填充而不是绘制
		context.fillStyle = '#fff';
		// 绘制一个圆,有六个参数,分别表示:圆心的x坐标,圆心的y坐标,圆的半径,开始绘制的角度,结束的角度,绘制方向(false表示顺时针)
		context.arc(211, 211, 211, startRadian, Math.PI * 2 + startRadian, false);
		// 将设置的颜色填充到圆中,这里不用closePath是因为closePath对fill无效.
		context.fill();
  
		// 将画布的状态恢复到上一次save()时的状态
		context.restore();
		// 第一个奖品色块开始绘制时开始的弧度及结束的弧度
		let RadianGap = Math.PI * 2 / awards.length, endRadian = startRadian + RadianGap;

		
		

		for (let i = 0; i < awards.length; i++) {
			context.save();
			context.beginPath();
			// 为了区分不同的色块,使用随机生成的颜色作为色块的填充色
			context.fillStyle = i % 2 == 0 ? 'rgba(247,193,11,1)' : 'rgba(250,213,11,1)';
			// 这里需要使用moveTo方法将初始位置定位在圆点处,这样绘制的圆弧都会以圆点作为闭合点
			context.moveTo(211, 211);
			// 画圆弧时,每次都会自动调用moveTo,将画笔移动到圆弧的起点,半径设置的比转盘稍小一点
			context.arc(211, 211, 211, startRadian, endRadian, false);
			context.fill();
			context.restore();
			// 开始绘制文字
			context.save();
			//设置文字颜色
			context.fillStyle = '#f00';
			//设置文字样式
			context.font = "16px Arial";
			// 改变canvas原点的位置,简单来说,translate到哪个坐标点,那么那个坐标点就将变为坐标(0, 0)
			context.translate(
				211 + Math.cos(startRadian + RadianGap / 2) * 201,
				211 + Math.sin(startRadian + RadianGap / 2) * 201
			);
	
			// 旋转角度,这个旋转是相对于原点进行旋转的.
			context.rotate(startRadian + RadianGap / 2 + Math.PI / 2);


			// 这里就是根据获取的各行的文字进行绘制,maxLineWidth取150,相当与一行最多展示个10文字

			// 文字一：奖品名称
			const  gift_name = awards[i].gift_name;
			const name =  gift_name.indexOf('元') > -1 ? gift_name.split('元')[1] : gift_name;
			this.getLineTextList(context, name , 70).forEach((line, index) => {
			// 绘制文字的方法,三个参数分别带:要绘制的文字,开始绘制的x坐标,开始绘制的y坐标
				context.fillText(line, -context.measureText(line).width / 2, ++index * 25)
			});

			// 文字二：奖品价格
			const price =  awards[i].gift_value;
			const newPrice = price && price > 0 ? '￥'+ price : '';
			const inudesArr = [ 1, 5, 9  ];
			if( inudesArr.includes(i) ){
				this.getLineTextList(context, newPrice , 70).forEach((line, index) => {
					context.fillText( line, -context.measureText(line).width / 2, ++index * 90)
				});
			}
			
			// 渲染图片
			this.handleRenderAllImg(context, i)

			context.restore();
			
			// 每个奖品色块绘制完后,下个奖品的弧度会递增
			startRadian += RadianGap;
			endRadian += RadianGap;
      	}
		//下面是画中间的小圆
		context.save();
		// 新建一个路径,画笔的位置回到默认的坐标(0,0)的位置
		// 保证了当前的绘制不会影响到之前的绘制
		context.beginPath();
		// 设置填充转盘用的颜色,fill是填充而不是绘制
		context.fillStyle = '#fff';
		// 绘制一个圆,有六个参数,分别表示:圆心的x坐标,圆心的y坐标,圆的半径,开始绘制的角度,结束的角度,绘制方向(false表示顺时针)
		context.arc(211, 211, 70, startRadian, Math.PI * 2 + startRadian, false);
		// 将设置的颜色填充到圆中,这里不用closePath是因为closePath对fill无效.
		context.fill();
		// 将画布的状态恢复到上一次save()时的状态
		context.restore();
	}

	//   渲染图片	
	handleRenderAllImg( context, i ){

		const inudesArr = [ 1, 5, 9 ,11 ]; // 其他图片类型
		if( !inudesArr.includes(i) ){
			context.drawImage( Imgconfig[i] , -20 , 42 , 45 , 20);
		}

		// 单独处理
		switch(i){
			case 1: { // 净化器
				context.drawImage( Imgconfig[1] , -20 , 30 , 40 , 40);
				break;
			}
			case 5: { // 香薰
				context.drawImage( Imgconfig[5] , -20 , 25 , 50 , 50);
				break;
			}
			case 9: { // 记录仪
				context.drawImage(  Imgconfig[9] , -15 , 35 , 30 , 30);
				break;
			}
			case 11: { // 谢谢参与
				context.drawImage(  Imgconfig[11] , -15 , 35 , 30 , 30);
				break;
			}
			default: {}
		}
	}
	//   绘制文字，文字过长进行换行，防止文字溢出	
    getLineTextList(context, text, maxLineWidth) {
		let wordList = text.split(''), tempLine = '', lineList = [];
		for (let i = 0; i < wordList.length; i++) {
			if (context.measureText(tempLine).width >= maxLineWidth) {
				lineList.push(tempLine);
				maxLineWidth -= context.measureText(text[0]).width;
				tempLine = ''
			}
			tempLine += wordList[i]
		}
		
		lineList.push(tempLine);
		return lineList
    }
	// 将canvas在window中的坐标点转化为canvas中的坐标点
    windowToCanvas(canvas, e) {
		// getBoundingClientRect这个方法返回html元素的大小及其相对于视口的位置
		const canvasPostion = canvas.getBoundingClientRect(), x = e.clientX, y = e.clientY;
		return {
			x: x - canvasPostion.left,
			y: y - canvasPostion.top
		}
    };
	//点击抽奖让转盘转起来
    draw(e) {
		const { canBeClick, awards, resultIndex } = this.state;
		// 只要抽奖没有结束，就不让再次抽奖
		
		if (!canBeClick) return;

		// 抽奖下标大于数组长度
		if( resultIndex > awards.length - 1  ){
			window.global.showMsg('配置错误', true)
			return;
		}
		// 开始抽奖
	

		this.setState({ 
			canBeClick: false,
			startRadian: 0
		}, () => {
			// 每次点击抽奖，都将初始化角度重置
			const distance = this.distanceToStop();
			this.rotatePanel(distance);//调用处理旋转的方法
			
		})
		
	}
	
	// 处理旋转的关键方法
    rotatePanel(distance) {
		let animateId = '';
		// 这里用一个很简单的缓动函数来计算每次绘制需要改变的角度，这样可以达到一个转盘从快到慢的渐变的过程
		const { startRadian, awards } = this.state;
		const changeRadian = Math.abs((distance - startRadian) / 20);
		this.setState((prev) => {
			return {
				startRadian: prev.startRadian += changeRadian
			}
		})

		// 当最后的目标距离与startRadian之间的差距低于0.0001时，就默认奖品抽完了，可以继续抽下一个了。
		if (distance - startRadian <= 0.001) {
			// 抽奖完成，传递给父元素
			this.props.handleLotterySuccess();
			animateId && window.cancelAnimationFrame(animateId)
			
			this.setState({
				canBeClick: true,
				resultIndex: -1
			})
			return;
		};
		// 初始角度改变后，需要重新绘制
		this.onLoadPage(awards);
		// 循环调用rotatePanel函数，使得转盘的绘制连续，造成旋转的视觉效果
		animateId = window.requestAnimationFrame(this.rotatePanel.bind(this, distance));
    }
  
	// 停止旋转的角度
    distanceToStop() {
		let { awards } = this.state;

		// middleDegrees为奖品块的中间角度（最终停留都是以中间角度进行计算的）距离初始的startRadian的距离，distance就是当前奖品跑到指针位置要转动的距离。
		let middleDegrees = 0, distance = 0;
		// 映射出每个奖品的middleDegrees
		let awardsToDegreesList = awards.map((data, index) => {
			let awardRadian = (Math.PI * 2) / awards.length;
			return awardRadian * index + (awardRadian * (index + 1) - awardRadian * index) / 2
		});

		
		// resultIndex索引值，来表示此次抽奖应该中的奖品
		const currentPrizeIndex = this.state.resultIndex;
		
		middleDegrees = awardsToDegreesList[currentPrizeIndex];


		// 因为指针是垂直向上的，相当坐标系的Math.PI/2,所以这里要进行判断来移动角度
		distance = Math.PI * 3 / 2 - middleDegrees;
		distance = distance > 0 ? distance : Math.PI * 2 + distance;
		// 这里额外加上后面的值，是为了让转盘多转动几圈，看上去更像是在抽奖
		return distance + Math.PI * 1000 ;
	}
	
	 handleLotteryStart = async () => {
		this.props.lotteryStart()
	}
    
    render(){
		const { canBeClick, resultIndex, awards } = this.state;
		const { changeWidth } = this.props;

		const styleC = {
			width: changeWidth
		}
        return <div className={ styleCss.wheel_container }>
			<div className={ styleCss.wheel_main}>
				<div className={ styleCss.wheel}>
					{/* 转盘背景 */}
					<img props="" alt="" className={ styleCss.wheel_circle} 
					src={ require('@/assets/img/lottery/lottery_box.png') }/>
					{/* 转盘 */}
					<canvas style={ changeWidth && styleC } className={ styleCss.item } id="wheelcanvas" height={422} width={422}/>
					{/* 开始按钮 */}
					<img props="" alt="" 
					onClick={  () => {
							this.handleLotteryStart()
						}
					  } className={ `${styleCss.pointer} 
					${ !canBeClick ? styleCss.dis : '' }` } 
					src={ require('@/assets/img/lottery/lottery_btn.png') }/>
				</div>
			</div>
			
        </div>
    }
  }
  export default Lottery;
```


- css
```javascript
.wheel_container{
    width: 100%;
    .wheel_main{
        text-align: center;
        position: relative;
        background-size: auto 100%;
        background-position: center;
        margin: 0 auto;
        width: 100%;
      .wheel{
        margin: 0 auto;
        width: 100%;
        position: relative;
		&_circle{
			position: relative;
			width: 8rem;
		}
		.item{
			position: absolute;
			width: 6rem;
			top: 49.3%;
			left: 50%;
			transform: translate(-50%, -50%);
		}
        .pointer{
			position: absolute;
			width: 45%;
			height: 45%;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			cursor: pointer;
			transition: all .3s;
          
        }
        .dis{
			opacity: .6;
			filter: grayscale(.8);
        }
      }
    }
	img{
		max-width: 100%;
	}
}
  
  
```

