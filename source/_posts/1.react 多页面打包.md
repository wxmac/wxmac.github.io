
---
title: 一、React 多页面打包
date: 2019-12-06
tags:
  - react
  - js
  - webpack
---


## 缘由

- 之前我们用的是react单页面打包，方便是方便，开包即用。但是因为我们做的是活动页面，一般每次都只有一个页面，不仅要建大量的路由，而且资源冗杂，即使已经做了资源分割。还有做多页面最重要的原因是：单页面打包，会影响所有的页面，如果一个页面报错，那么其他的页面也无法访问。下面开始配置:


### 一.webpack及react版本

``` javascript
  "webpack": "^4.19.1",
  "react": "^16.8.3",
```

<!-- more -->

### 二.文件夹基本构造

``` javascript
config 
    - path.js
    |
    - webpack.config.js
public 
    - index.html
src    
    - page 
        - maintenance // 对应path.js的entriesPathFile
            - home 
                - component.js
                |
                - index.js 
                |
                - index.less
            - my 
                - component.js
                |
                - index.js 
                |
                - index.less
        - washstation //  对应path.js的entriesPathFile
            - home 
                - component.js
                |
                - index.js 
                |
                - index.less
            - my 
                - component.js
                |
                - index.js 
                |
                - index.less
index.js //必不可少，可以为空
```

<!-- More info: [Generating](https://hexo.io/docs/generating.html) -->

### 1.page下的index.js

 - home是一个单独的页面，包括 

1. component.js:
``` javascript
    class Home extends Component{
        constructor(props){
            super(props)
            this.state = {
                
            }
        }
        componentDidMount(){}
        render() {
            return(
                <div>
                     ...
                </div>
            )
        }
    }
    export default Home;
```

2. index.js:
``` javascript
    import 'core-js/stable';
    import 'babel-polyfill'
    import React from 'react';
    import ReactDOM from 'react-dom';
    import Home from './component';
    ReactDOM.render(<Home />, document.getElementById('root'));
```

3. index.less是页面相关的样式

### 2.config下的path.js

``` javascript
    const globby = require('globby');
    const entriesPathFile = 'maintenance';
    const entriesPath = globby.sync([resolveApp('src/page/' + entriesPathFile) + '/*/index.js']);
    /** 注意事项：
     -  1.entriesPath就是打包 maintenance 下面对应文件所有的index.js;
     -  2.有多个项目的话，就新建多个文件夹,如 washstation，
     -  3.启动项目或者打包项目只需要更改 entriesPathFile就可以了，如  const entriesPathFile = 'washstation'
     -  4.新建文件夹或者更换entriesPathFile必须要重新启动项目;*/ 
    
    module.exports = {
        ...
        entriesPath
    }
```

 - 下面这里是关键，东西有点多，配错了就没效果了：⬇️
### 3.config下的webpack.config.js

1. 获取指定路径下的入口文件
``` javascript
    function getEntries(){
        const entries = {};
        const files = paths.entriesPath;
        files.forEach(filePath => {
            let tmp = filePath.split('/');
            let name = tmp[tmp.length - 2];
            entries[name] = [
                require.resolve('react-dev-utils/webpackHotDevClient'),
                filePath,
            ];
        });
        return entries;
    }
```
2. 入口文件对象
``` javascript
    const entries = getEntries();
```
3. 有多少个页面就new 多少个HtmlWebpackPlugin
``` javascript
    const htmlPlugin = Object.keys(entries).map(item => {
        return new HtmlWebpackPlugin({
            inject: true,
            template: paths.appHtml, // pulblic/index.html 公共html模板
            filename:  item + '/' + item + '.html', // 这里是关键,访问入口由这里决定 http://localhost:3000/home/home.html
            chunks: [item]
        });
    });
```
4. 更换入口
``` javascript
    entry: {
        /* devtool: isEnvProduction
         ? shouldUseSourceMap
             ? 'source-map'
             : false
         : isEnvDevelopment && 'eval-source-map',
        entries
    }
```
5. 出口也顺便更改一下
``` javascript
    output:{
        /*把对应资源放到对应页面下面,这里[name] 就是home
        isEnvDevelopment 对应的内容一定要配，不然本地开发只能找到一个页面
        version 是时间戳 const version = +new Date();*/
        filename: isEnvProduction
        ?    '[name]/static/js/[name].[chunkhash:8].'+version+'.js'
        : isEnvDevelopment && '[name]/static/js/bundle.js',

        chunkFilename: isEnvProduction
        ?    '[name]/static/js/[name].[chunkhash:8].'+version+'.chunk.js'
        : isEnvDevelopment && '[name]/static/js/[name].chunk.'+version+'.js',
    }

    //上面是js，css也改一下，全局搜索 MiniCssExtractPlugin
    new MiniCssExtractPlugin({
        // Options similar to the same options in webpackOptions.output
        // both options are optional
        filename:   '[name]/static/css/[name].[contenthash:8].'+version+'.css',
        chunkFilename:  '[name]/static/css/[name].[contenthash:8].chunk.'+version+'.css',
    }),

    // 图片资源 全局搜索 .png ,图片是独立的
    {
        test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/],
        loader: require.resolve('url-loader')  ,
        options: {
        limit: 10000,
        name: 'static/media/[name].[hash:8].'+version+'.[ext]',
        },
    },
```
### 4.打包效果

``` javascript
    dist
      - 1  // 打包出的公共的js文件
      - 2  // 打包出的公共的js文件
      - assets // 本地静态资源
      - static //打包的静态图片资源
          - media
              - xxxx.png
      - home
          - home.html
          - static
              - css
                - xxx.css
              - js
                - xxx.js
       xxx
```

- 如果多个页面的话，其他页面效果和home文件一样。

### 4.最后一点

- 打完包，可能会出现资源访问不到，在 package.json 配置一下homepage

(1).我的是下面，根据项目路径来写：
``` javascript
   "homepage": "../",
```
 - (1)：顺便提一下，本地跨域，同样在 package.json 配置一下 proxy就可以了：
 
 ``` javascript
  "proxy": "域名",
 ```
 - (2)：2020/7/15 更新 -- 跨域配置 - 在src下新建 setupProxy.js

``` javascript
const { createProxyMiddleware } = require("http-proxy-middleware");
const targetUrl = "https://wechattest.youbeichefu.com"; // 配置域名 -- 测试
// const targetUrl = "https://prewechat.youbeichefu.com"; // 配置域名 -- 预发布
// const targetUrl = "https://wechat.youbeichefu.com"; // 配置域名 -- 线上

const regArr = [ // 配置匹配的请求链接
	'/func', 
	'/userApi', 
	'/washstation', 
	'/app', 
	'/parkingLot', 
	'/static/web',
	'/file'
]; 
module.exports = function(app) {
	app.use(
		createProxyMiddleware(regArr, {
			target: targetUrl,
			changeOrigin: true, // needed for virtual hosted sites
		})
	);
};
```

(2).打完包之后，放到服务器上，跳转访问路径也要配置的

 ``` javascript
 
    //比如本地 
    http://localhost:3000/home/home.html;

    //线上:
    https:www.baidu.com/dist/demo/home/home.html

    //那么当你跳转链接的时候，就要这样：

    //跳转
    const param = window.location.href.includes('baidu') ? '/dist/demo' : '';
    window.location.href = param + '/home/home.html';
```


