---
title: 十四、eventloop事件循环
date: 2020-1-25
tags:
  - eventloop
  - 事件循环
---

## eventloop事件循环

 - js是单线程执行的，eventloop事件循环就是解决javaScript单线程运行阻塞的一种机制。

 
 

### 一、宏任务和微任务

 ```javascript
在 js 中，任务分为宏任务(macrotask)和微任务(microtask)，这两个任务分别维护一个队列，均采用先进先出(类似放盘子)的策略进行执行，同步执行的任务都在宏任务上执行。
宏任务主要有：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)。
微任务主要有：Promise.then、 MutationObserver、 process.nextTick(Node.js 环境)。

宏任务是由多个微任务组成的，先执行微任务，后执行宏任务。
```

### 二、运行机制
```javascript
    在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：

    - 执行一个宏任务（栈中没有就从事件队列中获取）
    - 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
    - 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
    - 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
    - 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
```


### 三、🌰
 ### 1.尝试输出以下代码 
 ```javascript
    console.log(1);
    setTimeout(function() {
        console.log(2);
    }, 0);
    new Promise(function(resolve) {
        console.log(3);
        resolve(Date.now());
    }).then(function() {
        console.log(4);
    });
    console.log(5);
    setTimeout(function() {
        new Promise(function(resolve) {
            console.log(6);
            resolve(Date.now());
        }).then(function() {
            console.log(7);
        });
    }, 0);
 ```

 - 那么以上代码的执行过程是什么样的呢？
 ```javascript
    //  1 3 5 4 2 6 7 
    1.代码从上往下执行，首先输出 1，
    2.遇到setTimeout，推入宏任务，待后面执行，
    3.遇到Promise，首先打印 3，把then后面的推入微任务，
    4.直接打印 5，
    6.遇到setTimeout，推入宏任务，待后面执行，
    7.微任务按顺序执行，打印 4，
    8.宏任务按顺序执行，打印 2，任务队列中没有微任务，下一步，
    9.执行宏任务，打印 6，把then后面的推入微任务，
    10.执行微任务，打印 7，完成。
 ```


 ### 2.尝试输出以下代码 

 ```javascript
    async function async1() {
        console.log('async1 start');
        await async2();
        console.log('async1 end');
    }
    async function async2() {
        console.log('async2');
    }
    console.log('script start');
    setTimeout(function() {
        console.log('setTimeout');
    }, 0)
    async1();
    new Promise(function(resolve) {
        console.log('promise1');
        resolve();
    }).then(function() {
        console.log('promise2');
    });
    console.log('script end');

    /**
        await async2()等价于
        async2().then(() => {
                console.log('async1 end');
        })
    **/ 
 ```


 ```javascript
    /*
        script start
        async1 start
        async2
        promise1
        script end
        async1 end
        promise2
        setTimeout
    */
    1.首先定义了两个async，没调用，直接下一步，
    2.执行 script start，
    3.遇到setTimeout， 推入宏任务，
    3.执行 async1函数,在await之前的代码是立即执行的，所以会立即输出 async1 start,遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2,打印async2，
    4.往下走，遇到Promise，打印promise1， then推入微任务，
    5.往下走，打印script end，
    6.继续按顺序执行之前任务队列中的微任务，先打印async1 end， 再打印 promise2，
    7.执行宏任务，打印setTimeout。
 ```