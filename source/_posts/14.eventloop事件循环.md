---
title: 十四、eventloop事件循环
date: 2020-1-25
tags:
  - eventloop
  - 事件循环
---

## eventloop事件循环

 - js是单线程执行的，eventloop事件循环就是解决javaScript单线程运行阻塞的一种机制。


## 消息队列

```javascript
const bar = () => console.log('bar')

const baz = () => console.log('baz')

const foo = () => {
  console.log('foo')
  setTimeout(bar, 0)
  baz()
}

foo()

该代码会打印：
foo
baz
bar
```
 1. 当调用 setTimeout() 时，浏览器或 Node.js 会启动定时器。 当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。

 2. 在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。

 3. 事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。

 
 ## ES6 作业队列
- ECMAScript 2015 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。

- 当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。

- 有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。

```javascript
const bar = () => console.log('bar')

const baz = () => console.log('baz')

const foo = () => {
  console.log('foo')
  setTimeout(bar, 0)
  new Promise((resolve, reject) =>
    resolve('应该在 baz 之后、bar 之前')
  ).then(resolve => console.log(resolve))
  baz()
}

foo()

这会打印：
foo
baz
应该在 baz 之后、bar 之前
bar

```
 - 这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。
 

### 一、宏任务和微任务

- 在 js 中，任务分为宏任务(macrotask)和微任务(microtask)，这两个任务分别维护一个队列，均采用先进先出(类似放盘子)的策略进行执行，同步执行的任务都在宏任务上执行。



    1. 宏任务主要有：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)。
    2. 微任务主要有：Promise.then、 MutationObserver、 process.nextTick(Node.js 环境)。

- 宏任务是由多个微任务组成的，先执行微任务，后执行宏任务。

### 二、运行机制
- 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：


    1. 执行一个宏任务（栈中没有就从事件队列中获取）
    2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
    3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
    4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
    5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）


### 三、🌰
 - 按消息队列 和  作业队列 思路更简单。先执行作业队列， 后执行 作业队列。

 ### 1.尝试输出以下代码 
 ```javascript
    console.log(1);
    setTimeout(function() {
        console.log(2);
    }, 0);
    new Promise(function(resolve) {
        console.log(3);
        resolve(Date.now());
    }).then(function() {
        console.log(4);
    });
    console.log(5);
    setTimeout(function() {
        new Promise(function(resolve) {
            console.log(6);
            resolve(Date.now());
        }).then(function() {
            console.log(7);
        });
    }, 0);
 ```

 - 那么以上代码的执行过程是什么样的呢？


    -  1 3 5 4 2 6 7 
    1. 代码从上往下执行，首先输出 1，
    2. 遇到setTimeout，推入宏任务，待后面执行，
    3. 遇到Promise，首先打印 3，把then后面的推入微任务，
    4. 直接打印 5，
    6. 遇到setTimeout，推入宏任务，待后面执行，
    7. 微任务按顺序执行，打印 4，
    8. 宏任务按顺序执行，打印 2，任务队列中没有微任务，下一步，
    9. 执行宏任务，打印 6，把then后面的推入微任务，
    10. 执行微任务，打印 7，完成。


 ### 2.尝试输出以下代码 

 ```javascript
    async function async1() {
        console.log('async1 start');
        await async2();
        console.log('async1 end');
    }
    async function async2() {
        console.log('async2');
    }
    console.log('script start');
    setTimeout(function() {
        console.log('setTimeout');
    }, 0)
    async1();
    new Promise(function(resolve) {
        console.log('promise1');
        resolve();
    }).then(function() {
        console.log('promise2');
    });
    console.log('script end');

    /**
        await async2()等价于
        async2().then(() => {
                console.log('async1 end');
        })
    **/ 
 ```


 ```javascript
    /*
        script start
        async1 start
        async2
        promise1
        script end
        async1 end
        promise2
        setTimeout
    */
 ```
- 解析


    1.首先定义了两个async，没调用，直接下一步，
    2.执行 script start，
    3.遇到setTimeout， 推入宏任务，
    3.执行 async1函数,在await之前的代码是立即执行的，所以会立即输出 async1 start,遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2,打印async2，
    4.往下走，遇到Promise，打印promise1， then推入微任务，
    5.往下走，打印script end，
    6.继续按顺序执行之前任务队列中的微任务，先打印async1 end， 再打印 promise2，
    7.执行宏任务，打印setTimeout。