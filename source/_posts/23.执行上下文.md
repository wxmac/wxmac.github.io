---
title: 二十三、执行上下文
date: 2020-5-1
tags:
  - 执行上下文
---

 ## 执行上下文

 <!-- more -->

- 什么是执行上下文
	1. 当 JS 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 “准备工作”，就叫做 "执行上下文(execution context 简称 EC)" 或者也可以叫做执行环境。

***
- 执行上下文的类型
	1. 全局执行上下文——这是默认或者说是最基础的执行上下文，一个程序中只会存在一个全局上下文，它在整个 javascript 脚本的生命周期内都会存在于执行堆栈的最底部不会被栈弹出销毁。全局上下文会生成一个全局对象（以浏览器环境为例，这个全局对象是 window），并且将 this 值绑定到这个全局对象上。

	2. 函数执行上下文——每当一个函数被调用时，都会创建一个新的函数执行上下文（不管这个函数是不是被重复调用的）

	3. Eval 函数执行上下文—— 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于并不经常使用 eval，所以在这里不做分析。

***

- 作用域链
  1. 作用域 规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做 作用域链。

 *** 

- 执行上下文和作用域有什么区别?
	1. 作用域是在声明时就已经确定了，但是执行上下文是在运行的时候才能确定的。比如函数声明时其中this的指向是不确定的，由它最终的调用时环境确定(不确定)
  *** 
- 相关题目
	- 第一题：
	```javascript
	var foo = function () {
		console.log('foo1');
	}

	foo();

	var foo = function () {
		console.log('foo2');
	}

	foo();
	//  foo1 foo2

	```
	- 第二题：
	```javascript
	foo();

	var foo = function foo() {
		console.log('foo1');
	}

	function foo() {
		console.log('foo2');
	}

	foo();

	//  由于函数声明提升更加靠前，且如果 var 定义变量的时候发现已有同名函数定义则跳过变量定义，

	```
	- 第三题：
	```javascript
	var foo = 1;
	function bar () {
		console.log(foo);
		var foo = 10;
		console.log(foo);
	}

	bar();

	/**
	 * bar 函数运行，内部变量申明提升，当执行代码块中有访问变量时，先查找本地作用域，找到了 foo 为 undefined ，打印出来。然后 foo 被赋值为 10 ，打印出 10。
	 */ 
	// undefined 10
	```

	- 第四题：
	```javascript
	var foo = 1;
	function bar () {
		console.log(foo);
		foo = 2;
	}
	bar();
	console.log(foo);
	// 	这题也是考察的作用域链查找，bar 里操作的 foo 本地没有定义，所以应该是上层作用域的变量。
	// 1 2
	```

	- 第五题：
	```javascript
	var foo = 1;
	function bar (foo) {
		console.log(foo);
		foo = 234;
	}
	bar(123);
	console.log(foo);

	// 	运行 bar 函数的时候将 123 数字作为实参传入，所以操作的还是本地作用域的 foo
	// 123 1
	```

	- 第六题：
	```javascript
	var a = 1;
	function foo () {
		var a = 2;
		return function () {
			console.log(a);
		}
	}

	var bar = foo();
	bar();
	/**
	 这道题目主要考察闭包和函数作用域的概念，我们只要记住：函数能够访问到的上层作用域，
	 是在函数声明时候就已经确定了的，函数声明在哪里，上层作用域就在哪里，和拿到哪里执行没有关系。
	这道题目中，匿名函数被作为闭包返回并在外部调用，但它内部的作用域链引用到了父函数的变量对象中的 a ，
	所以作用域链查找时，打印出来的是 2。
	 */ 	


	// 2
	```

	- 第七题：
	```javascript
	var a = 1;
	function foo () {
		var a = 2;
		return function () {
			console.log(this.a);
		}
	}

	var bar = foo().bind(this);//此时的this是window
	bar();

	/**
	 这题考察的是执行环境中的 this 指向的问题，由于闭包内明确指定访问 this 中的 a 属性，
	 并且闭包被 bind 绑定在全局环境下运行，所以打印出的是全局对象中的 a。
	 */ 	
	// 1
	```

