{"meta":{"title":"wxmac的前端笔记","subtitle":"记录自己的代码点滴 -- 九层之台，起于累土","description":"","author":"wxmac","url":"https://wxmac.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-19T02:14:29.205Z","updated":"2019-12-19T02:14:29.204Z","comments":true,"path":"404.html","permalink":"https://wxmac.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"所有标签","date":"2019-12-19T02:08:57.392Z","updated":"2019-12-19T02:08:57.392Z","comments":true,"path":"tags/index.html","permalink":"https://wxmac.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-01-07T03:35:06.484Z","updated":"2020-01-07T03:35:06.484Z","comments":true,"path":"js/love.js","permalink":"https://wxmac.github.io/js/love.js","excerpt":"","text":"!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e"},{"title":"","date":"2019-12-24T09:33:53.764Z","updated":"2019-12-24T09:33:53.762Z","comments":true,"path":"js/jquery.js","permalink":"https://wxmac.github.io/js/jquery.js","excerpt":"","text":"/*! jQuery v3.3.1 | (c) JS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(e,t){\"use strict\";var n=[],r=e.document,i=Object.getPrototypeOf,o=n.slice,a=n.concat,s=n.push,u=n.indexOf,l={},c=l.toString,f=l.hasOwnProperty,p=f.toString,d=p.call(Object),h={},g=function e(t){return\"function\"==typeof t&&\"number\"!=typeof t.nodeType},y=function e(t){return null!=t&&t===t.window},v={type:!0,src:!0,noModule:!0};function m(e,t,n){var i,o=(t=t||r).createElement(\"script\");if(o.text=e,n)for(i in v)n[i]&&(o[i]=n[i]);t.head.appendChild(o).parentNode.removeChild(o)}function x(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?l[c.call(e)]||\"object\":typeof e}var b=\"3.3.1\",w=function(e,t){return new w.fn.init(e,t)},T=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;w.fn=w.prototype={jquery:\"3.3.1\",constructor:w,length:0,toArray:function(){return o.call(this)},get:function(e){return null==e?o.call(this):e=0&&n10|55296,1023&r|56320)},te=/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,ne=function(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e},re=function(){p()},ie=me(function(e){return!0===e.disabled&&(\"form\"in e||\"label\"in e)},{dir:\"parentNode\",next:\"legend\"});try{L.apply(A=H.call(w.childNodes),w.childNodes),A[w.childNodes.length].nodeType}catch(e){L={apply:A.length?function(e,t){q.apply(e,H.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function oe(e,t,r,i){var o,s,l,c,f,h,v,m=t&&t.ownerDocument,T=t?t.nodeType:9;if(r=r||[],\"string\"!=typeof e||!e||1!==T&&9!==T&&11!==T)return r;if(!i&&((t?t.ownerDocument||t:w)!==d&&p(t),t=t||d,g)){if(11!==T&&(f=J.exec(e)))if(o=f[1]){if(9===T){if(!(l=t.getElementById(o)))return r;if(l.id===o)return r.push(l),r}else if(m&&(l=m.getElementById(o))&&x(t,l)&&l.id===o)return r.push(l),r}else{if(f[2])return L.apply(r,t.getElementsByTagName(e)),r;if((o=f[3])&&n.getElementsByClassName&&t.getElementsByClassName)return L.apply(r,t.getElementsByClassName(o)),r}if(n.qsa&&!S[e+\" \"]&&(!y||!y.test(e))){if(1!==T)m=t,v=e;else if(\"object\"!==t.nodeName.toLowerCase()){(c=t.getAttribute(\"id\"))?c=c.replace(te,ne):t.setAttribute(\"id\",c=b),s=(h=a(e)).length;while(s--)h[s]=\"#\"+c+\" \"+ve(h[s]);v=h.join(\",\"),m=K.test(e)&&ge(t.parentNode)||t}if(v)try{return L.apply(r,m.querySelectorAll(v)),r}catch(e){}finally{c===b&&t.removeAttribute(\"id\")}}}return u(e.replace(B,\"$1\"),t,r,i)}function ae(){var e=[];function t(n,i){return e.push(n+\" \")>r.cacheLength&&delete t[e.shift()],t[n+\" \"]=i}return t}function se(e){return e[b]=!0,e}function ue(e){var t=d.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function le(e,t){var n=e.split(\"|\"),i=n.length;while(i--)r.attrHandle[n[i]]=t}function ce(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function fe(e){return function(t){return\"input\"===t.nodeName.toLowerCase()&&t.type===e}}function pe(e){return function(t){var n=t.nodeName.toLowerCase();return(\"input\"===n||\"button\"===n)&&t.type===e}}function de(e){return function(t){return\"form\"in t?t.parentNode&&!1===t.disabled?\"label\"in t?\"label\"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&ie(t)===e:t.disabled===e:\"label\"in t&&t.disabled===e}}function he(e){return se(function(t){return t=+t,se(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}function ge(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}n=oe.support={},o=oe.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return!!t&&\"HTML\"!==t.nodeName},p=oe.setDocument=function(e){var t,i,a=e?e.ownerDocument||e:w;return a!==d&&9===a.nodeType&&a.documentElement?(d=a,h=d.documentElement,g=!o(d),w!==d&&(i=d.defaultView)&&i.top!==i&&(i.addEventListener?i.addEventListener(\"unload\",re,!1):i.attachEvent&&i.attachEvent(\"onunload\",re)),n.attributes=ue(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),n.getElementsByTagName=ue(function(e){return e.appendChild(d.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),n.getElementsByClassName=Q.test(d.getElementsByClassName),n.getById=ue(function(e){return h.appendChild(e).id=b,!d.getElementsByName||!d.getElementsByName(b).length}),n.getById?(r.filter.ID=function(e){var t=e.replace(Z,ee);return function(e){return e.getAttribute(\"id\")===t}},r.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&g){var n=t.getElementById(e);return n?[n]:[]}}):(r.filter.ID=function(e){var t=e.replace(Z,ee);return function(e){var n=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return n&&n.value===t}},r.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&g){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),r.find.TAG=n.getElementsByTagName?function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):n.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},r.find.CLASS=n.getElementsByClassName&&function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&g)return t.getElementsByClassName(e)},v=[],y=[],(n.qsa=Q.test(d.querySelectorAll))&&(ue(function(e){h.appendChild(e).innerHTML=\"\",e.querySelectorAll(\"[msallowcapture^='']\").length&&y.push(\"[*^$]=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\"[selected]\").length||y.push(\"\\\\[\"+M+\"*(?:value|\"+P+\")\"),e.querySelectorAll(\"[id~=\"+b+\"-]\").length||y.push(\"~=\"),e.querySelectorAll(\":checked\").length||y.push(\":checked\"),e.querySelectorAll(\"a#\"+b+\"+*\").length||y.push(\".#.+[+~]\")}),ue(function(e){e.innerHTML=\"\";var t=d.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),e.querySelectorAll(\"[name=d]\").length&&y.push(\"name\"+M+\"*[*^$|!~]?=\"),2!==e.querySelectorAll(\":enabled\").length&&y.push(\":enabled\",\":disabled\"),h.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&y.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),y.push(\",.*:\")})),(n.matchesSelector=Q.test(m=h.matches||h.webkitMatchesSelector||h.mozMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&ue(function(e){n.disconnectedMatch=m.call(e,\"*\"),m.call(e,\"[s!='']:x\"),v.push(\"!=\",W)}),y=y.length&&new RegExp(y.join(\"|\")),v=v.length&&new RegExp(v.join(\"|\")),t=Q.test(h.compareDocumentPosition),x=t||Q.test(h.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return f=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r||(1&(r=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!n.sortDetached&&t.compareDocumentPosition(e)===r?e===d||e.ownerDocument===w&&x(w,e)?-1:t===d||t.ownerDocument===w&&x(w,t)?1:c?O(c,e)-O(c,t):0:4&r?-1:1)}:function(e,t){if(e===t)return f=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===d?-1:t===d?1:i?-1:o?1:c?O(c,e)-O(c,t):0;if(i===o)return ce(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?ce(a[r],s[r]):a[r]===w?-1:s[r]===w?1:0},d):d},oe.matches=function(e,t){return oe(e,null,null,t)},oe.matchesSelector=function(e,t){if((e.ownerDocument||e)!==d&&p(e),t=t.replace(z,\"='$1']\"),n.matchesSelector&&g&&!S[t+\" \"]&&(!v||!v.test(t))&&(!y||!y.test(t)))try{var r=m.call(e,t);if(r||n.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){}return oe(t,d,null,[e]).length>0},oe.contains=function(e,t){return(e.ownerDocument||e)!==d&&p(e),x(e,t)},oe.attr=function(e,t){(e.ownerDocument||e)!==d&&p(e);var i=r.attrHandle[t.toLowerCase()],o=i&&N.call(r.attrHandle,t.toLowerCase())?i(e,t,!g):void 0;return void 0!==o?o:n.attributes||!g?e.getAttribute(t):(o=e.getAttributeNode(t))&&o.specified?o.value:null},oe.escape=function(e){return(e+\"\").replace(te,ne)},oe.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},oe.uniqueSort=function(e){var t,r=[],i=0,o=0;if(f=!n.detectDuplicates,c=!n.sortStable&&e.slice(0),e.sort(D),f){while(t=e[o++])t===e[o]&&(i=r.push(o));while(i--)e.splice(r[i],1)}return c=null,e},i=oe.getText=function(e){var t,n=\"\",r=0,o=e.nodeType;if(o){if(1===o||9===o||11===o){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=i(e)}else if(3===o||4===o)return e.nodeValue}else while(t=e[r++])n+=i(t);return n},(r=oe.selectors={cacheLength:50,createPseudo:se,match:V,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(Z,ee),e[3]=(e[3]||e[4]||e[5]||\"\").replace(Z,ee),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||oe.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&oe.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return V.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&X.test(n)&&(t=a(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(Z,ee).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=E[e+\" \"];return t||(t=new RegExp(\"(^|\"+M+\")\"+e+\"(\"+M+\"|$)\"))&&E(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(e,t,n){return function(r){var i=oe.attr(r,e);return null==i?\"!=\"===t:!t||(i+=\"\",\"=\"===t?i===n:\"!=\"===t?i!==n:\"^=\"===t?n&&0===i.indexOf(n):\"*=\"===t?n&&i.indexOf(n)>-1:\"$=\"===t?n&&i.slice(-n.length)===n:\"~=\"===t?(\" \"+i.replace($,\" \")+\" \").indexOf(n)>-1:\"|=\"===t&&(i===n||i.slice(0,n.length+1)===n+\"-\"))}},CHILD:function(e,t,n,r,i){var o=\"nth\"!==e.slice(0,3),a=\"last\"!==e.slice(-4),s=\"of-type\"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==a?\"nextSibling\":\"previousSibling\",y=t.parentNode,v=s&&t.nodeName.toLowerCase(),m=!u&&!s,x=!1;if(y){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===v:1===p.nodeType)return!1;h=g=\"only\"===e&&!h&&\"nextSibling\"}return!0}if(h=[a?y.firstChild:y.lastChild],a&&m){x=(d=(l=(c=(f=(p=y)[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]||[])[0]===T&&l[1])&&l[2],p=d&&y.childNodes[d];while(p=++d&&p&&p[g]||(x=d=0)||h.pop())if(1===p.nodeType&&++x&&p===t){c[e]=[T,d,x];break}}else if(m&&(x=d=(l=(c=(f=(p=t)[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]||[])[0]===T&&l[1]),!1===x)while(p=++d&&p&&p[g]||(x=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===v:1===p.nodeType)&&++x&&(m&&((c=(f=p[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]=[T,x]),p===t))break;return(x-=i)===r||x%r==0&&x/r>=0}}},PSEUDO:function(e,t){var n,i=r.pseudos[e]||r.setFilters[e.toLowerCase()]||oe.error(\"unsupported pseudo: \"+e);return i[b]?i(t):i.length>1?(n=[e,e,\"\",t],r.setFilters.hasOwnProperty(e.toLowerCase())?se(function(e,n){var r,o=i(e,t),a=o.length;while(a--)e[r=O(e,o[a])]=!(n[r]=o[a])}):function(e){return i(e,0,n)}):i}},pseudos:{not:se(function(e){var t=[],n=[],r=s(e.replace(B,\"$1\"));return r[b]?se(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),t[0]=null,!n.pop()}}),has:se(function(e){return function(t){return oe(e,t).length>0}}),contains:se(function(e){return e=e.replace(Z,ee),function(t){return(t.textContent||t.innerText||i(t)).indexOf(e)>-1}}),lang:se(function(e){return U.test(e||\"\")||oe.error(\"unsupported lang: \"+e),e=e.replace(Z,ee).toLowerCase(),function(t){var n;do{if(n=g?t.lang:t.getAttribute(\"xml:lang\")||t.getAttribute(\"lang\"))return(n=n.toLowerCase())===e||0===n.indexOf(e+\"-\")}while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===d.activeElement&&(!d.hasFocus||d.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:de(!1),disabled:de(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType"},{"title":"所有分类","date":"2019-12-19T02:12:02.734Z","updated":"2019-12-19T02:12:02.734Z","comments":true,"path":"categories/index.html","permalink":"https://wxmac.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"二十、疑难问题归纳","slug":"20.疑难问题归纳","date":"2020-02-29T16:00:00.000Z","updated":"2020-03-11T01:05:59.991Z","comments":true,"path":"2020/03/01/20.疑难问题归纳/","link":"","permalink":"https://wxmac.github.io/2020/03/01/20.疑难问题归纳/","excerpt":"疑难问题归纳 – 更新中","text":"疑难问题归纳 – 更新中 一.双iframe问题 最近遇到一个需求，点击title，切换页面，但是第一个title是已有页面，第二个是新写的，于是想到了iframe。写了两个iframe，对应下面的的写法，点击title，显示对应的页面，一切都很完美。 12345678&lt;div className=&#123; `$&#123;welfaretitleIndex == 0 ? styleCss.welafreMain : ''&#125;` &#125;&gt; &lt;iframe className=&#123; styleCss.welfare_iframe &#125; title=\"1\" src=&#123; urlOne &#125; frameBorder=\"0\"&gt; &lt;/iframe&gt;&lt;/div&gt;&lt;div className=&#123; `$&#123; styleCss.blobkWelafreMain &#125; $&#123;welfaretitleIndex == 1 ? styleCss.welafreMain : ''&#125;` &#125;&gt; &lt;iframe className=&#123; styleCss.welfare_iframe &#125; title=\"2\" src=&#123; urlTwo &#125; frameBorder=\"0\"&gt; &lt;/iframe&gt;&lt;/div&gt; 但是在ios真机中，第一个已有页面没问题，当切换到第二个页面的时候，只剩title了，页面死活显示不出来，单独打开第二个页面也是没问题的。找不到原因，只能修改成点击title切换iframe的url链接，就没问题了。 1234&lt;div className=&#123; `$&#123; styleCss.blobkWelafreMain &#125; $&#123;welfaretitleIndex == 1 ? styleCss.welafreMain : ''&#125;` &#125;&gt; &lt;iframe ref=\"ifm\" className=&#123; styleCss.welfare_iframe &#125; title=\"1\" src=&#123; this.url &#125; frameBorder=\"0\"&gt; &lt;/iframe&gt; &lt;/div&gt; 二.react白屏问题 新项目是我用react重构的，刚开始很好，没出现问题。后来运营集中反馈，vivo、oppo手机在app中打开活动页面出现白屏，但是很难复现。只能去问度娘了。 解决方法一： 给打包的资源加时间戳。这个是最常用的方法，没生效。 解决方法二： 在index.js中引入’babel-polyfill’。依然没生效。 解决方法三： 在index.js中引入’core-js/stable’。在前两种没去处的情况下，目前运营还没反馈白屏问题，不知道是用户少了，还是解决了。 12import 'babel-polyfill';import 'core-js/stable'; // 解决react兼容问题。 三.微信二次分享问题 微信分享的时候，第一次分享是好的。但是通过别人分享的链接再进行分享，会出现分享失效的情况。经过排查，发现是分享的时候，微信自动给链接加上了 &amp;isappinstalled=0&amp;&amp;from=groupmessage 参数，导致分享失败，为啥失败咱也不知道。 于是采用以下解决方法：如果链接带这两个参数，encodeURIComponent一下就好了。123456let params = '';if(window.location.href.indexOf('from') != -1 || window.location.href.indexOf('isappinstalled') != -1)&#123; params = encodeURIComponent(window.location.href);&#125; else &#123; params = window.location.href;&#125; 四.ios 视频无法自动播放问题 这个之前没有遇到过，在谷歌模拟器里是好的，但是在ios微信里面，视频无法自动播放，需要做一下判断，在wx.ready调用就好了。123456789101112131415161718const u = navigator.userAgent;const isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);if(isiOS)&#123; const video = this.refs.videoEl; // config必须存在 wx.config(&#123; // 配置信息, 即使不正确也能使用 wx.ready debug: false, appId: '', timestamp: 1, nonceStr: '', signature: '', jsApiList: [] &#125;); wx.ready(function() &#123; video.play(); &#125;)&#125;","categories":[],"tags":[{"name":"归纳问题","slug":"归纳问题","permalink":"https://wxmac.github.io/tags/归纳问题/"}]},{"title":"十九、父子页面通信","slug":"19.父子页面通信","date":"2020-02-19T16:00:00.000Z","updated":"2020-02-26T07:59:45.269Z","comments":true,"path":"2020/02/20/19.父子页面通信/","link":"","permalink":"https://wxmac.github.io/2020/02/20/19.父子页面通信/","excerpt":"父子页面通信","text":"父子页面通信 做了一个需求，套了一个iframe，但是iframe里面的弹窗遮罩覆盖不戴父页面，导致显示遮罩的时候，页面仍然可以滚动，试了几个方法，还是 postMessage 靠谱，可以实现即时通信。 子页面 12345678910111213141516171819 // 拓展门店handleShowOpenStore()&#123; this.setState(&#123; showOpenStore: true &#125;) window.location.href = '#container'; stopScroll(); window.parent.postMessage('stopScroll', '*');&#125;/** * 注意事项： 1.需要禁止滚动的地方 window.parent.postMessage('stopScroll', '*'); 2.恢复滚动 window.parent.postMessage('autoScroll', '*');**/ 父页面 12345678 // 防止滚动window.addEventListener('message', (e) =&gt; &#123; if(e.data &amp;&amp; e.data === 'autoScroll')&#123; autoScroll() &#125; else if(e.data &amp;&amp; e.data === 'stopScroll')&#123; stopScroll() &#125;&#125;); 后记 123/** 但是个人感觉这个方法不是很好，无奈之举，后续可以找新方法。**/","categories":[],"tags":[{"name":"postMessage","slug":"postMessage","permalink":"https://wxmac.github.io/tags/postMessage/"},{"name":"父子页面通信","slug":"父子页面通信","permalink":"https://wxmac.github.io/tags/父子页面通信/"}]},{"title":"十七、四种常见的设计模式","slug":"17.四种常见的设计模式","date":"2020-02-09T16:00:00.000Z","updated":"2020-01-16T06:08:22.195Z","comments":true,"path":"2020/02/10/17.四种常见的设计模式/","link":"","permalink":"https://wxmac.github.io/2020/02/10/17.四种常见的设计模式/","excerpt":"设计模式","text":"设计模式 1.工厂模式 简单的工厂模式可以理解为解决多个相似的问题;123456789101112131415161718192021function CreatePerson(name,age,sex) &#123; let obj = new Object(); obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function()&#123; return this.name; &#125; return obj;&#125;let p1 = new CreatePerson(\"longen\",'28','男');let p2 = new CreatePerson(\"tugenhua\",'27','女');console.log(p1.name); // longenconsole.log(p1.age); // 28console.log(p1.sex); // 男console.log(p1.sayName()); // longenconsole.log(p2.name); // tugenhuaconsole.log(p2.age); // 27console.log(p2.sex); // 女console.log(p2.sayName()); // tugenhua 2.单例模式 只能被实例化(构造函数给实例添加属性与方法)一次;1234567891011121314151617181920// 单体模式let Singleton = function(name)&#123; this.name = name;&#125;;Singleton.prototype.getName = function()&#123; return this.name;&#125;// 获取实例对象let getInstance = (function() &#123; let instance = null; return function(name) &#123; if(!instance) &#123;//相当于一个一次性阀门,只能实例化一次 instance = new Singleton(name); &#125; return instance; &#125;&#125;)();// 测试单体模式的实例,所以a===blet a = getInstance(\"aa\");let b = getInstance(\"bb\"); 3.沙箱模式 只能被实例化(构造函数给实例添加属性与方法)一次;12345678let sandboxModel=(function()&#123; function sayName()&#123;&#125;; function sayAge()&#123;&#125;; return&#123; sayName:sayName, sayAge:sayAge &#125; &#125;)() 4.发布者订阅模式 例如如我们关注了某一个公众号,然后他对应的有新的消息就会给你推送;123456789101112131415161718192021222324252627//发布者与订阅模式let shoeObj = &#123;&#125;; // 定义发布者shoeObj.list = []; // 缓存列表 存放订阅者回调函数// 增加订阅者shoeObj.listen = function(fn) &#123; shoeObj.list.push(fn); // 订阅消息添加到缓存列表&#125;// 发布消息shoeObj.trigger = function() &#123; for (var i = 0, fn; fn = this.list[i++];) &#123; fn.apply(this, arguments);//第一个参数只是改变fn的this, &#125;&#125; // 小红订阅如下消息shoeObj.listen(function(color, size) &#123; console.log(\"颜色是：\" + color); console.log(\"尺码是：\" + size);&#125;);setInterval(() =&gt; &#123; shoeObj.trigger(\"红色\", 40);&#125;,10000);// 可用用发布订阅模式来设计 消息弹窗。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://wxmac.github.io/tags/设计模式/"}]},{"title":"十八、手写Promise","slug":"18.手写Promise","date":"2020-02-09T16:00:00.000Z","updated":"2020-01-17T06:20:45.646Z","comments":true,"path":"2020/02/10/18.手写Promise/","link":"","permalink":"https://wxmac.github.io/2020/02/10/18.手写Promise/","excerpt":"手写Promise","text":"手写Promise 暂未实现链式调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Promise(callback)&#123; const _this = this; this.status = 'pending'; this.value = null; this.reason = null; this.onSuccess = []; this.onFail = []; function resolve(value)&#123; if(_this.status === 'pending')&#123; _this.onSuccess.forEach((fn) =&gt; &#123; return fn(value) &#125;) _this.status = 'resolve'; &#125; &#125;; function reject(reason)&#123; if(_this.status === 'pending')&#123; _this.onFail.forEach((fn) =&gt; &#123; return fn(reason) &#125;) _this.status = 'reject'; &#125; &#125; callback(resolve,reject )&#125;;Promise.prototype.then = function ( onresolve, onreject )&#123; if(this.status === 'resolve')&#123; if( typeof onresolve === 'function' )&#123; onresolve(this.value) &#125; &#125; if(this.status === 'reject')&#123; if( typeof onreject === 'function' )&#123; onreject(this.reason) &#125; &#125; if(this.status === 'pending')&#123; if( typeof onresolve === 'function' )&#123; this.onSuccess.push(onresolve) &#125; if( typeof onreject === 'function' )&#123; this.onFail.push(onreject) &#125; &#125;&#125;;var t = new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 500);&#125;);t.then(data =&gt; &#123; console.log(data);&#125;); 参考链接","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://wxmac.github.io/tags/设计模式/"}]},{"title":"十六、自己实现map、indexOf、concat，来自jquery源码","slug":"16.实现map、indexOf、concat","date":"2020-01-31T16:00:00.000Z","updated":"2020-01-13T01:50:35.019Z","comments":true,"path":"2020/02/01/16.实现map、indexOf、concat/","link":"","permalink":"https://wxmac.github.io/2020/02/01/16.实现map、indexOf、concat/","excerpt":"看了jq源码，受益良多。","text":"看了jq源码，受益良多。 1.map123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const map = ( elems, callback, arg ) =&gt; &#123; let length, value, ret = []; if ( Array.isArray(elems) ) &#123; // 数组 length = elems.length; for ( let i = 0 ; i &lt; length; i++ ) &#123; value = callback( elems[ i ], i, arg ); if ( value != null ) &#123; ret.push( value ); &#125; &#125; &#125; else &#123; for ( let i in elems ) &#123; value = callback( elems[ i ], i, arg ); if ( value != null ) &#123; ret.push( value ); &#125; &#125; &#125; return ret;&#125;// 1.数组 /** const arr1 = ['a','b','c','d','e','f']; map(arr1, (item,i) =&gt; &#123; console.log(item, i) &#125;) 输出： a 0 b 1 c 2 d 3 e 4 f 5* **/ // 2.对象 /** const obj = &#123; 'a':1111, 'b':2222 &#125;; map(obj, (item,i) =&gt; &#123; console.log(item, i) &#125;) // 输出 a \"111\" b \"222\" * **/ 2.indexOf1234567891011121314151617181920const indexOf = ( list, elem ) =&gt; &#123; let len = list.length; for ( let i = 0 ; i &lt; len; i++ ) &#123; if ( list[i] === elem ) &#123; return i; &#125; &#125; return -1;&#125;;/*** * let arr = [1,2,3,4,5,6]; * console.log( indexOf(arr,2) ) * // 返回下标 1 * * * let obj = 'abcdefg'; * console.log( indexOf(obj,c) ) * // 返回下标 2*/ 3.concat12345678910111213141516const merge = ( first, second ) =&gt; &#123; let len = second.length, i = first.length; for (let j = 0 ; j &lt; len; j++ ) &#123; first[ i++ ] = second[ j ]; &#125; first.length = i; return first;&#125;;/** * let arr1 = [1,2,3,4,5,6]; * let arr2 = ['a','b','c','d','e','f']; * console.log( merge(arr1,arr2) ) * 输出： [1, 2, 3, 4, 5, 6, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] * **/","categories":[],"tags":[{"name":"map","slug":"map","permalink":"https://wxmac.github.io/tags/map/"}]},{"title":"十五、利用less实现一个雪花❄️","slug":"15.利用less实现一个雪花❄️","date":"2020-01-29T16:00:00.000Z","updated":"2020-01-06T06:37:17.737Z","comments":true,"path":"2020/01/30/15.利用less实现一个雪花❄️/","link":"","permalink":"https://wxmac.github.io/2020/01/30/15.利用less实现一个雪花❄️/","excerpt":"利用less实现一个雪花 看了一篇文章，里面用less实现了一个雪花，里面less的用法让我眼前一亮，该看看less的其他用法了。","text":"利用less实现一个雪花 看了一篇文章，里面用less实现了一个雪花，里面less的用法让我眼前一亮，该看看less的其他用法了。 html - 实现雪花，html结构是很重要的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;figure className=&#123; styleCss.snowflake &#125;&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/figure&gt; less - 实现雪花的核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243.snowflake&#123; font-size: 100px; color: snow; width: 4em; height: 4em; outline: 1px dashed yellow; position: relative; display: flex; justify-content: center; div &#123; width: 0.1em; height: 2em; background-color: currentColor; border-radius: 0.05em; position: absolute; transform-origin: bottom; transform: rotate(calc(var(--n) * 60deg)); display: flex; flex-direction: column; align-items: center; span:nth-child(1),span:nth-child(2),span:nth-child(3),span:nth-child(4) &#123; width: calc(var(--slide-width)); height: calc(var(--slide-width)); border: 0.1em solid; border-width: 0.1em; border-style: none solid solid none; border-radius: 0.05em; transform: rotate(45deg); &#125; span:nth-child(1)&#123;--slide-width:0.2rem;&#125; span:nth-child(2)&#123;--slide-width:0.5rem;&#125; span:nth-child(3)&#123;--slide-width:0.4rem;&#125; span:nth-child(4)&#123;--slide-width:0.3rem;&#125; &#125; div:nth-child(1) &#123;--n: 1;&#125; div:nth-child(2) &#123;--n: 2;&#125; div:nth-child(3) &#123;--n: 3;&#125; div:nth-child(4) &#123;--n: 4;&#125; div:nth-child(5) &#123;--n: 5;&#125; div:nth-child(6) &#123;--n: 6;&#125;&#125;","categories":[],"tags":[{"name":"less","slug":"less","permalink":"https://wxmac.github.io/tags/less/"},{"name":"雪花","slug":"雪花","permalink":"https://wxmac.github.io/tags/雪花/"}]},{"title":"十四、eventloop事件循环","slug":"14.eventloop事件循环","date":"2020-01-24T16:00:00.000Z","updated":"2020-02-26T08:51:02.311Z","comments":true,"path":"2020/01/25/14.eventloop事件循环/","link":"","permalink":"https://wxmac.github.io/2020/01/25/14.eventloop事件循环/","excerpt":"","text":"eventloop事件循环 js是单线程执行的，eventloop事件循环就是解决javaScript单线程运行阻塞的一种机制。 一、宏任务和微任务 在 js 中，任务分为宏任务(macrotask)和微任务(microtask)，这两个任务分别维护一个队列，均采用先进先出(类似放盘子)的策略进行执行，同步执行的任务都在宏任务上执行。 1. 宏任务主要有：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)。 2. 微任务主要有：Promise.then、 MutationObserver、 process.nextTick(Node.js 环境)。 宏任务是由多个微任务组成的，先执行微任务，后执行宏任务。 二、运行机制 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 1. 执行一个宏任务（栈中没有就从事件队列中获取） 2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）三、🌰1.尝试输出以下代码 12345678910111213141516171819console.log(1);setTimeout(function() &#123; console.log(2);&#125;, 0);new Promise(function(resolve) &#123; console.log(3); resolve(Date.now());&#125;).then(function() &#123; console.log(4);&#125;);console.log(5);setTimeout(function() &#123; new Promise(function(resolve) &#123; console.log(6); resolve(Date.now()); &#125;).then(function() &#123; console.log(7); &#125;);&#125;, 0); 那么以上代码的执行过程是什么样的呢？ - 1 3 5 4 2 6 7 1. 代码从上往下执行，首先输出 1， 2. 遇到setTimeout，推入宏任务，待后面执行， 3. 遇到Promise，首先打印 3，把then后面的推入微任务， 4. 直接打印 5， 6. 遇到setTimeout，推入宏任务，待后面执行， 7. 微任务按顺序执行，打印 4， 8. 宏任务按顺序执行，打印 2，任务队列中没有微任务，下一步， 9. 执行宏任务，打印 6，把then后面的推入微任务， 10. 执行微任务，打印 7，完成。2.尝试输出以下代码 123456789101112131415161718192021222324252627async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');/** await async2()等价于 async2().then(() =&gt; &#123; console.log('async1 end'); &#125;)**/ 12345678910/* script start async1 start async2 promise1 script end async1 end promise2 setTimeout*/ 解析 1.首先定义了两个async，没调用，直接下一步， 2.执行 script start， 3.遇到setTimeout， 推入宏任务， 3.执行 async1函数,在await之前的代码是立即执行的，所以会立即输出 async1 start,遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2,打印async2， 4.往下走，遇到Promise，打印promise1， then推入微任务， 5.往下走，打印script end， 6.继续按顺序执行之前任务队列中的微任务，先打印async1 end， 再打印 promise2， 7.执行宏任务，打印setTimeout。","categories":[],"tags":[{"name":"eventloop","slug":"eventloop","permalink":"https://wxmac.github.io/tags/eventloop/"},{"name":"事件循环","slug":"事件循环","permalink":"https://wxmac.github.io/tags/事件循环/"}]},{"title":"十三、数组和字符串相关方法","slug":"13.数组和字符串相关方法","date":"2020-01-19T16:00:00.000Z","updated":"2020-01-02T01:48:57.442Z","comments":true,"path":"2020/01/20/13.数组和字符串相关方法/","link":"","permalink":"https://wxmac.github.io/2020/01/20/13.数组和字符串相关方法/","excerpt":"一：数组方法","text":"一：数组方法 1.splice() – 拼接数组 1234567891011121314151617181920212223242526272829// 使用1： 删除元素const arr = [1,2,3];arr.splice(0,1); // [1]/** 第一个参数（0）定义了删除元素的位置（下标）; 第二个参数（1）定义应删除多少元素; 该方法返回一个包含已删除项的数组,改变原数组 [2,3]**/// 使用2： 向指定位置添加元素const arr = [1,2,3];arr.splice(2,0,5,6); // []/** 第一个参数（2）定义了应添加新元素的位置（下标）; 第二个参数（0）定义应删除多少元素; 其余参数（'5','6'）定义要添加的新元素. 该方法返回一个包含已删除项的数组,改变原数组 [1, 2, 5, 6, 3]**/// 使用3： 向指定位置替换元素const arr = [1,2,3];arr.splice(2,1,5,6); // [3]/** 第一个参数（2）定义了应添加新元素的位置（下标）; 第二个参数（1）定义应删除多少元素; 其余参数（'5','6'）定义要添加的新元素. 该方法返回一个包含已删除项的数组,改变原数组 [1, 2, 5, 6]**/ 2.slice() – 裁剪数组 12345678910 // 使用1： 只有一个参数 -- 从下标 1 开始切出一段数组，结束参数被省略，则 slice() 会切出数组的剩余部分 const arr = [1,2,3,4,5]; arr.slice(1); // [2,3,4,5]; // 使用1： 两个参数 -- 从下标 1 到 3 切出一段数组（不包括结束参数） const arr = [1,2,3,4,5]; arr.slice(1,3); // [2,3]; // 该方法创建新数组,不会改变原数组 3.toString()、join() – 把数组转换为字符串 123const arr = [1,2,3];arr.toString(); // 1,2,3arr.join('-'); // 1-2-3 join() 可以规定分隔符 - 4.pop() – 方法从数组中删除最后一个元素 123456789101112131415161718192021 const arr = [1,2,3]; arr.pop(); // 3 // 该方法返回被删除的元素, 改变原数组 [1,2]/** 使用栈的思想扁平化数组： const flat = (arr) =&gt; &#123; const stack = [...arr]; const res = []; while( stack.length )&#123; const next = stack.pop(); if(Array.isArray(next))&#123; stack.push(...next); &#125; else &#123; res.push(next) &#125; &#125; return res.reverse();&#125;*/ 5.push() – 向数组末尾添加一个新的元素 123const arr = [1,2,3];arr.push(4); // 4// 该方法返回新数组的长度 length, 改变原数组 [1,2,3,4] 6.shift() – 删除首个数组元素 123const arr = [1,2,3];arr.shift(); // 1// 该方法返回被删除的元素, 改变原数组 [2,3] 7.unshift() – 向数组头部添加新元素 123const arr = [1,2,3];arr.unshift(9); // 4// 该方法返回新数组的长度 length, 改变原数组 [9,1,2,3] 8.concat() – 合并数组 1234const arr = [1,2,3];const newArr = [4,5,6];arr.concat(newArr); // [1,2,3,4,5,6]// 该方法不会更改现有数组，它总是返回一个新数组 [1,2,3,4,5,6] 9.sort() – 数组排序 1234567891011121314151617181920212223242526const arr = [2,1,3];arr.sort(); // [1,2,3]arr.sort((a,b) =&gt; b - a) // [3,2,1]// 该方法不会更改现有数组，它总是返回一个新数组 [1,2,3,4,5,6]/** // 1.排序 const compare = (property,desc) =&gt; &#123; return function (a, b) &#123; var value1 = a[property]; var value2 = b[property]; if(desc)&#123; // 升序排列 return value1 - value2; &#125;else&#123; // 降序排列 return value2 - value1; &#125; &#125; &#125; 2. 查找最大值 Math.max.apply(null, arr); 3. 查找最小值 Math.min.apply(null, arr);*/ 9.reverse() – 反转数组 12const arr = [1,2,3];arr.reverse(arr); // [3,2,1] 二：字符串方法1.indexOf() – 返回字符串中指定文本 首次 出现的索引（位置） 123const str = 'indexOf';str.indexOf('index'); // 0// 如果未找到文本， 返回 -1 2.lastIndexOf() – 返回指定文本在字符串中 最后 一次出现的索引 123const str = 'lastIndexOf';str.lastIndexOf('last'); // 0// 如果未找到文本， 返回 -1 3.slice()、substring()、substr() – 裁剪字符串 1234//有三种提取部分字符串的方法： - slice(start, end) - substring(start, end) - substr(start, length) slice() – 提取字符串的某个部分并在新字符串中返回被提取的部分 12345678const str = '提取字符串';str.slice(2,3); // '字'// 如果某个参数为负，则从字符串的结尾开始计数。str.slice(-3,-2); // '字'// 如果省略第二个参数，则该方法将裁剪字符串的剩余部分：str.slice(1); // '取字符串' substring() – 类似于 slice(), 但是无法接受负的索引 12const str = '提取字符串';str.substring(2,3); // '字' substr() – 类似于 slice(), 但是第二个参数规定被提取部分的长度 1234567const str = '提取字符串';str.substring(2,3); // '字符串'// 如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分。 str.substring(2); // '取字符串'//如果首个参数为负，则从字符串的结尾计算位置。第二个参数不能为负，因为它定义的是长度。 4.replace() – 用另一个值替换在字符串中指定的值 123const str = 'hello world';str.replace(/l/ig,'替换'); // \"he替换替换o wor替换d\" // 返回的是新字符串。 5.toUpperCase() – 把字符串转换为大写 12const str = 'hello world';str.toUpperCase(); // \"HELLO WORLD\" 6.toLowerCase() – 把字符串转换为小写 12const str = 'HELLO WORLD';str.toLowerCase(); // \"hello world\" 7.concat() – 连接两个或多个字符串 123const str = 'hello';const str2 = 'world';str.concat(str2); // \"helloworld\" 8.trim() – 删除字符串两端的空白符： 12const str = ' hello world ';str.trim(); // \"hello world\" 9.split() – 将字符串转换为数组 12const str = '1,2,3,4';str.split(','); // [\"1\", \"2\", \"3\", \"4\"]","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://wxmac.github.io/tags/字符串/"},{"name":"字符串方法","slug":"字符串方法","permalink":"https://wxmac.github.io/tags/字符串方法/"},{"name":"数组","slug":"数组","permalink":"https://wxmac.github.io/tags/数组/"},{"name":"数组方法","slug":"数组方法","permalink":"https://wxmac.github.io/tags/数组方法/"}]},{"title":"十二、数组去重","slug":"12.数组去重","date":"2020-01-14T16:00:00.000Z","updated":"2020-01-17T06:35:21.535Z","comments":true,"path":"2020/01/15/12.数组去重/","link":"","permalink":"https://wxmac.github.io/2020/01/15/12.数组去重/","excerpt":"数组去重","text":"数组去重 reduce + find 1234567891011121314const data = [1,2,3,4,5,1,2,6,7];const distinct = (arr) =&gt; &#123; return arr.reduce((total,curr, index) =&gt; &#123; // find返回数组中满足提供的测试函数的第一个元素的值 const exist = total.find((item) =&gt; item === curr ); if(!exist)&#123; total.push(curr) &#125; return total &#125;,[]) &#125;console.log(distinct(data)); // // [1, 2, 3, 4, 5, 6, 7]// 利用find查找是否存在相同元素，如果不存在就push到数组里 1.filter + indexOf 123456789const arr = [1,2,3,4,5,1,2];const distinct = (arr) =&gt; &#123; return arr.filter((item,index) =&gt; &#123; return arr.indexOf(item) === index &#125;)&#125;;console.log(distinct(arr));// [1, 2, 3, 4, 5]// 利用indexOf检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素 双重for循环 123456789101112131415const data = [1,2,3,4,5,1,2];const distinct = (arr) =&gt; &#123; for( let i = 0; i &lt; arr.length; i++ )&#123; for(let j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] === arr[j])&#123; arr.splice(j, 1); j--; &#125; &#125; &#125; return arr;&#125;; console.log(distinct(data)); // [1, 2, 3, 4, 5] // 先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组 ES6 中的 Set 去重 12345const data = [1,2,3,4,5,1,2];const distinct = (arr) =&gt; &#123; return [...new Set(arr)]&#125;;console.log(distinct(data)); // [1, 2, 3, 4, 5] 例子🌰 12345678910111213141516171819202122232425262728293031/** （携程）算法手写题 已知如下数组： var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 编写一个程序将数组扁平化并去除其中重复部分数据，最终得到一个升序且不重复的数组**/var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];const flat = (arr) =&gt; &#123; // 扁平化数组 return arr.reduce((total, curr) =&gt; &#123; return Array.isArray(curr) ? total.concat(flat(curr)) : total.concat(curr) &#125;,[])&#125;const newArr = flat(arr);const removeRepeat = (arr) =&gt; &#123; // 数组去重 return arr.filter((item,index) =&gt; &#123; return arr.indexOf(item) === index &#125;)&#125;const res = removeRepeat(newArr)console.log(res.sort((a,b) =&gt; a - b))// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]/** 简便解法： Array.from( new Set( arr.flat(Infinity)) ).sort(( a, b )=&gt;a - b)**/","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"https://wxmac.github.io/tags/数组/"},{"name":"数组去重","slug":"数组去重","permalink":"https://wxmac.github.io/tags/数组去重/"}]},{"title":"十一、九宫格抽奖","slug":"11.九宫格抽奖","date":"2020-01-09T16:00:00.000Z","updated":"2019-12-26T05:56:43.066Z","comments":true,"path":"2020/01/10/11.九宫格抽奖/","link":"","permalink":"https://wxmac.github.io/2020/01/10/11.九宫格抽奖/","excerpt":"九宫格抽奖","text":"九宫格抽奖 1.js实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130class Lottery&#123; constructor(&#123; startBtnEl, giftAllEl, prizeIndex, delayTime, animateTime, clearActive, _luckyTimes, haveChange, successCallback = () =&gt; &#123;&#125; &#125;)&#123; Object.assign(this,&#123; startBtnEl, // 开始按钮 giftAllEl, // 所有奖品公共class prizeIndex: prizeIndex || '谢谢参与', // 抽中奖品下标 _luckyTimes: _luckyTimes || 0, // 抽奖次数 delayTime: delayTime || 3000, // 延时多少秒得到结果 animateTime: animateTime || 200, // 动画时间 clearActive: clearActive || true, // 清除状态 haveChange: haveChange || false, // 是否还有抽奖机会 successCallback // 抽中奖品回调 &#125;) this.$prizeItemsEl = null, // 奖品 this.lotteryPrizeIndex = 0, // 九宫格对应下标 this.timer = null, // 定时器 this.init() &#125; init()&#123; this.$lotteryStartEl = document.querySelector(this.startBtnEl) this.$prizeItemsEl = document.querySelectorAll(this.giftAllEl) // 🏅奖品 this.initStartEvent() &#125; initStartEvent()&#123; let haveChange = this.haveChange; const el = this.$lotteryStartEl el.onclick = () =&gt; &#123; if (!el.classList.contains('disabled') ) &#123; this.setStartBtnStatus(true) if (haveChange) &#123; // 有抽奖机会，得到抽奖结果 this.getTargetPrize() this.handleStartAnimate() &#125; else &#123; // 没有抽奖机会了 console.log('没有抽奖机会了') &#125; &#125; &#125; &#125; // 开始抽奖动画 handleStartAnimate()&#123; this.lotteryPrizeIndex = 0 this.timer = setInterval(() =&gt; &#123; this.lotteryPrizeIndex = this.lotteryPrizeIndex === 8 ? 1 : this.lotteryPrizeIndex + 1; this.addPrizeMask(); // 这里很巧妙，lottery-prize_item_index 和html一致 document.querySelector(`.lottery-prize_item_$&#123;this.lotteryPrizeIndex&#125;`).classList.remove('mask') &#125;, this.animateTime) return this.timer &#125; // 添加所有奖品的遮罩状态 addPrizeMask()&#123; for (let i = 0, l = this.$prizeItemsEl.length; i &lt; l; i++) &#123; this.$prizeItemsEl[i].classList.add('mask') &#125; &#125; // 清除所有奖品的遮罩状态 clearPrizeActive () &#123; for (let i = 0, l = this.$prizeItemsEl.length; i &lt; l; i++) &#123; this.$prizeItemsEl[i].classList.remove('mask') &#125; &#125; // 抽奖结果 getTargetPrize()&#123; // 模拟随机得到一个结果 let prizeIndex = this.prizeIndex; if(prizeIndex == '谢谢参与')&#123; return &#125; if(prizeIndex == 0 || prizeIndex == 9)&#123; prizeIndex = 1 &#125; // 延时几秒得到结果 setTimeout(() =&gt; &#123; typeof this.successCallback === 'function' &amp;&amp; this.successCallback(prizeIndex) this.stopPrizeAnimate(prizeIndex) &#125;, this.delayTime) &#125; // 关闭抽奖动画 stopPrizeAnimate(index)&#123; if (index) &#123; let stopTimer = null stopTimer = setInterval(() =&gt; &#123; if (index === this.lotteryPrizeIndex ) &#123; clearInterval(stopTimer) clearInterval(this.timer) this.setStartBtnStatus() if (this.clearActive) &#123; //this.clearPrizeActive() &#125; &#125; &#125;, 100) &#125; else &#123; this.setStartBtnStatus() clearInterval(this.timer) this.clearPrizeActive() &#125; &#125; // 按钮状态 setStartBtnStatus (status) &#123; if (status) &#123; this.$lotteryStartEl.classList.add('disabled') &#125; else if (this._luckyTimes) &#123; this.$lotteryStartEl.classList.remove('disabled') &#125; &#125;&#125;new Lottery(&#123; startBtnEl: '.J_lottery-start', giftAllEl: '.lottery-prize_item', prizeIndex:2 , haveChange: true, _luckyTimes: 2, successCallback(prizeIndex)&#123; console.log('prizeIndex---&gt;',prizeIndex) &#125;&#125;) 2.html结构 123456789101112131415161718192021222324252627&lt;div class=\"lottery-prize_items\"&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_1\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_2\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_3\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_8\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-start J_lottery-start \"&gt;GO! &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_4\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_7\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_6\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_5\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt;&lt;/div&gt; 3.css 1234567891011121314151617181920212223242526272829303132333435363738394041424344*&#123;margin: 0; padding: 0;&#125; .lottery-prize_items&#123; width: 430px; height:400px; display: flex; flex-wrap: wrap; justify-content: space-between; align-content: space-between; padding: 20px; background-color: #446CD3; border-radius: 5px; &#125; .lottery-prize_items .lottery-prize_item, .lottery-prize_items .lottery-start&#123; width: 120px; height: 120px; background: #D2DAFF; background: #fff; border-radius: 5px; position: relative; display: flex; align-items: center; justify-content: center; user-select: none; overflow: hidden; &#125; .lottery-prize_items .mask:after&#123; display: block; content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 120px; background: rgba(94, 139, 255, 0.4); border-radius: 5px; &#125; .lottery-prize_items .disabled&#123; background: #C4C6CA; color: #fff; &#125; .lottery-prize_items .lottery-prize_item img&#123; width: 120px; height: 120px; &#125;","categories":[],"tags":[{"name":"lottery","slug":"lottery","permalink":"https://wxmac.github.io/tags/lottery/"},{"name":"抽奖","slug":"抽奖","permalink":"https://wxmac.github.io/tags/抽奖/"}]},{"title":"十、节日头像小挂件","slug":"10.节日头像小挂件","date":"2020-01-04T16:00:00.000Z","updated":"2019-12-26T05:18:57.621Z","comments":true,"path":"2020/01/05/10.节日头像小挂件/","link":"","permalink":"https://wxmac.github.io/2020/01/05/10.节日头像小挂件/","excerpt":"实现思路：参考大佬链接 上传的头像和小挂件要匹配到一起，利用canvas生成图片，并下载。","text":"实现思路：参考大佬链接 上传的头像和小挂件要匹配到一起，利用canvas生成图片，并下载。 实现代码 首先把html写好，再加上一顿CSS操作，样式如下12345678910111213// htmlconst &#123; targetUrl, loading &#125; = this.state;&lt;div className=&#123; `$&#123;styleCss.avatarBox&#125; ` &#125;&gt;&lt;div className=&#123; `$&#123;styleCss.avatar_main&#125; $&#123;loading ? styleCss.loader : ''&#125;` &#125;&gt; &lt;img onClick=&#123; () =&gt; this.handleArrowChange('LEFT') &#125; className=&#123; styleCss.arrowLeft &#125; src=&#123; require('@/assets/img/avatar/arrowLeft.svg') &#125; alt=\"\"/&gt; &lt;img onClick=&#123; () =&gt; this.handleArrowChange('RIGHT') &#125; className=&#123; styleCss.arrowRight &#125; src=&#123; require('@/assets/img/avatar/arrowRight.svg') &#125; alt=\"\"/&gt;&lt;/div&gt;&lt;input type=\"file\" accept=\"image/*\" onChange=&#123; (e) =&gt; this.handleUploadImgInit(e) &#125;/&gt;&lt;img src=&#123; targetUrl &#125; alt=\"\" className=&#123; styleCss.avatar_target &#125;/&gt;&lt;/div&gt;&lt;canvas className=&#123; styleCss.canvas &#125; ref=\"canvas\" /&gt; 核心代码 1、定义相关变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const CANVANS_SIZE = 256;// 小挂件数组,style位置和大小信息需要自己试验一下const imgSourceList = [&#123; source: require('@/assets/img/avatar/1.png'), style: &#123; width: 108, height: 88, top: `$&#123;CANVANS_SIZE - 88&#125;`, left: `$&#123;CANVANS_SIZE - 108&#125;` &#125;&#125;, &#123; source: require('@/assets/img/avatar/2.png'), style: &#123; width: 128, height: 128, top: `$&#123;CANVANS_SIZE - 108&#125;`, left: `$&#123;CANVANS_SIZE - 118&#125;` &#125;&#125;, &#123; source: require('@/assets/img/avatar/3.png'), style: &#123; width: 96, height: 108, top: `$&#123;CANVANS_SIZE - 128&#125;`, left: `$&#123;CANVANS_SIZE - 86&#125;` &#125;&#125;, &#123; source: require('@/assets/img/avatar/4.png'), style: &#123; width: CANVANS_SIZE, height: 226, top: -38, left: 0 &#125;&#125;, &#123; source: require('@/assets/img/avatar/5.png'), style: &#123; width: 100, height: 126, top: 0, left: CANVANS_SIZE / 3 &#125;&#125;];this.state=&#123; decorationCurrent: imgSourceList[0], // 小挂件1 decorationList: imgSourceList, // 小挂件数组 currentIndex:0, // 当前挂件下标 loading:false // 是否显示加载&#125; 2、初始化canvas 1234567891011121314151617 componentDidMount()&#123; const &#123; decorationCurrent &#125; = this.state; // 初始化挂载小挂件 this.handleMakeImage(null, decorationCurrent).then(targetUrl =&gt; &#123; this.setState(&#123; targetUrl &#125;); &#125;);// 挂载canvas this.initCanvas(); &#125; initCanvas() &#123; const &#123; canvas &#125; = this.refs; canvas.width = CANVANS_SIZE; canvas.height = CANVANS_SIZE; &#125; 3、上传图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 async handleUploadImgInit(e)&#123; const _this = this; const target = e.target; const &#123; canvas &#125; = this.refs; const &#123; decorationCurrent &#125; = this.state; const context = canvas.getContext('2d'); const files = e.target.files[0]; // 上传的图片 const base64Url = await this.handleBase64Img(files); const imgObj = await this.createImage(base64Url);// 调整用户图片尺寸// 无论宽大于高还是宽小于高，都会进行等比缩放 const type = imgObj.width - imgObj.height; if (type &gt; 0) &#123; // 宽 &gt; 高 const w = imgObj.width * CANVANS_SIZE / imgObj.height; context.drawImage(imgObj, 0, 0, w, CANVANS_SIZE); &#125; else if (type &lt; 0) &#123; // 宽 &lt; 高 const h = imgObj.height * CANVANS_SIZE / imgObj.width; context.drawImage(imgObj, 0, 0, CANVANS_SIZE, h); &#125; else &#123; context.drawImage(imgObj, 0, 0, CANVANS_SIZE, CANVANS_SIZE);&#125;// canvas转图片 const imgUrl = canvas.toDataURL('image/png'); this.setState(&#123; imgUrl:imgUrl &#125;,() =&gt; &#123; target.value = ''; // 可以重复上传同一张图片 &#125;) this.handleMakeImage(imgUrl, decorationCurrent).then(targetUrl =&gt; &#123; this.setState(&#123; targetUrl &#125;); &#125;); &#125; // 上传图片base64转化 handleBase64Img(files)&#123; return new Promise((resolve,reject) =&gt; &#123; let reads = new FileReader(); reads.readAsDataURL(files); reads.onload = function(e) &#123; resolve(this.result); &#125;; &#125;) &#125; // 创建图片 createImage(imgUrl) &#123; return new Promise((resolve, rejest) =&gt; &#123; const imgObj = new Image(); imgObj.src = imgUrl; imgObj.onload = (e) =&gt; &#123; resolve(imgObj); &#125;; &#125;); &#125; 4、把头像和挂件组合在一起，生成图片链接（关键） 123456789101112131415161718192021222324252627/** * @param &#123; string &#125; imgUrl -- 处理的用户图片url * @param &#123; object &#125; decorationCurrent -- 小挂件 * */ async handleMakeImage(imgUrl, decorationCurrent)&#123; if (!(imgUrl || decorationCurrent)) &#123; return ''; &#125; const &#123; source, style &#125; = decorationCurrent; const &#123; width, height, top, left &#125; = style; const &#123; canvas &#125; = this.refs; this.clearCanvas(canvas); const context = canvas.getContext('2d'); if (imgUrl) &#123; const bgImg = await this.createImage(imgUrl); context.drawImage(bgImg, 0, 0, bgImg.width, bgImg.height); &#125; if (decorationCurrent &amp;&amp; source) &#123; const imgObj = await this.createImage(source); context.drawImage(imgObj, left, top, width, height); &#125; const targetUrl = canvas.toDataURL('image/png'); return targetUrl;&#125;clearCanvas(targetCanvans) &#123; let ctx = targetCanvans.getContext('2d'); ctx.clearRect(0, 0, targetCanvans.width, targetCanvans.height);&#125; 5、左右切换小挂件 12345678910111213141516171819202122232425handleArrowChange(type)&#123; const &#123; decorationList &#125; = this.state; const length = decorationList.length - 1; let index = 0; this.setState((prvState) =&gt;&#123; if(type === 'LEFT')&#123; // 左 index = --prvState.currentIndex &lt; 0 ? length : prvState.currentIndex; &#125; else &#123; // 右 index = ++prvState.currentIndex &gt; length ? 0 : prvState.currentIndex; &#125; return &#123; loading:true, currentIndex:index, decorationCurrent: imgSourceList[index], &#125; &#125;, () =&gt; &#123; const &#123; imgUrl, decorationCurrent&#125; = this.state; this.handleMakeImage(imgUrl, decorationCurrent).then(targetUrl =&gt; &#123; this.setState(&#123; targetUrl, loading:false, &#125;); &#125;); &#125;) &#125;","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://wxmac.github.io/tags/canvas/"},{"name":"小挂件","slug":"小挂件","permalink":"https://wxmac.github.io/tags/小挂件/"}]},{"title":"九、将具有相同属性的对象合并到一个数组中","slug":"9.属性合并","date":"2019-12-31T16:00:00.000Z","updated":"2020-03-05T03:07:29.053Z","comments":true,"path":"2020/01/01/9.属性合并/","link":"","permalink":"https://wxmac.github.io/2020/01/01/9.属性合并/","excerpt":"将具有相同属性的对象合并到一个数组中","text":"将具有相同属性的对象合并到一个数组中 新年新气象，新的一年，继续加油。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let data = [ &#123; 'group_name':'A', 'type': 'apple' &#125;, &#123; 'group_name':'A', 'type': 'almond' &#125;, &#123; 'group_name':'B', 'type': 'banana' &#125;, &#123; 'group_name':'B', 'type': 'bennet' &#125;];//代码实现// &#123; group_name, type &#125; = currValueconst res = data.reduce( (prv, currValue ) =&gt; &#123; const exist = prv.find(item =&gt; item.type == currValue.group_name); if (exist) &#123; exist[\"data\"].push( currValue ); &#125; else &#123; prv.push(&#123; type: currValue.group_name, data: [ currValue ]&#125;) &#125; return prv;&#125;, []);console.log(res)// 打印结果如下：[ &#123; 'type':A, data:[ &#123; 'group_name':'A', 'type': 'apple' &#125;, &#123; 'group_name':'A', 'type': 'almond' &#125;, ] &#125;, &#123; 'type':B, data:[ &#123; 'group_name':'B', 'type': 'banana' &#125;, &#123; 'group_name':'B', 'type': 'bennet' &#125; ] &#125;]","categories":[],"tags":[{"name":"reduce","slug":"reduce","permalink":"https://wxmac.github.io/tags/reduce/"},{"name":"数组","slug":"数组","permalink":"https://wxmac.github.io/tags/数组/"}]},{"title":"八、扁平化数组","slug":"8.扁平化数组","date":"2019-12-29T16:00:00.000Z","updated":"2020-02-26T08:45:10.151Z","comments":true,"path":"2019/12/30/8.扁平化数组/","link":"","permalink":"https://wxmac.github.io/2019/12/30/8.扁平化数组/","excerpt":"一：Array.prototype.flat()","text":"一：Array.prototype.flat() 12345678910111213141516171819202122const arr = [1,2,3,[4,5,6,[7,8]],9,10];// 不传参数时，默认“拉平”一层arr.flat();// // [1, 2, 3, 4, 5, 6, [7,8], 9, 10]// 传入一个整数参数，整数即“拉平”的层数arr.flat(2);// // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// Infinity 关键字作为参数时，无论多少层嵌套，都会转为一维数组// Infinity(无穷大)在 JS 中是一个特殊的数字，它的特性是：它比任何有限的数字都大。arr.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// 传入 &lt;=0 的整数将返回原数组，不“拉平”arr.flat(0);arr.flat(-10); // [1,2,3,[4,5,6,[7,8]],9,10]//如果原数组有空位，flat()方法会过滤空位[1,2,3,,].flat()// [1, 2, 3] 二：其他方法实现1.reduce12345const flat = (arr) =&gt; &#123; return arr.reduce((prv,cur) =&gt; &#123; return Array.isArray(cur) ? prv.concat(flat(cur)) : prv.concat(cur) &#125;,[])&#125; 2.使用栈的思想实现 flat 函数12345678910111213const flat = (arr) =&gt; &#123; const stack = [...arr]; const res = []; while( stack.length )&#123; const next = stack.pop(); if(Array.isArray(next))&#123; stack.push(...next); &#125; else &#123; res.push(next) &#125; &#125; return res.reverse();&#125; 3.通过传入整数参数控制“拉平”层数 123456789const flat = (arr, num = 1) =&gt; &#123; return num &gt; 0 ? arr.reduce( (pre, cur) =&gt; pre.concat(Array.isArray(cur) ? flat(cur, num - 1) : cur),[]) : arr.slice()&#125;#const arr = [1,2,3,[1,2,3,4, [2,3,4]]];#flat(arr,Infinity) MDN参考链接 其他参考","categories":[],"tags":[{"name":"flat","slug":"flat","permalink":"https://wxmac.github.io/tags/flat/"},{"name":"扁平化数组","slug":"扁平化数组","permalink":"https://wxmac.github.io/tags/扁平化数组/"}]},{"title":"七、不刷新修改url链接","slug":"7.不刷新修改url链接","date":"2019-12-24T16:00:00.000Z","updated":"2020-02-26T08:44:44.253Z","comments":true,"path":"2019/12/25/7.不刷新修改url链接/","link":"","permalink":"https://wxmac.github.io/2019/12/25/7.不刷新修改url链接/","excerpt":"有一个这样的需求，点击分页，不刷新页面。 123//我们的page参数是记录在url里的： https://xxx.html?page=1//如果采取硬拼接的方式，无疑会刷新页面window.location.href = window.location.pathname + `?page=$&#123;page&#125;`","text":"有一个这样的需求，点击分页，不刷新页面。 123//我们的page参数是记录在url里的： https://xxx.html?page=1//如果采取硬拼接的方式，无疑会刷新页面window.location.href = window.location.pathname + `?page=$&#123;page&#125;` 1.pushState() 方法MDN链接 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL. 让我们来解释下这三个参数详细内容：： 状态对象 — 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本 标题 — Firefox 目前忽略这个参数，但未来可能会用到。在此处传一个空字符串应该可以安全的防范未来这个方法的更改。或者，你可以为跳转的state传递一个短标题 URL — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL 2.pushState使用123const pageSize = 2;const url = `$&#123;window.location.pathname&#125;?page=$&#123;pageSize&#125;`window.history.pushState(&#123;url: url&#125;, '', url); 以上就能实现页面无刷新修改url链接。 3.获取和修改url的函数： 顺便放上获取和修改url的函数：↓ 获取url参数12345function getParams (name) &#123; let reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); let r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 更改url参数123456789101112function replaceParamVal(paramName,replaceWith) &#123; var oUrl = window.location.href.toString(); var re = evil('/('+ paramName+'=)([^&amp;]*)/gi'); var nUrl = oUrl.replace(re,paramName+'='+replaceWith); this.location = nUrl; window.location.href=nUrl&#125;function evil(fn) &#123; let Fn = Function; //一个变量指向Function，防止有些前端编译工具报错 return new Fn('return ' + fn)();&#125;","categories":[],"tags":[{"name":"pushState","slug":"pushState","permalink":"https://wxmac.github.io/tags/pushState/"},{"name":"url","slug":"url","permalink":"https://wxmac.github.io/tags/url/"}]},{"title":"六、函数节流和防抖","slug":"6.函数节流和防抖","date":"2019-12-22T16:00:00.000Z","updated":"2020-02-26T08:43:29.378Z","comments":true,"path":"2019/12/23/6.函数节流和防抖/","link":"","permalink":"https://wxmac.github.io/2019/12/23/6.函数节流和防抖/","excerpt":"1.节流 核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动下一个定时器任务。","text":"1.节流 核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动下一个定时器任务。 123456789101112const throttle = (fn, delay) =&gt; &#123; let flag = true; return (...args) =&gt; &#123; let context = this; if (!flag) return; flag = false; setTimeout(() =&gt; &#123; fn.apply(context, args); flag = true; &#125;, delay); &#125;;&#125;; 2.防抖 核心思想: 每次事件触发都删除原来的定时器，建立新的定时器，反复触发函数，那么从最后一次触发开始计时。 123456789101112const debounce = (fn, delay) =&gt; &#123; let timer = null; return (...args) =&gt; &#123; let context = this; if(timer)&#123; clearTimeout(timer) &#125;; timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125;&#125; 3.合并 现在我们可以把防抖和节流放到一起，有时候触发的太频繁会导致一次响应都没有，我们希望到了固定的时间必须给用户一个响应。 12345678910111213const throttle = (fn, delay) =&gt; &#123; let flag = true, timer = null; return function (...args) &#123; let context = this; if( !flag )&#123; return &#125;; clearTimeout(timer); flag = false; timer = setTimeout(function() &#123; flag = true; fn.apply(context, args); &#125;, delay); &#125;&#125; 4.实践 – 图片懒加载clientHeight 、scrollTop 、 offsetTop 思路： 给img一个默认图片，以及data-src属性，当页面滚动到对应img元素的时候，把data-src赋值给src。12345678910111213141516171819202122232425//给img一个默认图片&lt;img src=\"default.png\" data-src=\"xxx/img.png\" /&gt;//通过监听 scroll 事件来判断图片是否到达视口:let img = document.getElementsByTagName(\"img\");let num = img.length;let count = 0; //计数器，从第一张图片开始计lazyload(); //首次加载window.addEventListener('scroll', throttle(lazyload, 200)); //节流function lazyload() &#123; let viewHeight = document.documentElement.clientHeight;// 视口高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//滚动条滚动的高度 for(let i = count; i &lt; num; i++) &#123; //元素现在已经出现在视口中 if( img[i].offsetTop &lt; scrollHeight + viewHeight ) &#123; if(img[i].getAttribute('src') !== 'default.png') continue; //如果src不是default.png'，跳过循环，继续往下循环 img[i].src = img[i].getAttribute(\"data-src\"); count ++; &#125; &#125;&#125;//scrollTop + clientHeight === scrollHeight 即触发下拉加载的条件","categories":[],"tags":[{"name":"函数","slug":"函数","permalink":"https://wxmac.github.io/tags/函数/"},{"name":"节流/防抖","slug":"节流-防抖","permalink":"https://wxmac.github.io/tags/节流-防抖/"}]},{"title":"五、js 深拷贝与浅拷贝","slug":"5.js 深拷贝与浅拷贝","date":"2019-12-17T16:00:00.000Z","updated":"2020-02-26T08:43:12.573Z","comments":true,"path":"2019/12/18/5.js 深拷贝与浅拷贝/","link":"","permalink":"https://wxmac.github.io/2019/12/18/5.js 深拷贝与浅拷贝/","excerpt":"1.基本数据类型和引用数据类型 数据分为基本数据类型和引用数据类型 基本数据类型: 1String、Number、Boolean、Null、Undefined、Symbol、BigInt(?) 引用数据类型: 1Array、Object","text":"1.基本数据类型和引用数据类型 数据分为基本数据类型和引用数据类型 基本数据类型: 1String、Number、Boolean、Null、Undefined、Symbol、BigInt(?) 引用数据类型: 1Array、Object 2.概念 浅拷贝： 1仅仅复制对象的引用，而不是对象本身 深拷贝： 1把复制的对象所引用的全部对象都复制一遍 简单来说，浅拷贝就是这个人的影子，深拷贝就是复制了这个人。 3.方法浅拷贝 123456789const shallowClone = (obj) =&gt; &#123; const result = []; for (let i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; result[i] = obj[i]; &#125; &#125; return result;&#125; Object的 hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性,hasOwnProperty()方法来忽略继承属性.。 object.assign() 把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象 Array.prototype.concat() 数组的一个内置方法，用户合并两个或者多个数组，不会改变现有数组，而是返回一个新数组 Array.prototype.slice() 数组的一个内置方法，该方法会返回一个新的对象，不会改变原数组 obj展开运算符 […]以上几种方式也可以深拷贝 1234567891011121314const deepClone = (obj) =&gt; &#123; let result = Array.isArray(obj) ? [] : &#123;&#125;; for( let i in obj )&#123; if( obj.hasOwnProperty(i) )&#123; if( typeof obj[i] === 'object' &amp;&amp; obj[i] !== null)&#123; result[i] = deepClone(obj[i]) //递归复制 &#125; else &#123; result[i] = obj[i] &#125; &#125; &#125; return result;&#125;//Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。hasOwnProperty()方法来忽略继承属性 JSON.stringfy()和JSON.parse()会忽略undefined、function、symbol，导致属性丢失。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"小技巧","slug":"小技巧","permalink":"https://wxmac.github.io/tags/小技巧/"},{"name":"拷贝","slug":"拷贝","permalink":"https://wxmac.github.io/tags/拷贝/"}]},{"title":"四、react & html2canvas 生成图片下载实践","slug":"4.react & html2canvas实践","date":"2019-12-15T16:00:00.000Z","updated":"2020-02-26T08:42:11.273Z","comments":true,"path":"2019/12/16/4.react & html2canvas实践/","link":"","permalink":"https://wxmac.github.io/2019/12/16/4.react & html2canvas实践/","excerpt":"html2canvas的选择 现在一般生成图片有前端处理和后端处理两种方式，后端生成的方案不需要前端出力，只需要拿路径渲染，但是会出现数据延时，模板更换困难等问题，出于灵活性和减少后端工作量考虑，我们采取 html2canvas 绘制页面。 html2canvas npmhtml2canvas 介绍","text":"html2canvas的选择 现在一般生成图片有前端处理和后端处理两种方式，后端生成的方案不需要前端出力，只需要拿路径渲染，但是会出现数据延时，模板更换困难等问题，出于灵活性和减少后端工作量考虑，我们采取 html2canvas 绘制页面。 html2canvas npmhtml2canvas 介绍 1.在react中的使用123456789101112131415//安装npm install --save html2canvasoryarn add html2canvas//引入import html2canvas from 'html2canvas';//使用html2canvas(document.body).then(function(canvas) &#123; document.body.appendChild(canvas);&#125;);//如果想生成一部分页面的话，html2canvas可以换成 this.refs.demo//&lt;div ref=\"demo\"&gt;&lt;/div&gt; 上面就会把页面简单的绘制出来。 2.canvas 下载12345678910html2canvas(this.refs.demo).then(function(canvas) &#123; const imgUrl = canvas.toDataURL(\"image/png\"); // 获取图片的url const elA = document.createElement(\"a\"); elA.download = +new Date() + \".png\"; elA.href = imgUrl ; elA.click(); elA.remove();&#125;);//微信中不能下载图片，可以展示图片并提示用户长按保存图片 3.参考 参考1 4.canvas添加图片12345678910111213141516171819202122const SIZE = 300;/** @type &#123;HTMLCanvasElement&#125; */ const canvas = this.refs.canvas;const ctx = canvas.getContext('2d');const img = new Image()img.crossOrigin = \"anonymous\";img.src = '图片路径';img.onload = () =&gt; &#123; const w = img.width; const h = img.height; const type = w - h if(type &gt; 0)&#123; const width = w * ( SIZE / h ) ctx.drawImage(img, 0, 0, width , SIZE) &#125; else if(type &lt; 0) &#123; const hieght = h * ( SIZE / w ) ctx.drawImage(img, 0, 0, SIZE , hieght) &#125; else &#123; ctx.drawImage(img, 0, 0, SIZE , SIZE) &#125;&#125;","categories":[],"tags":[{"name":"html2canvas","slug":"html2canvas","permalink":"https://wxmac.github.io/tags/html2canvas/"},{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"react","slug":"react","permalink":"https://wxmac.github.io/tags/react/"}]},{"title":"三 - 一、一些自己在使用css、js技巧","slug":"3-1.一些自己在js技巧","date":"2019-12-11T16:00:00.000Z","updated":"2020-03-12T09:51:02.160Z","comments":true,"path":"2019/12/12/3-1.一些自己在js技巧/","link":"","permalink":"https://wxmac.github.io/2019/12/12/3-1.一些自己在js技巧/","excerpt":"","text":"一、JS – 更新中判断 val 是否存在123456789101112131415161718192021222324 1. for(let item in data)&#123; if(!data[item])&#123; data[item] = '--'; &#125; &#125; // 是否是空对象，&#123;&#125;返回true 2. const isEmptyObject = function( obj ) &#123;var name;for ( name in obj ) &#123; return false;&#125;return true; &#125;; 3. const page = &#123; user:'111', cityInfo:&#123; city:'hz', code:'111' &#125; &#125;; const name = ( (page || &#123;&#125;).cityInfo || &#123;&#125; ).city || '111'; console.log(name) 滑动固定距离显示123456789101112 var oNav = document.getElementById(\"Q-nav\");window.onscroll = function()&#123; var h = 168; var sTop = document.body.scrollTop || document.documentElement.scrollTop; if( sTop &gt; h )&#123; //吸顶 固定定位 并且 top 设置为 0 oNav.style.position = \"fixed\"; oNav.style.top = 0; &#125;else&#123; oNav.style.position = \"static\"; &#125;&#125; 上传图片回填12345let reads = new FileReader();reads.readAsDataURL(files);reads.onload = function(e) &#123; document.getElementById('ID').src = this.result;&#125;; 获取url参数12345function getParams (name) &#123; let reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); let r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 更改url参数123456789101112function replaceParamVal(paramName,replaceWith) &#123; var oUrl = window.location.href.toString(); var re = evil('/('+ paramName+'=)([^&amp;]*)/gi'); var nUrl = oUrl.replace(re,paramName+'='+replaceWith); this.location = nUrl; window.location.href=nUrl&#125;function evil(fn) &#123; let Fn = Function; //一个变量指向Function，防止有些前端编译工具报错 return new Fn('return ' + fn)();&#125; ios window.history.back() 致使 localStorage不同步123456window.onpageshow = function(event) &#123; if (event.persisted || (window.performance &amp;&amp; window.performance.navigation.type == 2)) &#123; window.location.reload(); &#125;&#125; textatea 高度自适应123456789101112//jq:el.on('input', function () &#123; const height = $(this).scrollTop() + $(this).prop(\"scrollHeight\") + \"px\"; $(this).height(height)&#125;)//react :const el = this.refs.remark;el.style.height = 'auto'; if(el.scrollHeight &gt;= el.offsetHeight )&#123; //如果高度不够，再重新设置 el.style.height = el.scrollHeight + 'px'&#125; 查找重复字符123456let red= 'hjqjbsaxhhhh'; let obj = &#123;&#125;;for (var i = 0; i&lt;red.length; i++) &#123; obj[red[i]] = ++obj[red[i]] || 1 ; console.log(red[i]) &#125; 安卓键盘置顶按钮(安卓会出现键盘出来,按钮在下面没上来的情况)12345678910111213function handleSetBtnPosition()&#123; let win_h = $(window).height(); window.addEventListener('resize', function () &#123; var u = navigator.userAgent; if (u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1) &#123; if($(window).height() &lt; win_h)&#123; $(\"#submit_btn\").hide(); &#125;else&#123; $(\"#submit_btn\").show(); &#125; &#125; &#125;);&#125; 手机号自动添加空格1\"13116700755\".replace(/(?&lt;=^\\d&#123;3&#125;(\\d&#123;4&#125;)*)(?!$)/g, ' ') ---&gt; \"131 1670 0755\" 获取key和val，组成新对象123456789101112131415161718192021222324252627282930313233343536const cities = [ &#123; name: 'Paris', visited: 'no' &#125;, &#123; name: 'Lyon', visited: 'no' &#125;, &#123; name: 'Marseille', visited: 'yes' &#125;, &#123; name: 'Rome', visited: 'yes' &#125;, &#123; name: 'Milan', visited: 'no' &#125;, &#123; name: 'Palermo', visited: 'yes' &#125;, &#123; name: 'Genoa', visited: 'yes' &#125;, &#123; name: 'Berlin', visited: 'no' &#125;, &#123; name: 'Hamburg', visited: 'yes' &#125;, &#123; name: 'New York', visited: 'yes' &#125;]; const result = cities.reduce((prv, item) =&gt; &#123; return &#123; ...prv, [item.name]: item.visited &#125;&#125;, &#123;&#125;);console.log(result);/** 打印结果： &#123; Paris: \"no\", Lyon: \"no\", Marseille: \"yes\", Rome: \"yes\", Milan: \"no\", Palermo: \"yes\", Genoa: \"yes\", Berlin: \"no\", Hamburg: \"yes\", New York: \"yes\" &#125;**/ react多个倒计时1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 初始化倒计时handleTimeInit(data)&#123; data.map((item,index) =&gt; &#123; let timer = ''; if(Number(item.lost_dttm_second) &gt; 0)&#123; this.handleResetTime(timer, Number(item.lost_dttm_second),index ) &#125; &#125;) &#125;handleResetTime(timer, delay, index)&#123; const _this = this; let time = Math.floor(delay); timer = setInterval( function () &#123; let _time = --time; _this.handleFormatTime(_time,index); if(time &lt;= 0)&#123; clearInterval(timer) &#125; &#125;,1000);&#125;handleFormatTime(time,index)&#123; var hour = parseInt(time / 3600, 10); var day = parseInt(hour/24); var min = parseInt((time - (hour * 3600)) / 60, 10); // var sec = time % 60; min = min &lt; 10 ? ('0' + min) : min; hour = hour &lt; 10 ? ('0' + hour) : hour; day = day &lt; 10 ? ('0' + day) : day; // sec = sec &lt; 10 ? ('0' + sec) : sec; // 重新设置时间 const &#123; couponList &#125; = this.state; couponList[index].day = day couponList[index].hour = parseInt(hour % 24); // ！！！ couponList[index].min = min this.setState(&#123; couponList: couponList &#125;)&#125;/*** * 毫秒倒计时小技巧 -- 毫秒值跟在倒计时后面 * */ let newTime = 99;setInterval(() =&gt; &#123; const newTime2 = newTime--; if(newTime2 &lt;= 0)&#123; newTime = 99 &#125; this.setState(&#123; newTime: newTime2 &#125;)&#125;,10) 利用数组获取当前时间123456789101112131415 const showTime = () =&gt; &#123; let date = new Date();let h = date.getHours();let m = date.getMinutes(); let s = date.getSeconds(); let arrTime = [ h &lt; 10 ? 0 : parseInt( h/10 ), h % 10, m &lt; 10 ? 0 : parseInt( m/10 ), m % 10, s &lt; 10 ? 0 : parseInt( s/10 ), s % 10, ]; return arrTime; // 返回的是时间数组，例[ 1,2,0,0,0,0 ] 就是12:00:00 &#125; 处理图片出错，替换默认图片123456document.addEventListener(\"error\", function (e) &#123; let elem = e.target; if (elem.tagName.toLowerCase() === 'img') &#123; elem.src = 'https://res.youbeichefu.com/upload/head/default.png'; &#125;&#125;, true);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"小技巧","slug":"小技巧","permalink":"https://wxmac.github.io/tags/小技巧/"}]},{"title":"三、一些自己在使用css技巧","slug":"3.一些自己在使用css技巧","date":"2019-12-11T16:00:00.000Z","updated":"2020-03-12T09:51:37.255Z","comments":true,"path":"2019/12/12/3.一些自己在使用css技巧/","link":"","permalink":"https://wxmac.github.io/2019/12/12/3.一些自己在使用css技巧/","excerpt":"一、CSS – 更新中","text":"一、CSS – 更新中 省略123456789101112131415//单行省略width: 100px;white-space: nowrap;text-overflow: ellipsis;overflow: hidden;//多行省略width: 100px;height:50px;line-height: 30px;overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3; //块元素显示的文本的行数。-webkit-box-orient: vertical; ios关闭输入框内部阴影1-webkit-appearance: none; 用户设置字号放大或者缩小导致页面布局错误 – 设置字体禁止缩放123-webkit-text-size-adjust: 100% !important;text-size-adjust: 100% !important;-moz-text-size-adjust: 100% !important; 下箭头 12345width: 7px;height: 7px;border-bottom: 2px solid #bdbdbd;border-right: 2px solid #bdbdbd;transform: rotate(45deg); 实心三角123456789 width: 0; height: 0;border-width: .1rem;border-style: solid;border-color:#ccc transparent transparent transparent;position: absolute;right: -.3rem;top: 60%;transform: translateY(-50%) 更换谷歌滚动条样式：12::-webkit-scrollbar-thumb&#123;&#125; //更改谷歌滚动条样式::-webkit-scrollbar&#123;&#125; //更改谷歌滚动条背景样式 改变placeholder的颜色123::-moz-placeholder &#123; color: #CDCDCD; &#125;::-webkit-input-placeholder &#123; color:#CDCDCD; &#125;:-ms-input-placeholder &#123; color:#CDCDCD; &#125; 阴影：12345678//左box-shadow: -7px 0 5px -5px #333;//右box-shadow: 7px 0 5px -5px #333;//上box-shadow: 0px -7px 5px -5px #333;//下box-shadow: 0px 7px 5px -5px #333; 单行文字居中，多行文字居左1234.text&#123; display: flex; justify-content: center;&#125; less实现loading1234567891011121314151617181920212223242526272829303132.loader &#123; position: relative; transition: background-color .3s; pointer-events: none; &amp;:after &#123; content: ''; position: absolute; width: 20px; height: 20px; animation: loadingCircle infinite .75s linear; border: 2px solid #888; border-top-color: transparent; border-radius: 50%; z-index: 10; top: 0; bottom: 0; left: 0; right: 0; margin: auto; &#125;&#125;.hideLoader&#123; display: none;&#125;@keyframes loadingCircle &#123; 0% &#123; transform: rotate(0); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; input 功能 弹出数字键盘 1234// 有\"#\" \"*\"符号输入 &lt;input type=\"tel\" /&gt;// 纯数字 &lt;input pattern=\"\\d*\" /&gt; 调用系统的某些功能 12345678910111213// 多选 &lt;input type=\"file\" multiple /&gt;// 选择视频或者拍摄视频 &lt;input type=\"file\" accept=\"video/*\" /&gt;// 选择照片或者拍摄照片&lt;input type=\"file\" accept=\"image/*\" /&gt;// 附加// 发送邮件&lt;a href=\"mailto:839626987@qq.com\"&gt;发邮件给：13116700755@163.com&lt;/a&gt;// 发送短信 &lt;a href=\"sms:10086\"&gt;发短信给: 10086&lt;/a&gt;// 拨号&lt;a href=\"tel:10086\"&gt;打电话给: 10086&lt;/a&gt; flex布局最后一行列表左对齐的方法12345678910111213.container &#123; display: flex; justify-content: space-between; flex-wrap: wrap; .list &#123; background-color: skyblue; margin: 10px; &#125; &amp;::after &#123; content: ''; flex: auto; /* 或者flex: 1 */ &#125;&#125; 圆锥渐变1234width: 5em;height: 5em;border-radius: 50%;background: conic-gradient(red, 70%, #111 0); //圆锥渐变 障眼法：1234567891011&amp;:after&#123; content: ''; position: absolute; width: 90%; height: 90%; background: #111; border-radius: inherit; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; css波浪效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758.waveBox&#123; .wave&#123; width: 100%; height:100%; background: skyblue; margin: 2rem auto; position: relative; overflow: hidden; &amp;:after, &amp;:before&#123; content: ''; position: absolute; width: 5rem; height: 5rem; left: 50%; background: #fff; animation-name: rotate; animation-iteration-count: infinite; animation-timing-function: linear; &#125; &amp;:after&#123; top: -4.5rem; border-radius: 45%; animation-duration: 10s; &#125; &amp;:before&#123; top: -4.4rem; border-radius: 47%; opacity: .5; animation-duration: 10s; &#125; &#125; @keyframes rotate &#123; 0% &#123; transform: translate(-50%, 0) rotateZ(0deg); &#125; 50% &#123; transform: translate(-50%, -5%) rotateZ(180deg); &#125; 100% &#123; transform: translate(-50%, 0%) rotateZ(360deg); &#125; &#125;&#125;/*const height = 4;const top = height &gt; 4 ? height - 4 : 0;const res = &#123; width: '2rem', height: `$&#123;height&#125;rem`, position: 'absolute', top: `-$&#123;top&#125;rem`,&#125;*/// html&lt;div style=&#123; res &#125; className=&#123;styleCss.waveBox&#125;&gt; &lt;div className=&#123;styleCss.wave&#125;&gt;&lt;/div&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://wxmac.github.io/tags/css/"},{"name":"小技巧","slug":"小技巧","permalink":"https://wxmac.github.io/tags/小技巧/"}]},{"title":"二、vsCode终端打开问题","slug":"2.vsCode终端打开问题","date":"2019-12-08T16:00:00.000Z","updated":"2020-02-26T08:41:35.749Z","comments":true,"path":"2019/12/09/2.vsCode终端打开问题/","link":"","permalink":"https://wxmac.github.io/2019/12/09/2.vsCode终端打开问题/","excerpt":"之前打开vscode时，报 终端进程命令”/bin/bash -l”无法启动 (退出代码: 1)；","text":"之前打开vscode时，报 终端进程命令”/bin/bash -l”无法启动 (退出代码: 1)； 其他报错也可以参考一下： 有以下几个解决思路 重装vscode；（我是这个方法解决的） 因为 VSCode 工作区的文件夹有变更（删除、移动等），导致 VSCode 打开终端时，找不到此文件夹而报错； 配置下 git 路径不对，重新配置一下git；在设置里修改 “terminal.integrated.shell.windows”: “git路径base.exe”； 用管理员的权限来执行vscode，要不然它没有权限使用cmd;右击快捷键点击属性然后选择以管理员的身份运行 github解决思路","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://wxmac.github.io/tags/vscode/"}]},{"title":"一、React 多页面打包","slug":"1.react 多页面打包","date":"2019-12-05T16:00:00.000Z","updated":"2020-02-26T08:41:21.516Z","comments":true,"path":"2019/12/06/1.react 多页面打包/","link":"","permalink":"https://wxmac.github.io/2019/12/06/1.react 多页面打包/","excerpt":"缘由 之前我们用的是react单页面打包，方便是方便，开包即用。但是因为我们做的是活动页面，一般每次都只有一个页面，不仅要建大量的路由，而且资源冗杂，即使已经做了资源分割。还有做多页面最重要的原因是：单页面打包，会影响所有的页面，如果一个页面报错，那么其他的页面也无法访问。下面开始配置: 一.webpack及react版本12\"webpack\": \"^4.19.1\",\"react\": \"^16.8.3\",","text":"缘由 之前我们用的是react单页面打包，方便是方便，开包即用。但是因为我们做的是活动页面，一般每次都只有一个页面，不仅要建大量的路由，而且资源冗杂，即使已经做了资源分割。还有做多页面最重要的原因是：单页面打包，会影响所有的页面，如果一个页面报错，那么其他的页面也无法访问。下面开始配置: 一.webpack及react版本12\"webpack\": \"^4.19.1\",\"react\": \"^16.8.3\", 二.文件夹基本构造1234567891011121314151617181920212223242526272829303132333435config - path.js | - webpack.config.jspublic - index.htmlsrc - page - maintenance // 对应path.js的entriesPathFile - home - component.js | - index.js | - index.less - my - component.js | - index.js | - index.less - washstation // 对应path.js的entriesPathFile - home - component.js | - index.js | - index.less - my - component.js | - index.js | - index.lessindex.js //必不可少，可以为空 1.page下的index.js home是一个单独的页面，包括 component.js: 1234567891011121314151617class Home extends Component&#123; constructor(props)&#123; super(props) this.state = &#123; &#125; &#125; componentDidMount()&#123;&#125; render() &#123; return( &lt;div&gt; ... &lt;/div&gt; ) &#125;&#125;export default Home; index.js: 123456import 'core-js/stable';import 'babel-polyfill'import React from 'react';import ReactDOM from 'react-dom';import Home from './component';ReactDOM.render(&lt;Home /&gt;, document.getElementById('root')); index.less是页面相关的样式 2.config下的path.js12345678910111213const globby = require('globby');const entriesPathFile = 'maintenance';const entriesPath = globby.sync([resolveApp('src/page/' + entriesPathFile) + '/*/index.js']);/** 注意事项： - 1.entriesPath就是打包 maintenance 下面对应文件所有的index.js; - 2.有多个项目的话，就新建多个文件夹,如 washstation， - 3.启动项目或者打包项目只需要更改 entriesPathFile就可以了，如 const entriesPathFile = 'washstation' - 4.新建文件夹或者更换entriesPathFile必须要重新启动项目;*/ module.exports = &#123; ... entriesPath&#125; 下面这里是关键，东西有点多，配错了就没效果了：⬇️3.config下的webpack.config.js 获取指定路径下的入口文件 12345678910111213function getEntries()&#123; const entries = &#123;&#125;; const files = paths.entriesPath; files.forEach(filePath =&gt; &#123; let tmp = filePath.split('/'); let name = tmp[tmp.length - 2]; entries[name] = [ require.resolve('react-dev-utils/webpackHotDevClient'), filePath, ]; &#125;); return entries;&#125; 入口文件对象 1const entries = getEntries(); 有多少个页面就new 多少个HtmlWebpackPlugin 12345678const htmlPlugin = Object.keys(entries).map(item =&gt; &#123; return new HtmlWebpackPlugin(&#123; inject: true, template: paths.appHtml, // pulblic/index.html 公共html模板 filename: item + '/' + item + '.html', // 这里是关键,访问入口由这里决定 http://localhost:3000/home/home.html chunks: [item] &#125;);&#125;); 更换入口 12345678entry: &#123; /* devtool: isEnvProduction ? shouldUseSourceMap ? 'source-map' : false : isEnvDevelopment &amp;&amp; 'eval-source-map', entries&#125; 出口也顺便更改一下 123456789101112131415161718192021222324252627282930output:&#123; /*把对应资源放到对应页面下面,这里[name] 就是home isEnvDevelopment 对应的内容一定要配，不然本地开发只能找到一个页面 version 是时间戳 const version = +new Date();*/ filename: isEnvProduction ? '[name]/static/js/[name].[chunkhash:8].'+version+'.js' : isEnvDevelopment &amp;&amp; '[name]/static/js/bundle.js', chunkFilename: isEnvProduction ? '[name]/static/js/[name].[chunkhash:8].'+version+'.chunk.js' : isEnvDevelopment &amp;&amp; '[name]/static/js/[name].chunk.'+version+'.js',&#125;//上面是js，css也改一下，全局搜索 MiniCssExtractPluginnew MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: '[name]/static/css/[name].[contenthash:8].'+version+'.css', chunkFilename: '[name]/static/css/[name].[contenthash:8].chunk.'+version+'.css',&#125;),// 图片资源 全局搜索 .png ,图片是独立的&#123; test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/], loader: require.resolve('url-loader') , options: &#123; limit: 10000, name: 'static/media/[name].[hash:8].'+version+'.[ext]', &#125;,&#125;, 4.打包效果123456789101112131415dist - 1 // 打包出的公共的js文件 - 2 // 打包出的公共的js文件 - assets // 本地静态资源 - static //打包的静态图片资源 - media - xxxx.png - home - home.html - static - css - xxx.css - js - xxx.js xxx 如果多个页面的话，其他页面效果和home文件一样。 4.最后一点 打完包，可能会出现资源访问不到，在 package.json 配置一下homepage (1).我的是下面，根据项目路径来写： 1\"homepage\": \"../\", 顺便提一下，本地跨域，同样在 package.json 配置一下 proxy就可以了： 1\"proxy\": \"域名\", (2).打完包之后，放到服务器上，跳转访问路径也要配置的 123456789101112 //比如本地 http://localhost:3000/home/home.html;//线上:https:www.baidu.com/dist/demo/home/home.html//那么当你跳转链接的时候，就要这样：//跳转const param = window.location.href.includes('baidu') ? '/dist/demo' : '';window.location.href = param + '/home/home.html';","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"react","slug":"react","permalink":"https://wxmac.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://wxmac.github.io/tags/webpack/"}]}]}