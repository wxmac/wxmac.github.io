{"meta":{"title":"随缘笔记","subtitle":"记录自己的代码点滴 -- 九层之台，起于累土","description":"","author":"hwh","url":"https://wxmac.github.io","root":"/"},"pages":[],"posts":[{"title":"六、函数节流和防抖","slug":"函数节流和防抖","date":"2019-12-22T16:00:00.000Z","updated":"2019-12-18T07:07:05.173Z","comments":true,"path":"2019/12/23/函数节流和防抖/","link":"","permalink":"https://wxmac.github.io/2019/12/23/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/","excerpt":"","text":"1.节流核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动下一个定时器任务。 1const throttle = (fn, delay) =&gt; &#123;2 let flag = true;3 return (...args) =&gt; &#123;4 let context = this;5 if (!flag) return;6 flag = false;7 setTimeout(() =&gt; &#123;8 fn.apply(context, args);9 flag = true;10 &#125;, delay);11 &#125;;12&#125;; 2.防抖 核心思想: 每次事件触发都删除原来的定时器，建立新的定时器，反复触发函数，那么从最后一次触发开始计时。 1const debounce = (fn, delay) =&gt; &#123;2 let timer = null;3 return (...args) =&gt; &#123;4 let context = this;5 if(timer)&#123; 6 clearTimeout(timer)7 &#125;;8 timer = setTimeout(function() &#123;9 fn.apply(context, args);10 &#125;, delay);11 &#125;12&#125; 3.合并 现在我们可以把防抖和节流放到一起，有时候触发的太频繁会导致一次响应都没有，我们希望到了固定的时间必须给用户一个响应。 1const throttle = (fn, delay) =&gt; &#123;2 let flag = true, timer = null;3 return function (...args) &#123;4 let context = this;5 if( !flag )&#123; return &#125;; 6 clearTimeout(timer);7 flag = false;8 timer = setTimeout(function() &#123;9 flag = true;10 fn.apply(context, args);11 &#125;, delay);12 &#125;13&#125; 4.实践 – 图片懒加载clientHeight 、scrollTop 、 offsetTop思路： 给img一个默认图片，以及data-src属性，当页面滚动到对应img元素的时候，把data-src赋值给src。 1#给img一个默认图片2&lt;img src=\"default.png\" data-src=\"xxx/img.png\" /&gt;34#通过监听 scroll 事件来判断图片是否到达视口:5let img = document.getElementsByTagName(\"img\");6let num = img.length;7let count = 0; #计数器，从第一张图片开始计89lazyload(); #首次加载1011window.addEventListener('scroll', throttle(lazyload, 200)); #节流1213function lazyload() &#123;14 let viewHeight = document.documentElement.clientHeight;#视口高度15 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;#滚动条滚动的高度16 for(let i = count; i &lt; num; i++) &#123;17 #元素现在已经出现在视口中18 if( img[i].offsetTop &lt; scrollHeight + viewHeight ) &#123;19 if(img[i].getAttribute('src') !== 'default.png') continue; #如果src不是default.png'，跳过循环，继续往下循环20 img[i].src = img[i].getAttribute(\"data-src\");21 count ++;22 &#125;23 &#125;24&#125;25#scrollTop + clientHeight === scrollHeight 即触发下拉加载的条件","categories":[],"tags":[]},{"title":"五、js 深拷贝与浅拷贝","slug":"js 深拷贝与浅拷贝","date":"2019-12-17T16:00:00.000Z","updated":"2019-12-18T05:35:12.852Z","comments":true,"path":"2019/12/18/js 深拷贝与浅拷贝/","link":"","permalink":"https://wxmac.github.io/2019/12/18/js%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"1.基本数据类型和引用数据类型 数据分为基本数据类型和引用数据类型 基本数据类型: 1String、Number、Boolean、Null、Undefined、Symbol、BigInt(?) 引用数据类型: 1Array、Object 2.概念 浅拷贝： 1仅仅复制对象的引用，而不是对象本身 深拷贝： 1把复制的对象所引用的全部对象都复制一遍 简单来说，浅拷贝就是这个人的影子，深拷贝就是复制了这个人。 3.方法浅拷贝 1const shallowClone = (obj) =&gt; &#123;2 const result = [];3 for (let i in obj) &#123;4 if (obj.hasOwnProperty(i)) &#123;5 result[i] = obj[i];6 &#125;7 &#125;8 return result;9&#125;10#Object的 hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。 深拷贝 1const deepClone = (obj) =&gt; &#123;2 let result = Array.isArray(obj) ? [] : &#123;&#125;;3 for( let i in obj )&#123;4 if( obj.hasOwnProperty(i) )&#123;5 if( typeof obj[i] === 'object' &amp;&amp; obj[i] !== null)&#123;6 result[i] = deepClone(obj[i]) #递归复制7 &#125; else &#123;8 result[i] = obj[i]9 &#125;10 &#125;11 &#125;12 return result;13&#125;14#Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。 JSON.stringfy()和JSON.parse()会忽略undefined、function、symbol，导致属性丢失。","categories":[],"tags":[]},{"title":"四、react & html2canvas 生成图片下载实践","slug":"react & html2canvas实践","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-13T08:37:47.399Z","comments":true,"path":"2019/12/16/react & html2canvas实践/","link":"","permalink":"https://wxmac.github.io/2019/12/16/react%20&%20html2canvas%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"html2canvas的选择现在一般生成图片有前端处理和后端处理两种方式，后端生成的方案不需要前端出力，只需要拿路径渲染，但是会出现数据延时，模板更换困难等问题，出于灵活性和减少后端工作量考虑，我们采取 html2canvas 绘制页面。 html2canvas npm html2canvas 介绍 1.在react中的使用1#安装2npm install --save html2canvas3or4yarn add html2canvas56#引入7import html2canvas from 'html2canvas';89#使用10html2canvas(document.body).then(function(canvas) &#123;11 document.body.appendChild(canvas);12&#125;);1314#如果想生成一部分页面的话，html2canvas可以换成 this.refs.demo15#&lt;div ref=\"demo\"&gt;&lt;/div&gt; 上面就会把页面简单的绘制出来。 2.canvas 下载1html2canvas(this.refs.demo).then(function(canvas) &#123;2 const imgUrl = canvas.toDataURL(\"image/png\"); # 获取图片的url3 const elA = document.createElement(\"a\");4 elA.download = +new Date() + \".png\";5 elA.href = imgUrl ;6 elA.click();7 elA.remove();8&#125;);910#微信中不能下载图片，可以展示图片并提示用户长按保存图片 3.参考 参考1","categories":[],"tags":[]},{"title":"三、一些自己在使用css、js技巧","slug":"一些自己在使用css、js技巧","date":"2019-12-11T16:00:00.000Z","updated":"2019-12-13T03:36:30.778Z","comments":true,"path":"2019/12/12/一些自己在使用css、js技巧/","link":"","permalink":"https://wxmac.github.io/2019/12/12/%E4%B8%80%E4%BA%9B%E8%87%AA%E5%B7%B1%E5%9C%A8%E4%BD%BF%E7%94%A8css%E3%80%81js%E6%8A%80%E5%B7%A7/","excerpt":"","text":"CSS1.省略： 1#单行省略2width: 100px;3white-space: nowrap;4text-overflow: ellipsis;5overflow: hidden;67#多行省略8width: 100px;9height:50px;10line-height: 30px;11overflow: hidden;12text-overflow: ellipsis;13display: -webkit-box;14-webkit-line-clamp: 3; //块元素显示的文本的行数。15-webkit-box-orient: vertical; 2.下箭头 1width: 7px;2height: 7px;3border-bottom: 2px solid #bdbdbd;4border-right: 2px solid #bdbdbd;5transform: rotate(45deg); 3.更换谷歌滚动条样式： 1::-webkit-scrollbar-thumb&#123;&#125; 更改谷歌滚动条样式2::-webkit-scrollbar&#123;&#125; 更改谷歌滚动条背景样式 4.改变placeholder的颜色 1::-moz-placeholder &#123; color: #CDCDCD; &#125;2::-webkit-input-placeholder &#123; color:#CDCDCD; &#125;3:-ms-input-placeholder &#123; color:#CDCDCD; &#125; 5.阴影： 1#左2box-shadow: -7px 0 5px -5px #333;3#右4box-shadow: 7px 0 5px -5px #333;5#上6box-shadow: 0px -7px 5px -5px #333;7#下8box-shadow: 0px 7px 5px -5px #333; JS1.判断 val 是否存在 1for(let item in data)&#123;2 if(!data[item])&#123;3 data[item] = '--';4 &#125;5&#125; 2.上传图片回填 1let reads = new FileReader();2reads.readAsDataURL(files);3reads.onload = function(e) &#123;4 document.getElementById('ID').src = this.result;5&#125;; 3.获取url参数 1function getParams (name) &#123;2 let reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\");3 let r = window.location.search.substr(1).match(reg);4 if (r != null) return unescape(r[2]); return null;5&#125; 4.更改url参数 1function replaceParamVal(paramName,replaceWith) &#123;2 var oUrl = window.location.href.toString();3 var re = evil('/('+ paramName+'=)([^&amp;]*)/gi');4 var nUrl = oUrl.replace(re,paramName+'='+replaceWith);5 this.location = nUrl;6 window.location.href=nUrl7&#125;89function evil(fn) &#123;10 let Fn = Function; #一个变量指向Function，防止有些前端编译工具报错11 return new Fn('return ' + fn)();1213&#125; 5.ios window.history.back() 致使 localStorage不同步 1window.onpageshow = function(event) &#123;2 if (event.persisted) &#123;3 window.location.reload();4 &#125;5&#125; 6.判断对象是否存在 1const page = &#123;2 user:'111',3 cityInfo:&#123;4 city:'hz',5 code:'111'6 &#125;7&#125;;8const name = ( (page || &#123;&#125;).cityInfo || &#123;&#125; ).city || '111';9console.log(name) 7.textatea 高度自适应 1#jq:2el.on('input', function () &#123;3 const height = $(this).scrollTop() + $(this).prop(\"scrollHeight\") + \"px\";4 $(this).height(height)5&#125;)67#react :8const el = this.refs.remark;9el.style.height = 'auto'; 10if(el.scrollHeight &gt;=el.offsetHeight)&#123; #如果高度不够，再重新设置11 el.style.height = el.scrollHeight + 'px'12&#125; 8.查找重复字符 1let red= 'hjqjbsaxhhhh'; 2let obj = &#123;&#125;;3for (var i = 0; i&lt;red.length; i++) &#123; 4 obj[red[i]] = ++obj[red[i]] || 1 ;5 console.log(red[i]) 6&#125; 9.安卓键盘置顶按钮(安卓会出现键盘出来,按钮在下面没上来的情况) 1function handleSetBtnPosition()&#123;2 let win_h = $(window).height();3 window.addEventListener('resize', function () &#123;4 var u = navigator.userAgent;5 if (u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1) &#123; 6 if($(window).height() &lt; win_h)&#123;7 $(\"#submit_btn\").hide();8 &#125;else&#123;9 $(\"#submit_btn\").show();10 &#125;11 &#125;12 &#125;);13&#125; 10.自动添加空格 1\"13116700755\".replace(/(?&lt;=^\\d&#123;3&#125;(\\d&#123;4&#125;)*)(?!$)/g, ' ') ---&gt; \"131 1670 0755\" 11.将具有相同属性的对象合并到一个数组中 1let data = [2 &#123;3 'group_name':'A',4 'type': 'apple'5 &#125;,6 &#123;7 'group_name':'A',8 'type': 'almond'9 &#125;,10 &#123;11 'group_name':'B',12 'type': 'banana'13 &#125;,14 &#123;15 'group_name':'B',16 'type': 'bennet'17 &#125;18];1920const res = data.reduce( (prv, &#123; group_name, type &#125; ) =&gt; &#123;21 const exist = prv.find(item =&gt; item.group_name == group_name);22 if (exist) &#123;23 exist[\"data\"].push(&#123;24 group_name:group_name,25 type:type26 &#125;);27 &#125; else &#123;28 prv.push(&#123; group_name, data: [&#123;29 group_name:group_name,30 type:type31 &#125;]&#125;)32 &#125;33 return prv;34&#125;, []);3536console.log(res)3738# 打印结果如下：39[40 &#123; 41 'group_name':A,42 data:[43 &#123;44 'group_name':'A',45 'type': 'apple'46 &#125;,47 &#123;48 'group_name':'A',49 'type': 'almond'50 &#125;,51 ]52 &#125;,53 &#123; 54 'group_name':B,55 data:[56 &#123;57 'group_name':'B',58 'type': 'banana'59 &#125;,60 &#123;61 'group_name':'B',62 'type': 'bennet'63 &#125;64 ]65 &#125;66]","categories":[],"tags":[]},{"title":"二、vsCode终端打开问题","slug":"vsCode终端打开问题","date":"2019-12-08T16:00:00.000Z","updated":"2019-12-09T06:05:29.932Z","comments":true,"path":"2019/12/09/vsCode终端打开问题/","link":"","permalink":"https://wxmac.github.io/2019/12/09/vsCode%E7%BB%88%E7%AB%AF%E6%89%93%E5%BC%80%E9%97%AE%E9%A2%98/","excerpt":"","text":"之前打开vscode时，报 终端进程命令”/bin/bash -l”无法启动 (退出代码: 1)； 其他报错也可以参考一下： 有以下几个解决思路1.重装vscode；（我是这个方法解决的） 2.因为 VSCode 工作区的文件夹有变更（删除、移动等），导致 VSCode 打开终端时，找不到此文件夹而报错； 3.配置下 git 路径不对，重新配置一下git；在设置里修改 “terminal.integrated.shell.windows”: “git路径base.exe”； 4.用管理员的权限来执行vscode，要不然它没有权限使用cmd;右击快捷键点击属性然后选择以管理员的身份运行 github解决思路","categories":[],"tags":[]},{"title":"一、React 多页面打包","slug":"react 多页面打包","date":"2019-12-05T16:00:00.000Z","updated":"2019-12-09T02:40:21.830Z","comments":true,"path":"2019/12/06/react 多页面打包/","link":"","permalink":"https://wxmac.github.io/2019/12/06/react%20%E5%A4%9A%E9%A1%B5%E9%9D%A2%E6%89%93%E5%8C%85/","excerpt":"","text":"缘由之前我们用的是react单页面打包，方便是方便，开包即用。但是因为我们做的是活动页面，一般每次都只有一个页面，不仅要建大量的路由，而且资源冗杂，即使已经做了资源分割。还有做多页面最重要的原因是：单页面打包，会影响所有的页面，如果一个页面报错，那么其他的页面也无法访问。下面开始配置: 一.webpack及react版本1\"webpack\": \"^4.19.1\",2\"react\": \"^16.8.3\", 二.文件夹基本构造1config 2 - path.js3 - webpack.config.js4public 5 - index.html6src 7 - page 8 - home 9 - component.js10 - index.js 11 - index.less12index.js #必不可少，可以为空 1.page下的index.jshome是一个单独的页面，包括 component.js: 1class Home extends Component&#123;2 constructor(props)&#123;3 super(props)4 this.state = &#123;5 6 &#125;7 &#125;8 componentDidMount()&#123;&#125;9 render() &#123;10 return(11 &lt;div&gt;12 # ...13 &lt;/div&gt;14 )15 &#125;16&#125;17export default Home; index.js: 1import 'babel-polyfill'2import React from 'react';3import ReactDOM from 'react-dom';4import Home from './component';5ReactDOM.render(&lt;Home /&gt;, document.getElementById('root')); index.less是页面相关的样式 2.config下的path.js1# 获取page/*/下的所有index2const globby = require('globby');3const entriesPath = globby.sync([resolveApp('src/page') + '/*/index.js']);4module.exports = &#123;5 ...6 entriesPath7&#125; 下面这里是关键，东西有点多，配错了就没效果了：⬇️ 3.config下的webpack.config.js1# 获取指定路径下的入口文件2function getEntries()&#123;3 const entries = &#123;&#125;;4 const files = paths.entriesPath;5 files.forEach(filePath =&gt; &#123;6 let tmp = filePath.split('/');7 let name = tmp[tmp.length - 2];8 entries[name] = [9 require.resolve('react-dev-utils/webpackHotDevClient'),10 filePath,11 ];12 &#125;);13 return entries;14&#125;1516# 入口文件对象17const entries = getEntries();1819# 有多少个页面就new 多少个HtmlWebpackPlugin20const htmlPlugin = Object.keys(entries).map(item =&gt; &#123;21 return new HtmlWebpackPlugin(&#123;22 inject: true,23 template: paths.appHtml, # pulblic/index.html 公共html模板24 filename: item + '/' + item + '.html', # 这里是关键,访问入口由这里决定 http://localhost:3000/home/home.html25 chunks: [item]26 &#125;);27&#125;);282930#更换入口31entry: &#123;32 # devtool: isEnvProduction33 # ? shouldUseSourceMap34 # ? 'source-map'35 # : false36 # : isEnvDevelopment &amp;&amp; 'eval-source-map',37 entries38&#125;394041# 出口也顺便更改一下42output:&#123;43 #把对应资源放到对应页面下面,这里[name] 就是home44 #isEnvDevelopment 对应的内容一定要配，不然本地开发只能找到一个页面45 #version 是时间戳 const version = +new Date();46 filename: isEnvProduction47 ? '[name]/static/js/[name].[chunkhash:8].'+version+'.js'48 : isEnvDevelopment &amp;&amp; '[name]/static/js/bundle.js',4950 chunkFilename: isEnvProduction51 ? '[name]/static/js/[name].[chunkhash:8].'+version+'.chunk.js'52 : isEnvDevelopment &amp;&amp; '[name]/static/js/[name].chunk.'+version+'.js',53&#125;5455#上面是js，css也改一下，全局搜索 MiniCssExtractPlugin56new MiniCssExtractPlugin(&#123;57 // Options similar to the same options in webpackOptions.output58 // both options are optional59 filename: '[name]/static/css/[name].[contenthash:8].'+version+'.css',60 chunkFilename: '[name]/static/css/[name].[contenthash:8].chunk.'+version+'.css',61&#125;),6263# 图片资源 全局搜索 .png ,图片是独立的64&#123;65 test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/],66 loader: require.resolve('url-loader') ,67 options: &#123;68 limit: 10000,69 name: 'static/media/[name].[hash:8].'+version+'.[ext]',70 &#125;,71&#125;, 4.打包效果1dist2 - 1 # 打包出的公共的js文件3 - 2 # 打包出的公共的js文件4 - assets #本地静态资源5 - static #打包的静态图片资源6 - media7 - xxxx.png8 - home9 - home.html10 - static11 - css12 - xxx.css13 - js14 - xxx.js15 xxx 如果多个页面的话，其他页面效果和home文件一样。 4.最后一点打完包，可能会出现资源访问不到，在 package.json 配置一下homepage (1).我的是下面，根据项目路径来写： 1\"homepage\": \"../\", 顺便提一下，本地跨域，同样在 package.json 配置一下 proxy就可以了： 1\"proxy\": \"域名\", 打完包之后，放到服务器上，跳转访问路径也要配置的 1#比如本地 2http://localhost:3000/home/home.html;34#线上:5https:www.baidu.com/dist/demo/home/home.html67#那么当你跳转链接的时候，就要这样：89#跳转10const param = window.location.href.includes('baidu') ? '/dist/demo' : '';11window.location.href = param + '/home/home.html';","categories":[],"tags":[]}]}