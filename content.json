{"meta":{"title":"wxmac的前端笔记","subtitle":"记录自己的代码点滴 -- 九层之台，起于累土","description":"","author":"hwh","url":"https://wxmac.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-19T02:14:29.205Z","updated":"2019-12-19T02:14:29.204Z","comments":true,"path":"404.html","permalink":"https://wxmac.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"所有标签","date":"2019-12-19T02:08:57.392Z","updated":"2019-12-19T02:08:57.392Z","comments":true,"path":"tags/index.html","permalink":"https://wxmac.github.io/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-12-19T02:12:02.734Z","updated":"2019-12-19T02:12:02.734Z","comments":true,"path":"categories/index.html","permalink":"https://wxmac.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"九、将具有相同属性的对象合并到一个数组中","slug":"属性合并","date":"2019-12-31T16:00:00.000Z","updated":"2019-12-24T09:24:54.279Z","comments":true,"path":"2020/01/01/属性合并/","link":"","permalink":"https://wxmac.github.io/2020/01/01/属性合并/","excerpt":"将具有相同属性的对象合并到一个数组中","text":"将具有相同属性的对象合并到一个数组中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667let data = [ &#123; 'group_name':'A', 'type': 'apple' &#125;, &#123; 'group_name':'A', 'type': 'almond' &#125;, &#123; 'group_name':'B', 'type': 'banana' &#125;, &#123; 'group_name':'B', 'type': 'bennet' &#125;];//代码实现const res = data.reduce( (prv, &#123; group_name, type &#125; ) =&gt; &#123; const exist = prv.find(item =&gt; item.group_name == group_name); if (exist) &#123; exist[\"data\"].push(&#123; group_name:group_name, type:type &#125;); &#125; else &#123; prv.push(&#123; group_name, data: [&#123; group_name:group_name, type:type &#125;]&#125;) &#125; return prv;&#125;, []);console.log(res)// 打印结果如下：[ &#123; 'group_name':A, data:[ &#123; 'group_name':'A', 'type': 'apple' &#125;, &#123; 'group_name':'A', 'type': 'almond' &#125;, ] &#125;, &#123; 'group_name':B, data:[ &#123; 'group_name':'B', 'type': 'banana' &#125;, &#123; 'group_name':'B', 'type': 'bennet' &#125; ] &#125;]","categories":[],"tags":[{"name":"reduce","slug":"reduce","permalink":"https://wxmac.github.io/tags/reduce/"},{"name":"数组","slug":"数组","permalink":"https://wxmac.github.io/tags/数组/"}]},{"title":"八、扁平化数组","slug":"扁平化数组","date":"2019-12-29T16:00:00.000Z","updated":"2019-12-24T08:12:47.016Z","comments":true,"path":"2019/12/30/扁平化数组/","link":"","permalink":"https://wxmac.github.io/2019/12/30/扁平化数组/","excerpt":"一：Array.prototype.flat()","text":"一：Array.prototype.flat() 12345678910111213141516171819202122const arr = [1,2,3,[4,5,6,[7,8]],9,10];// 不传参数时，默认“拉平”一层arr.flat();// // [1, 2, 3, 4, 5, 6, [7,8], 9, 10]// 传入一个整数参数，整数即“拉平”的层数arr.flat(2);// // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// Infinity 关键字作为参数时，无论多少层嵌套，都会转为一维数组// Infinity(无穷大)在 JS 中是一个特殊的数字，它的特性是：它比任何有限的数字都大。arr.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// 传入 &lt;=0 的整数将返回原数组，不“拉平”arr.flat(0);arr.flat(-10); // [1,2,3,[4,5,6,[7,8]],9,10]//如果原数组有空位，flat()方法会过滤空位[1,2,3,,].flat()// [1, 2, 3] 二：其他方法实现1.reduce12345const flat = (arr) =&gt; &#123; return arr.reduce((prv,cur) =&gt; &#123; return Array.isArray(cur) ? prv.concat(flat(cur)) : prv.concat(cur) &#125;,[])&#125; 2.使用栈的思想实现 flat 函数12345678910111213const flat = (arr) =&gt; &#123; const stack = [...arr]; const res = []; while( stack.length )&#123; const next = stack.pop(); if(Array.isArray(next))&#123; stack.push(...next); &#125; else &#123; res.push(next) &#125; &#125; return res.reverse();&#125; 3.通过传入整数参数控制“拉平”层数 123456789const flat = (arr, num = 1) =&gt; &#123; return num &gt; 0 ? arr.reduce( (pre, cur) =&gt; pre.concat(Array.isArray(cur) ? flat(cur, num - 1) : cur),[]) : arr.slice()&#125;#const arr = [1,2,3,[1,2,3,4, [2,3,4]]];#flat(arr,Infinity) MDN参考链接 其他参考","categories":[],"tags":[{"name":"flat","slug":"flat","permalink":"https://wxmac.github.io/tags/flat/"},{"name":"扁平化数组","slug":"扁平化数组","permalink":"https://wxmac.github.io/tags/扁平化数组/"}]},{"title":"七、不刷新修改url链接","slug":"不刷新修改url链接","date":"2019-12-24T16:00:00.000Z","updated":"2019-12-24T08:14:46.888Z","comments":true,"path":"2019/12/25/不刷新修改url链接/","link":"","permalink":"https://wxmac.github.io/2019/12/25/不刷新修改url链接/","excerpt":"有一个这样的需求，点击分页，不刷新页面。 123//我们的page参数是记录在url里的： https://xxx.html?page=1//如果采取硬拼接的方式，无疑会刷新页面window.location.href = window.location.pathname + `?page=$&#123;page&#125;`","text":"有一个这样的需求，点击分页，不刷新页面。 123//我们的page参数是记录在url里的： https://xxx.html?page=1//如果采取硬拼接的方式，无疑会刷新页面window.location.href = window.location.pathname + `?page=$&#123;page&#125;` 1.pushState() 方法MDN链接一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL. 让我们来解释下这三个参数详细内容：： 123- 状态对象 — 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本- 标题 — Firefox 目前忽略这个参数，但未来可能会用到。在此处传一个空字符串应该可以安全的防范未来这个方法的更改。或者，你可以为跳转的state传递一个短标题- URL — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL 2.pushState使用123const pageSize = 2;const url = `$&#123;window.location.pathname&#125;?page=$&#123;pageSize&#125;`window.history.pushState(&#123;url: url&#125;, '', url); 以上就能实现页面无刷新修改url链接。 顺便放上获取和修改url的函数： 3.获取和修改url的函数：获取url参数12345function getParams (name) &#123; let reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); let r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 更改url参数123456789101112function replaceParamVal(paramName,replaceWith) &#123; var oUrl = window.location.href.toString(); var re = evil('/('+ paramName+'=)([^&amp;]*)/gi'); var nUrl = oUrl.replace(re,paramName+'='+replaceWith); this.location = nUrl; window.location.href=nUrl&#125;function evil(fn) &#123; let Fn = Function; //一个变量指向Function，防止有些前端编译工具报错 return new Fn('return ' + fn)();&#125;","categories":[],"tags":[{"name":"pushState","slug":"pushState","permalink":"https://wxmac.github.io/tags/pushState/"},{"name":"url","slug":"url","permalink":"https://wxmac.github.io/tags/url/"}]},{"title":"六、函数节流和防抖","slug":"函数节流和防抖","date":"2019-12-22T16:00:00.000Z","updated":"2019-12-24T08:13:02.792Z","comments":true,"path":"2019/12/23/函数节流和防抖/","link":"","permalink":"https://wxmac.github.io/2019/12/23/函数节流和防抖/","excerpt":"1.节流核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动下一个定时器任务。","text":"1.节流核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动下一个定时器任务。 123456789101112const throttle = (fn, delay) =&gt; &#123; let flag = true; return (...args) =&gt; &#123; let context = this; if (!flag) return; flag = false; setTimeout(() =&gt; &#123; fn.apply(context, args); flag = true; &#125;, delay); &#125;;&#125;; 2.防抖 核心思想: 每次事件触发都删除原来的定时器，建立新的定时器，反复触发函数，那么从最后一次触发开始计时。 123456789101112const debounce = (fn, delay) =&gt; &#123; let timer = null; return (...args) =&gt; &#123; let context = this; if(timer)&#123; clearTimeout(timer) &#125;; timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125;&#125; 3.合并 现在我们可以把防抖和节流放到一起，有时候触发的太频繁会导致一次响应都没有，我们希望到了固定的时间必须给用户一个响应。 12345678910111213const throttle = (fn, delay) =&gt; &#123; let flag = true, timer = null; return function (...args) &#123; let context = this; if( !flag )&#123; return &#125;; clearTimeout(timer); flag = false; timer = setTimeout(function() &#123; flag = true; fn.apply(context, args); &#125;, delay); &#125;&#125; 4.实践 – 图片懒加载clientHeight 、scrollTop 、 offsetTop思路： 给img一个默认图片，以及data-src属性，当页面滚动到对应img元素的时候，把data-src赋值给src。 12345678910111213141516171819202122232425//给img一个默认图片&lt;img src=\"default.png\" data-src=\"xxx/img.png\" /&gt;//通过监听 scroll 事件来判断图片是否到达视口:let img = document.getElementsByTagName(\"img\");let num = img.length;let count = 0; #计数器，从第一张图片开始计lazyload(); #首次加载window.addEventListener('scroll', throttle(lazyload, 200)); //节流function lazyload() &#123; let viewHeight = document.documentElement.clientHeight;#视口高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;#滚动条滚动的高度 for(let i = count; i &lt; num; i++) &#123; //元素现在已经出现在视口中 if( img[i].offsetTop &lt; scrollHeight + viewHeight ) &#123; if(img[i].getAttribute('src') !== 'default.png') continue; #如果src不是default.png'，跳过循环，继续往下循环 img[i].src = img[i].getAttribute(\"data-src\"); count ++; &#125; &#125;&#125;//scrollTop + clientHeight === scrollHeight 即触发下拉加载的条件","categories":[],"tags":[{"name":"函数","slug":"函数","permalink":"https://wxmac.github.io/tags/函数/"},{"name":"节流/防抖","slug":"节流-防抖","permalink":"https://wxmac.github.io/tags/节流-防抖/"}]},{"title":"五、js 深拷贝与浅拷贝","slug":"js 深拷贝与浅拷贝","date":"2019-12-17T16:00:00.000Z","updated":"2019-12-24T08:13:16.031Z","comments":true,"path":"2019/12/18/js 深拷贝与浅拷贝/","link":"","permalink":"https://wxmac.github.io/2019/12/18/js 深拷贝与浅拷贝/","excerpt":"1.基本数据类型和引用数据类型 数据分为基本数据类型和引用数据类型 基本数据类型: 1String、Number、Boolean、Null、Undefined、Symbol、BigInt(?) 引用数据类型: 1Array、Object","text":"1.基本数据类型和引用数据类型 数据分为基本数据类型和引用数据类型 基本数据类型: 1String、Number、Boolean、Null、Undefined、Symbol、BigInt(?) 引用数据类型: 1Array、Object 2.概念 浅拷贝： 1仅仅复制对象的引用，而不是对象本身 深拷贝： 1把复制的对象所引用的全部对象都复制一遍 简单来说，浅拷贝就是这个人的影子，深拷贝就是复制了这个人。 3.方法浅拷贝 123456789101112131415const shallowClone = (obj) =&gt; &#123; const result = []; for (let i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; result[i] = obj[i]; &#125; &#125; return result;&#125;//Object的 hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。hasOwnProperty()方法来忽略继承属性.//object.assign() 把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象//Array.prototype.concat() 数组的一个内置方法，用户合并两个或者多个数组，不会改变现有数组，而是返回一个新数组//Array.prototype.slice() 数组的一个内置方法，该方法会返回一个新的对象，不会改变原数组 //obj展开运算符 [...]//以上几种方式也可以 深拷贝 1234567891011121314const deepClone = (obj) =&gt; &#123; let result = Array.isArray(obj) ? [] : &#123;&#125;; for( let i in obj )&#123; if( obj.hasOwnProperty(i) )&#123; if( typeof obj[i] === 'object' &amp;&amp; obj[i] !== null)&#123; result[i] = deepClone(obj[i]) #递归复制 &#125; else &#123; result[i] = obj[i] &#125; &#125; &#125; return result;&#125;//Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。hasOwnProperty()方法来忽略继承属性 JSON.stringfy()和JSON.parse()会忽略undefined、function、symbol，导致属性丢失。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"小技巧","slug":"小技巧","permalink":"https://wxmac.github.io/tags/小技巧/"},{"name":"拷贝","slug":"拷贝","permalink":"https://wxmac.github.io/tags/拷贝/"}]},{"title":"四、react & html2canvas 生成图片下载实践","slug":"react & html2canvas实践","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-24T07:56:57.455Z","comments":true,"path":"2019/12/16/react & html2canvas实践/","link":"","permalink":"https://wxmac.github.io/2019/12/16/react & html2canvas实践/","excerpt":"html2canvas的选择现在一般生成图片有前端处理和后端处理两种方式，后端生成的方案不需要前端出力，只需要拿路径渲染，但是会出现数据延时，模板更换困难等问题，出于灵活性和减少后端工作量考虑，我们采取 html2canvas 绘制页面。 html2canvas npm html2canvas 介绍","text":"html2canvas的选择现在一般生成图片有前端处理和后端处理两种方式，后端生成的方案不需要前端出力，只需要拿路径渲染，但是会出现数据延时，模板更换困难等问题，出于灵活性和减少后端工作量考虑，我们采取 html2canvas 绘制页面。 html2canvas npm html2canvas 介绍 1.在react中的使用123456789101112131415//安装npm install --save html2canvasoryarn add html2canvas//引入import html2canvas from 'html2canvas';//使用html2canvas(document.body).then(function(canvas) &#123; document.body.appendChild(canvas);&#125;);//如果想生成一部分页面的话，html2canvas可以换成 this.refs.demo//&lt;div ref=\"demo\"&gt;&lt;/div&gt; 上面就会把页面简单的绘制出来。 2.canvas 下载12345678910html2canvas(this.refs.demo).then(function(canvas) &#123; const imgUrl = canvas.toDataURL(\"image/png\"); # 获取图片的url const elA = document.createElement(\"a\"); elA.download = +new Date() + \".png\"; elA.href = imgUrl ; elA.click(); elA.remove();&#125;);//微信中不能下载图片，可以展示图片并提示用户长按保存图片 3.参考 参考1","categories":[],"tags":[{"name":"html2canvas","slug":"html2canvas","permalink":"https://wxmac.github.io/tags/html2canvas/"},{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"react","slug":"react","permalink":"https://wxmac.github.io/tags/react/"}]},{"title":"三、一些自己在使用css、js技巧","slug":"一些自己在使用css、js技巧","date":"2019-12-11T16:00:00.000Z","updated":"2019-12-24T07:58:06.643Z","comments":true,"path":"2019/12/12/一些自己在使用css、js技巧/","link":"","permalink":"https://wxmac.github.io/2019/12/12/一些自己在使用css、js技巧/","excerpt":"CSS","text":"CSS 1.省略： 123456789101112131415//单行省略width: 100px;white-space: nowrap;text-overflow: ellipsis;overflow: hidden;//多行省略width: 100px;height:50px;line-height: 30px;overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3; //块元素显示的文本的行数。-webkit-box-orient: vertical; 2.下箭头 12345width: 7px;height: 7px;border-bottom: 2px solid #bdbdbd;border-right: 2px solid #bdbdbd;transform: rotate(45deg); 3.更换谷歌滚动条样式： 12::-webkit-scrollbar-thumb&#123;&#125; //更改谷歌滚动条样式::-webkit-scrollbar&#123;&#125; //更改谷歌滚动条背景样式 4.改变placeholder的颜色 123::-moz-placeholder &#123; color: #CDCDCD; &#125;::-webkit-input-placeholder &#123; color:#CDCDCD; &#125;:-ms-input-placeholder &#123; color:#CDCDCD; &#125; 5.阴影： 12345678//左box-shadow: -7px 0 5px -5px #333;//右box-shadow: 7px 0 5px -5px #333;//上box-shadow: 0px -7px 5px -5px #333;//下box-shadow: 0px 7px 5px -5px #333; JS1.判断 val 是否存在 12345for(let item in data)&#123; if(!data[item])&#123; data[item] = '--'; &#125;&#125; 2.上传图片回填 12345let reads = new FileReader();reads.readAsDataURL(files);reads.onload = function(e) &#123; document.getElementById('ID').src = this.result;&#125;; 3.获取url参数 12345function getParams (name) &#123; let reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); let r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 4.更改url参数 12345678910111213function replaceParamVal(paramName,replaceWith) &#123; var oUrl = window.location.href.toString(); var re = evil('/('+ paramName+'=)([^&amp;]*)/gi'); var nUrl = oUrl.replace(re,paramName+'='+replaceWith); this.location = nUrl; window.location.href=nUrl&#125;function evil(fn) &#123; let Fn = Function; //一个变量指向Function，防止有些前端编译工具报错 return new Fn('return ' + fn)();&#125; 5.ios window.history.back() 致使 localStorage不同步 12345window.onpageshow = function(event) &#123; if (event.persisted) &#123; window.location.reload(); &#125;&#125; 6.判断对象是否存在 123456789const page = &#123; user:'111', cityInfo:&#123; city:'hz', code:'111' &#125;&#125;;const name = ( (page || &#123;&#125;).cityInfo || &#123;&#125; ).city || '111';console.log(name) 7.textatea 高度自适应 123456789101112//jq:el.on('input', function () &#123; const height = $(this).scrollTop() + $(this).prop(\"scrollHeight\") + \"px\"; $(this).height(height)&#125;)//react :const el = this.refs.remark;el.style.height = 'auto'; if(el.scrollHeight &gt;=el.offsetHeight)&#123; #如果高度不够，再重新设置 el.style.height = el.scrollHeight + 'px'&#125; 8.查找重复字符 123456let red= 'hjqjbsaxhhhh'; let obj = &#123;&#125;;for (var i = 0; i&lt;red.length; i++) &#123; obj[red[i]] = ++obj[red[i]] || 1 ; console.log(red[i]) &#125; 9.安卓键盘置顶按钮(安卓会出现键盘出来,按钮在下面没上来的情况) 12345678910111213function handleSetBtnPosition()&#123; let win_h = $(window).height(); window.addEventListener('resize', function () &#123; var u = navigator.userAgent; if (u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1) &#123; if($(window).height() &lt; win_h)&#123; $(\"#submit_btn\").hide(); &#125;else&#123; $(\"#submit_btn\").show(); &#125; &#125; &#125;);&#125; 10.自动添加空格 1\"13116700755\".replace(/(?&lt;=^\\d&#123;3&#125;(\\d&#123;4&#125;)*)(?!$)/g, ' ') ---&gt; \"131 1670 0755\"","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://wxmac.github.io/tags/css/"},{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"小技巧","slug":"小技巧","permalink":"https://wxmac.github.io/tags/小技巧/"}]},{"title":"二、vsCode终端打开问题","slug":"vsCode终端打开问题","date":"2019-12-08T16:00:00.000Z","updated":"2019-12-19T02:16:45.819Z","comments":true,"path":"2019/12/09/vsCode终端打开问题/","link":"","permalink":"https://wxmac.github.io/2019/12/09/vsCode终端打开问题/","excerpt":"之前打开vscode时，报 终端进程命令”/bin/bash -l”无法启动 (退出代码: 1)；","text":"之前打开vscode时，报 终端进程命令”/bin/bash -l”无法启动 (退出代码: 1)； 其他报错也可以参考一下： 有以下几个解决思路1.重装vscode；（我是这个方法解决的） 2.因为 VSCode 工作区的文件夹有变更（删除、移动等），导致 VSCode 打开终端时，找不到此文件夹而报错； 3.配置下 git 路径不对，重新配置一下git；在设置里修改 “terminal.integrated.shell.windows”: “git路径base.exe”； 4.用管理员的权限来执行vscode，要不然它没有权限使用cmd;右击快捷键点击属性然后选择以管理员的身份运行 github解决思路","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://wxmac.github.io/tags/vscode/"}]},{"title":"一、React 多页面打包","slug":"react 多页面打包","date":"2019-12-05T16:00:00.000Z","updated":"2019-12-24T08:11:24.294Z","comments":true,"path":"2019/12/06/react 多页面打包/","link":"","permalink":"https://wxmac.github.io/2019/12/06/react 多页面打包/","excerpt":"缘由之前我们用的是react单页面打包，方便是方便，开包即用。但是因为我们做的是活动页面，一般每次都只有一个页面，不仅要建大量的路由，而且资源冗杂，即使已经做了资源分割。还有做多页面最重要的原因是：单页面打包，会影响所有的页面，如果一个页面报错，那么其他的页面也无法访问。下面开始配置: 一.webpack及react版本12\"webpack\": \"^4.19.1\",\"react\": \"^16.8.3\",","text":"缘由之前我们用的是react单页面打包，方便是方便，开包即用。但是因为我们做的是活动页面，一般每次都只有一个页面，不仅要建大量的路由，而且资源冗杂，即使已经做了资源分割。还有做多页面最重要的原因是：单页面打包，会影响所有的页面，如果一个页面报错，那么其他的页面也无法访问。下面开始配置: 一.webpack及react版本12\"webpack\": \"^4.19.1\",\"react\": \"^16.8.3\", 二.文件夹基本构造123456789101112config - path.js - webpack.config.jspublic - index.htmlsrc - page - home - component.js - index.js - index.lessindex.js //必不可少，可以为空 1.page下的index.jshome是一个单独的页面，包括 component.js: 1234567891011121314151617class Home extends Component&#123; constructor(props)&#123; super(props) this.state = &#123; &#125; &#125; componentDidMount()&#123;&#125; render() &#123; return( &lt;div&gt; # ... &lt;/div&gt; ) &#125;&#125;export default Home; index.js: 12345import 'babel-polyfill'import React from 'react';import ReactDOM from 'react-dom';import Home from './component';ReactDOM.render(&lt;Home /&gt;, document.getElementById('root')); index.less是页面相关的样式 2.config下的path.js1234567// 获取page/*/下的所有indexconst globby = require('globby');const entriesPath = globby.sync([resolveApp('src/page') + '/*/index.js']);module.exports = &#123; ... entriesPath&#125; 下面这里是关键，东西有点多，配错了就没效果了：⬇️ 3.config下的webpack.config.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 获取指定路径下的入口文件function getEntries()&#123; const entries = &#123;&#125;; const files = paths.entriesPath; files.forEach(filePath =&gt; &#123; let tmp = filePath.split('/'); let name = tmp[tmp.length - 2]; entries[name] = [ require.resolve('react-dev-utils/webpackHotDevClient'), filePath, ]; &#125;); return entries;&#125;// 入口文件对象const entries = getEntries();// 有多少个页面就new 多少个HtmlWebpackPluginconst htmlPlugin = Object.keys(entries).map(item =&gt; &#123; return new HtmlWebpackPlugin(&#123; inject: true, template: paths.appHtml, # pulblic/index.html 公共html模板 filename: item + '/' + item + '.html', # 这里是关键,访问入口由这里决定 http://localhost:3000/home/home.html chunks: [item] &#125;);&#125;);//更换入口entry: &#123; # devtool: isEnvProduction # ? shouldUseSourceMap # ? 'source-map' # : false # : isEnvDevelopment &amp;&amp; 'eval-source-map', entries&#125;// 出口也顺便更改一下output:&#123; #把对应资源放到对应页面下面,这里[name] 就是home #isEnvDevelopment 对应的内容一定要配，不然本地开发只能找到一个页面 #version 是时间戳 const version = +new Date(); filename: isEnvProduction ? '[name]/static/js/[name].[chunkhash:8].'+version+'.js' : isEnvDevelopment &amp;&amp; '[name]/static/js/bundle.js', chunkFilename: isEnvProduction ? '[name]/static/js/[name].[chunkhash:8].'+version+'.chunk.js' : isEnvDevelopment &amp;&amp; '[name]/static/js/[name].chunk.'+version+'.js',&#125;//上面是js，css也改一下，全局搜索 MiniCssExtractPluginnew MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: '[name]/static/css/[name].[contenthash:8].'+version+'.css', chunkFilename: '[name]/static/css/[name].[contenthash:8].chunk.'+version+'.css',&#125;),// 图片资源 全局搜索 .png ,图片是独立的&#123; test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/], loader: require.resolve('url-loader') , options: &#123; limit: 10000, name: 'static/media/[name].[hash:8].'+version+'.[ext]', &#125;,&#125;, 4.打包效果123456789101112131415dist - 1 // 打包出的公共的js文件 - 2 // 打包出的公共的js文件 - assets #本地静态资源 - static #打包的静态图片资源 - media - xxxx.png - home - home.html - static - css - xxx.css - js - xxx.js xxx 如果多个页面的话，其他页面效果和home文件一样。 4.最后一点打完包，可能会出现资源访问不到，在 package.json 配置一下homepage (1).我的是下面，根据项目路径来写： 1\"homepage\": \"../\", 顺便提一下，本地跨域，同样在 package.json 配置一下 proxy就可以了： 1\"proxy\": \"域名\", 打完包之后，放到服务器上，跳转访问路径也要配置的 123456789101112 //比如本地 http://localhost:3000/home/home.html;//线上:https:www.baidu.com/dist/demo/home/home.html//那么当你跳转链接的时候，就要这样：//跳转const param = window.location.href.includes('baidu') ? '/dist/demo' : '';window.location.href = param + '/home/home.html';","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"react","slug":"react","permalink":"https://wxmac.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://wxmac.github.io/tags/webpack/"}]}]}