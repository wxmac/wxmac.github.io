{"meta":{"title":"wxmac的前端笔记","subtitle":"记录自己的代码点滴 -- 九层之台，起于累土","description":"","author":"wxmac","url":"https://wxmac.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-19T02:14:29.205Z","updated":"2019-12-19T02:14:29.204Z","comments":true,"path":"404.html","permalink":"https://wxmac.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"所有标签","date":"2019-12-19T02:08:57.392Z","updated":"2019-12-19T02:08:57.392Z","comments":true,"path":"tags/index.html","permalink":"https://wxmac.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-01-07T03:35:06.484Z","updated":"2020-01-07T03:35:06.484Z","comments":true,"path":"js/love.js","permalink":"https://wxmac.github.io/js/love.js","excerpt":"","text":"!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e"},{"title":"","date":"2019-12-24T09:33:53.764Z","updated":"2019-12-24T09:33:53.762Z","comments":true,"path":"js/jquery.js","permalink":"https://wxmac.github.io/js/jquery.js","excerpt":"","text":"/*! jQuery v3.3.1 | (c) JS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(e,t){\"use strict\";var n=[],r=e.document,i=Object.getPrototypeOf,o=n.slice,a=n.concat,s=n.push,u=n.indexOf,l={},c=l.toString,f=l.hasOwnProperty,p=f.toString,d=p.call(Object),h={},g=function e(t){return\"function\"==typeof t&&\"number\"!=typeof t.nodeType},y=function e(t){return null!=t&&t===t.window},v={type:!0,src:!0,noModule:!0};function m(e,t,n){var i,o=(t=t||r).createElement(\"script\");if(o.text=e,n)for(i in v)n[i]&&(o[i]=n[i]);t.head.appendChild(o).parentNode.removeChild(o)}function x(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?l[c.call(e)]||\"object\":typeof e}var b=\"3.3.1\",w=function(e,t){return new w.fn.init(e,t)},T=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;w.fn=w.prototype={jquery:\"3.3.1\",constructor:w,length:0,toArray:function(){return o.call(this)},get:function(e){return null==e?o.call(this):e=0&&n10|55296,1023&r|56320)},te=/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,ne=function(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e},re=function(){p()},ie=me(function(e){return!0===e.disabled&&(\"form\"in e||\"label\"in e)},{dir:\"parentNode\",next:\"legend\"});try{L.apply(A=H.call(w.childNodes),w.childNodes),A[w.childNodes.length].nodeType}catch(e){L={apply:A.length?function(e,t){q.apply(e,H.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function oe(e,t,r,i){var o,s,l,c,f,h,v,m=t&&t.ownerDocument,T=t?t.nodeType:9;if(r=r||[],\"string\"!=typeof e||!e||1!==T&&9!==T&&11!==T)return r;if(!i&&((t?t.ownerDocument||t:w)!==d&&p(t),t=t||d,g)){if(11!==T&&(f=J.exec(e)))if(o=f[1]){if(9===T){if(!(l=t.getElementById(o)))return r;if(l.id===o)return r.push(l),r}else if(m&&(l=m.getElementById(o))&&x(t,l)&&l.id===o)return r.push(l),r}else{if(f[2])return L.apply(r,t.getElementsByTagName(e)),r;if((o=f[3])&&n.getElementsByClassName&&t.getElementsByClassName)return L.apply(r,t.getElementsByClassName(o)),r}if(n.qsa&&!S[e+\" \"]&&(!y||!y.test(e))){if(1!==T)m=t,v=e;else if(\"object\"!==t.nodeName.toLowerCase()){(c=t.getAttribute(\"id\"))?c=c.replace(te,ne):t.setAttribute(\"id\",c=b),s=(h=a(e)).length;while(s--)h[s]=\"#\"+c+\" \"+ve(h[s]);v=h.join(\",\"),m=K.test(e)&&ge(t.parentNode)||t}if(v)try{return L.apply(r,m.querySelectorAll(v)),r}catch(e){}finally{c===b&&t.removeAttribute(\"id\")}}}return u(e.replace(B,\"$1\"),t,r,i)}function ae(){var e=[];function t(n,i){return e.push(n+\" \")>r.cacheLength&&delete t[e.shift()],t[n+\" \"]=i}return t}function se(e){return e[b]=!0,e}function ue(e){var t=d.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function le(e,t){var n=e.split(\"|\"),i=n.length;while(i--)r.attrHandle[n[i]]=t}function ce(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function fe(e){return function(t){return\"input\"===t.nodeName.toLowerCase()&&t.type===e}}function pe(e){return function(t){var n=t.nodeName.toLowerCase();return(\"input\"===n||\"button\"===n)&&t.type===e}}function de(e){return function(t){return\"form\"in t?t.parentNode&&!1===t.disabled?\"label\"in t?\"label\"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&ie(t)===e:t.disabled===e:\"label\"in t&&t.disabled===e}}function he(e){return se(function(t){return t=+t,se(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}function ge(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}n=oe.support={},o=oe.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return!!t&&\"HTML\"!==t.nodeName},p=oe.setDocument=function(e){var t,i,a=e?e.ownerDocument||e:w;return a!==d&&9===a.nodeType&&a.documentElement?(d=a,h=d.documentElement,g=!o(d),w!==d&&(i=d.defaultView)&&i.top!==i&&(i.addEventListener?i.addEventListener(\"unload\",re,!1):i.attachEvent&&i.attachEvent(\"onunload\",re)),n.attributes=ue(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),n.getElementsByTagName=ue(function(e){return e.appendChild(d.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),n.getElementsByClassName=Q.test(d.getElementsByClassName),n.getById=ue(function(e){return h.appendChild(e).id=b,!d.getElementsByName||!d.getElementsByName(b).length}),n.getById?(r.filter.ID=function(e){var t=e.replace(Z,ee);return function(e){return e.getAttribute(\"id\")===t}},r.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&g){var n=t.getElementById(e);return n?[n]:[]}}):(r.filter.ID=function(e){var t=e.replace(Z,ee);return function(e){var n=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return n&&n.value===t}},r.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&g){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),r.find.TAG=n.getElementsByTagName?function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):n.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},r.find.CLASS=n.getElementsByClassName&&function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&g)return t.getElementsByClassName(e)},v=[],y=[],(n.qsa=Q.test(d.querySelectorAll))&&(ue(function(e){h.appendChild(e).innerHTML=\"\",e.querySelectorAll(\"[msallowcapture^='']\").length&&y.push(\"[*^$]=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\"[selected]\").length||y.push(\"\\\\[\"+M+\"*(?:value|\"+P+\")\"),e.querySelectorAll(\"[id~=\"+b+\"-]\").length||y.push(\"~=\"),e.querySelectorAll(\":checked\").length||y.push(\":checked\"),e.querySelectorAll(\"a#\"+b+\"+*\").length||y.push(\".#.+[+~]\")}),ue(function(e){e.innerHTML=\"\";var t=d.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),e.querySelectorAll(\"[name=d]\").length&&y.push(\"name\"+M+\"*[*^$|!~]?=\"),2!==e.querySelectorAll(\":enabled\").length&&y.push(\":enabled\",\":disabled\"),h.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&y.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),y.push(\",.*:\")})),(n.matchesSelector=Q.test(m=h.matches||h.webkitMatchesSelector||h.mozMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&ue(function(e){n.disconnectedMatch=m.call(e,\"*\"),m.call(e,\"[s!='']:x\"),v.push(\"!=\",W)}),y=y.length&&new RegExp(y.join(\"|\")),v=v.length&&new RegExp(v.join(\"|\")),t=Q.test(h.compareDocumentPosition),x=t||Q.test(h.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return f=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r||(1&(r=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!n.sortDetached&&t.compareDocumentPosition(e)===r?e===d||e.ownerDocument===w&&x(w,e)?-1:t===d||t.ownerDocument===w&&x(w,t)?1:c?O(c,e)-O(c,t):0:4&r?-1:1)}:function(e,t){if(e===t)return f=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===d?-1:t===d?1:i?-1:o?1:c?O(c,e)-O(c,t):0;if(i===o)return ce(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?ce(a[r],s[r]):a[r]===w?-1:s[r]===w?1:0},d):d},oe.matches=function(e,t){return oe(e,null,null,t)},oe.matchesSelector=function(e,t){if((e.ownerDocument||e)!==d&&p(e),t=t.replace(z,\"='$1']\"),n.matchesSelector&&g&&!S[t+\" \"]&&(!v||!v.test(t))&&(!y||!y.test(t)))try{var r=m.call(e,t);if(r||n.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){}return oe(t,d,null,[e]).length>0},oe.contains=function(e,t){return(e.ownerDocument||e)!==d&&p(e),x(e,t)},oe.attr=function(e,t){(e.ownerDocument||e)!==d&&p(e);var i=r.attrHandle[t.toLowerCase()],o=i&&N.call(r.attrHandle,t.toLowerCase())?i(e,t,!g):void 0;return void 0!==o?o:n.attributes||!g?e.getAttribute(t):(o=e.getAttributeNode(t))&&o.specified?o.value:null},oe.escape=function(e){return(e+\"\").replace(te,ne)},oe.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},oe.uniqueSort=function(e){var t,r=[],i=0,o=0;if(f=!n.detectDuplicates,c=!n.sortStable&&e.slice(0),e.sort(D),f){while(t=e[o++])t===e[o]&&(i=r.push(o));while(i--)e.splice(r[i],1)}return c=null,e},i=oe.getText=function(e){var t,n=\"\",r=0,o=e.nodeType;if(o){if(1===o||9===o||11===o){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=i(e)}else if(3===o||4===o)return e.nodeValue}else while(t=e[r++])n+=i(t);return n},(r=oe.selectors={cacheLength:50,createPseudo:se,match:V,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(Z,ee),e[3]=(e[3]||e[4]||e[5]||\"\").replace(Z,ee),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||oe.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&oe.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return V.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&X.test(n)&&(t=a(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(Z,ee).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=E[e+\" \"];return t||(t=new RegExp(\"(^|\"+M+\")\"+e+\"(\"+M+\"|$)\"))&&E(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(e,t,n){return function(r){var i=oe.attr(r,e);return null==i?\"!=\"===t:!t||(i+=\"\",\"=\"===t?i===n:\"!=\"===t?i!==n:\"^=\"===t?n&&0===i.indexOf(n):\"*=\"===t?n&&i.indexOf(n)>-1:\"$=\"===t?n&&i.slice(-n.length)===n:\"~=\"===t?(\" \"+i.replace($,\" \")+\" \").indexOf(n)>-1:\"|=\"===t&&(i===n||i.slice(0,n.length+1)===n+\"-\"))}},CHILD:function(e,t,n,r,i){var o=\"nth\"!==e.slice(0,3),a=\"last\"!==e.slice(-4),s=\"of-type\"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==a?\"nextSibling\":\"previousSibling\",y=t.parentNode,v=s&&t.nodeName.toLowerCase(),m=!u&&!s,x=!1;if(y){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===v:1===p.nodeType)return!1;h=g=\"only\"===e&&!h&&\"nextSibling\"}return!0}if(h=[a?y.firstChild:y.lastChild],a&&m){x=(d=(l=(c=(f=(p=y)[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]||[])[0]===T&&l[1])&&l[2],p=d&&y.childNodes[d];while(p=++d&&p&&p[g]||(x=d=0)||h.pop())if(1===p.nodeType&&++x&&p===t){c[e]=[T,d,x];break}}else if(m&&(x=d=(l=(c=(f=(p=t)[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]||[])[0]===T&&l[1]),!1===x)while(p=++d&&p&&p[g]||(x=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===v:1===p.nodeType)&&++x&&(m&&((c=(f=p[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]=[T,x]),p===t))break;return(x-=i)===r||x%r==0&&x/r>=0}}},PSEUDO:function(e,t){var n,i=r.pseudos[e]||r.setFilters[e.toLowerCase()]||oe.error(\"unsupported pseudo: \"+e);return i[b]?i(t):i.length>1?(n=[e,e,\"\",t],r.setFilters.hasOwnProperty(e.toLowerCase())?se(function(e,n){var r,o=i(e,t),a=o.length;while(a--)e[r=O(e,o[a])]=!(n[r]=o[a])}):function(e){return i(e,0,n)}):i}},pseudos:{not:se(function(e){var t=[],n=[],r=s(e.replace(B,\"$1\"));return r[b]?se(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),t[0]=null,!n.pop()}}),has:se(function(e){return function(t){return oe(e,t).length>0}}),contains:se(function(e){return e=e.replace(Z,ee),function(t){return(t.textContent||t.innerText||i(t)).indexOf(e)>-1}}),lang:se(function(e){return U.test(e||\"\")||oe.error(\"unsupported lang: \"+e),e=e.replace(Z,ee).toLowerCase(),function(t){var n;do{if(n=g?t.lang:t.getAttribute(\"xml:lang\")||t.getAttribute(\"lang\"))return(n=n.toLowerCase())===e||0===n.indexOf(e+\"-\")}while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===d.activeElement&&(!d.hasFocus||d.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:de(!1),disabled:de(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType"},{"title":"所有分类","date":"2019-12-19T02:12:02.734Z","updated":"2019-12-19T02:12:02.734Z","comments":true,"path":"categories/index.html","permalink":"https://wxmac.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"三十三、  微信，支付宝扫码进入对应小程序指定页面","slug":"33. 微信 支付宝扫码进入对应小程序指定页面","date":"2020-09-30T16:00:00.000Z","updated":"2020-09-25T07:37:50.925Z","comments":true,"path":"2020/10/01/33. 微信 支付宝扫码进入对应小程序指定页面/","link":"","permalink":"https://wxmac.github.io/2020/10/01/33. 微信 支付宝扫码进入对应小程序指定页面/","excerpt":"","text":"文章链接 需求用微信和支付宝扫同一个普通二维码，支付宝扫码进入支付宝小程序的支付页面，微信扫码进入微信小程序的支付页面。 解决办法： 微信公众平台和蚂蚁金服开放平台都有自己的二维码配置规则。配置相同的规则，然后用配置的二维码地址加上参数，用草料生成二维码。 1.微信公众平台配置 微信公众平台——开发——开发设置——扫普通链接二维码打开小程序 1. 2. 3. 2.蚂蚁金服开放平台 蚂蚁金服平台登录——服务商登录（进入我的开放平台）——开发中心（小程序）——我的小程序（查看发布的版本）——码管理（关联普通二维码）","categories":[],"tags":[{"name":"微信","slug":"微信","permalink":"https://wxmac.github.io/tags/微信/"},{"name":"扫码","slug":"扫码","permalink":"https://wxmac.github.io/tags/扫码/"},{"name":"支付宝","slug":"支付宝","permalink":"https://wxmac.github.io/tags/支付宝/"}]},{"title":"三十二、 动态规划解决斐波那契数列","slug":"32.动态规划解决斐波那契数列","date":"2020-09-29T16:00:00.000Z","updated":"2020-09-16T02:53:28.500Z","comments":true,"path":"2020/09/30/32.动态规划解决斐波那契数列/","link":"","permalink":"https://wxmac.github.io/2020/09/30/32.动态规划解决斐波那契数列/","excerpt":"","text":"文章链接 斐波那契数列指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…… 第3项开始，每一项都等于前两项之和。 1.基础版本123456789const fib = (x) =&gt; &#123; if( x == 1 || x == 2)&#123; return 1 &#125; return fib( x - 1 ) + fib( x - 2 )&#125;fib(10)// 55 2.带备忘录的递归解法123456789101112131415161718192021const fib = (x) =&gt; &#123; if( x &lt; 1 )&#123; return 0 &#125; let memo = new Array(x + 1).fill(0); return helper(memo, x)&#125;const helper = ( memo, x ) =&gt; &#123; if( x == 1 || x == 2 )&#123; return 1 &#125; if( memo[x] != 0 )&#123; return memo[x]; &#125; memo[x] = helper( memo, x - 1 ) + helper( memo, x - 2 ) return memo[x]&#125;fib(10)// 55 3.「自底向上」的推算123456789101112131415const fib = (x) =&gt; &#123; let dp = new Array(x + 1).fill(0); dp[1] = dp[2] = 1; for(let i = 3; i &lt;= x; i++ )&#123; dp[i] = dp[ i - 1] + dp[ i - 2] &#125; return dp[x]&#125;fib(10)// 55","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://wxmac.github.io/tags/动态规划/"},{"name":"斐波那契数列","slug":"斐波那契数列","permalink":"https://wxmac.github.io/tags/斐波那契数列/"}]},{"title":"三十一、 react圆盘抽奖","slug":"31.react圆盘抽奖","date":"2020-09-14T16:00:00.000Z","updated":"2020-09-25T08:40:16.683Z","comments":true,"path":"2020/09/15/31.react圆盘抽奖/","link":"","permalink":"https://wxmac.github.io/2020/09/15/31.react圆盘抽奖/","excerpt":"","text":"使用 12345678910111213141516171819202122232425 const awardsList = [ &#123;gift_value: \"140\", index_num: 1, gift_name: \"140元加油券\", product_no: \"FO-100438-14\"&#125;, &#123;gift_value: \"2999\", index_num: 2, gift_name: \"2999元空气净化器\"&#125;, &#123;gift_value: \"210\", index_num: 3, gift_name: \"210元加油券\", product_no: \"FO-100438-16\"&#125;, &#123;gift_value: \"50\", index_num: 4, gift_name: \"50元美容养护券\", product_no: \"CW\"&#125;, &#123;gift_value: \"200\", index_num: 5, gift_name: \"200元加油券\", product_no: \"FO-100438-09\"&#125;, &#123;gift_value: \"144\", index_num: 6, gift_name: \"144元车载香薰\"&#125;, &#123;gift_value: \"80\", index_num: 7, gift_name: \"80元加油券\", product_no: \"FO-100438-07\"&#125;, &#123;gift_value: \"15\", index_num: 8, gift_name: \"15元洗车券\", product_no: \"CW\"&#125;, &#123;gift_value: \"70\", index_num: 9, gift_name: \"70元加油券\", product_no: \"FO-100438-13\"&#125;, &#123;gift_value: \"549\", index_num: 10, gift_name: \"549元行车记录仪\"&#125;, &#123;gift_value: \"350\", index_num: 11, gift_name: \"350元加油券\", product_no: \"FO-100438-18\"&#125;, &#123;gift_value: \"0\", index_num: 12, gift_name: \"谢谢参与\"&#125;]&lt;Lottery lotteryStart = &#123; () =&gt; &#123; console.log('start')&#125; &#125; hasChange = &#123; true &#125; resultIndex = &#123; currIndex &#125;awardsList=&#123; awardsList &#125; handleLotterySuccess=&#123; (curr) =&gt; &#123; onsole.log(curr)&#125; &#125; /&gt; HTML + js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336/************ data.js ***************/ // i等于奖品下标let Imgconfig = []; let rewardLength = 12; // 奖品长度for( let i = 0; i &lt; rewardLength; i++ )&#123; Imgconfig[i] = new Image(); Imgconfig[i].src = require(`@/assets/img/nation/lottery/img$&#123;i&#125;.png`);&#125;export default Imgconfig;/************ index.js ***************/ /* * @Author: hwh * @Date: 2020-04-23 18:50:20 * @LastEditors: Please set LastEditors * @LastEditTime: 2020-09-25 11:44:52 * 圆盘抽奖组件 */ import React, &#123; useState, useRef, useEffect &#125; from 'react'import styleCss from './style.less';import '@/units/isLoginApp';import Imgconfig from './data';import &#123; getParams, getFuncId, getPostData, isApp, trackEvent &#125; from '@/units/common';class Lottery extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; awards: [],//大转盘的奖品列表 animation: true, fileRootPath: \"\",//\"http://co.dev.touty.io\" startRadian: -90 * Math.PI / 180,//大转盘的开始弧度(canvas绘制圆从水平方向开始，所以这里调整为垂直方向) 弧度计算公式：角度*Math.PI/180 canBeClick: true,//判断抽奖有没有结束 canvas: '', content: '', resultIndex: -1 &#125; &#125; // // 获取配置 componentWillReceiveProps(props)&#123; // 奖品配置列表 if( props.awardsList &amp;&amp; props.awardsList.length &gt; 0 )&#123; this.setState(&#123; awards: props.awardsList &#125;) this.onLoadPage( props.awardsList ); // 初始化配置 &#125; // 是否可以点击 // console.log('props.hasChange', props.hasChange) this.setState(&#123; canBeClick: props.hasChange &#125;) // console.log('resultIndex',props.resultIndex &amp;&amp; props.resultIndex &gt; -1 ) // 获取抽奖下标 if( props.resultIndex &amp;&amp; props.resultIndex &gt; -1 )&#123; this.setState(&#123; resultIndex: props.resultIndex - 1 &#125;, () =&gt; &#123; this.draw() &#125;) &#125; &#125; // 初始化配置 onLoadPage(awards) &#123; let &#123; startRadian &#125; = this.state; let canvas = document.getElementById(\"wheelcanvas\"); // 获取canvas的上下文,context含有各种api用来操作canvas let context = canvas.getContext('2d'); this.setState(&#123;canvas: canvas, context: context&#125;); context.save(); // 新建一个路径,画笔的位置回到默认的坐标(0,0)的位置 // 保证了当前的绘制不会影响到之前的绘制 context.beginPath(); // 设置填充转盘用的颜色,fill是填充而不是绘制 context.fillStyle = '#fff'; // 绘制一个圆,有六个参数,分别表示:圆心的x坐标,圆心的y坐标,圆的半径,开始绘制的角度,结束的角度,绘制方向(false表示顺时针) context.arc(211, 211, 211, startRadian, Math.PI * 2 + startRadian, false); // 将设置的颜色填充到圆中,这里不用closePath是因为closePath对fill无效. context.fill(); // 将画布的状态恢复到上一次save()时的状态 context.restore(); // 第一个奖品色块开始绘制时开始的弧度及结束的弧度 let RadianGap = Math.PI * 2 / awards.length, endRadian = startRadian + RadianGap; for (let i = 0; i &lt; awards.length; i++) &#123; context.save(); context.beginPath(); // 为了区分不同的色块,使用随机生成的颜色作为色块的填充色 context.fillStyle = i % 2 == 0 ? 'rgba(247,193,11,1)' : 'rgba(250,213,11,1)'; // 这里需要使用moveTo方法将初始位置定位在圆点处,这样绘制的圆弧都会以圆点作为闭合点 context.moveTo(211, 211); // 画圆弧时,每次都会自动调用moveTo,将画笔移动到圆弧的起点,半径设置的比转盘稍小一点 context.arc(211, 211, 211, startRadian, endRadian, false); context.fill(); context.restore(); // 开始绘制文字 context.save(); //设置文字颜色 context.fillStyle = '#f00'; //设置文字样式 context.font = \"16px Arial\"; // 改变canvas原点的位置,简单来说,translate到哪个坐标点,那么那个坐标点就将变为坐标(0, 0) context.translate( 211 + Math.cos(startRadian + RadianGap / 2) * 201, 211 + Math.sin(startRadian + RadianGap / 2) * 201 ); // 旋转角度,这个旋转是相对于原点进行旋转的. context.rotate(startRadian + RadianGap / 2 + Math.PI / 2); // 这里就是根据获取的各行的文字进行绘制,maxLineWidth取150,相当与一行最多展示个10文字 // 文字一：奖品名称 const gift_name = awards[i].gift_name; const name = gift_name.indexOf('元') &gt; -1 ? gift_name.split('元')[1] : gift_name; this.getLineTextList(context, name , 70).forEach((line, index) =&gt; &#123; // 绘制文字的方法,三个参数分别带:要绘制的文字,开始绘制的x坐标,开始绘制的y坐标 context.fillText(line, -context.measureText(line).width / 2, ++index * 25) &#125;); // 文字二：奖品价格 const price = awards[i].gift_value; const newPrice = price &amp;&amp; price &gt; 0 ? '￥'+ price : ''; const inudesArr = [ 1, 5, 9 ]; if( inudesArr.includes(i) )&#123; this.getLineTextList(context, newPrice , 70).forEach((line, index) =&gt; &#123; context.fillText( line, -context.measureText(line).width / 2, ++index * 90) &#125;); &#125; // 渲染图片 this.handleRenderAllImg(context, i) context.restore(); // 每个奖品色块绘制完后,下个奖品的弧度会递增 startRadian += RadianGap; endRadian += RadianGap; &#125; //下面是画中间的小圆 context.save(); // 新建一个路径,画笔的位置回到默认的坐标(0,0)的位置 // 保证了当前的绘制不会影响到之前的绘制 context.beginPath(); // 设置填充转盘用的颜色,fill是填充而不是绘制 context.fillStyle = '#fff'; // 绘制一个圆,有六个参数,分别表示:圆心的x坐标,圆心的y坐标,圆的半径,开始绘制的角度,结束的角度,绘制方向(false表示顺时针) context.arc(211, 211, 70, startRadian, Math.PI * 2 + startRadian, false); // 将设置的颜色填充到圆中,这里不用closePath是因为closePath对fill无效. context.fill(); // 将画布的状态恢复到上一次save()时的状态 context.restore(); &#125; // 渲染图片 handleRenderAllImg( context, i )&#123; const inudesArr = [ 1, 5, 9 ,11 ]; // 其他图片类型 if( !inudesArr.includes(i) )&#123; context.drawImage( Imgconfig[i] , -20 , 42 , 45 , 20); &#125; // 单独处理 switch(i)&#123; case 1: &#123; // 净化器 context.drawImage( Imgconfig[1] , -20 , 30 , 40 , 40); break; &#125; case 5: &#123; // 香薰 context.drawImage( Imgconfig[5] , -20 , 25 , 50 , 50); break; &#125; case 9: &#123; // 记录仪 context.drawImage( Imgconfig[9] , -15 , 35 , 30 , 30); break; &#125; case 11: &#123; // 谢谢参与 context.drawImage( Imgconfig[11] , -15 , 35 , 30 , 30); break; &#125; default: &#123;&#125; &#125; &#125; // 绘制文字，文字过长进行换行，防止文字溢出 getLineTextList(context, text, maxLineWidth) &#123; let wordList = text.split(''), tempLine = '', lineList = []; for (let i = 0; i &lt; wordList.length; i++) &#123; if (context.measureText(tempLine).width &gt;= maxLineWidth) &#123; lineList.push(tempLine); maxLineWidth -= context.measureText(text[0]).width; tempLine = '' &#125; tempLine += wordList[i] &#125; lineList.push(tempLine); return lineList &#125; // 将canvas在window中的坐标点转化为canvas中的坐标点 windowToCanvas(canvas, e) &#123; // getBoundingClientRect这个方法返回html元素的大小及其相对于视口的位置 const canvasPostion = canvas.getBoundingClientRect(), x = e.clientX, y = e.clientY; return &#123; x: x - canvasPostion.left, y: y - canvasPostion.top &#125; &#125;; //点击抽奖让转盘转起来 draw(e) &#123; const &#123; canBeClick, awards, resultIndex &#125; = this.state; // 只要抽奖没有结束，就不让再次抽奖 if (!canBeClick) return; // 抽奖下标大于数组长度 if( resultIndex &gt; awards.length - 1 )&#123; window.global.showMsg('配置错误', true) return; &#125; // 开始抽奖 this.setState(&#123; canBeClick: false, startRadian: 0 &#125;, () =&gt; &#123; // 每次点击抽奖，都将初始化角度重置 const distance = this.distanceToStop(); this.rotatePanel(distance);//调用处理旋转的方法 &#125;) &#125; // 处理旋转的关键方法 rotatePanel(distance) &#123; let animateId = ''; // 这里用一个很简单的缓动函数来计算每次绘制需要改变的角度，这样可以达到一个转盘从快到慢的渐变的过程 const &#123; startRadian, awards &#125; = this.state; const changeRadian = Math.abs((distance - startRadian) / 20); this.setState((prev) =&gt; &#123; return &#123; startRadian: prev.startRadian += changeRadian &#125; &#125;) // 当最后的目标距离与startRadian之间的差距低于0.0001时，就默认奖品抽完了，可以继续抽下一个了。 if (distance - startRadian &lt;= 0.001) &#123; // 抽奖完成，传递给父元素 this.props.handleLotterySuccess(); animateId &amp;&amp; window.cancelAnimationFrame(animateId) this.setState(&#123; canBeClick: true, resultIndex: -1 &#125;) return; &#125;; // 初始角度改变后，需要重新绘制 this.onLoadPage(awards); // 循环调用rotatePanel函数，使得转盘的绘制连续，造成旋转的视觉效果 animateId = window.requestAnimationFrame(this.rotatePanel.bind(this, distance)); &#125; // 停止旋转的角度 distanceToStop() &#123; let &#123; awards &#125; = this.state; // middleDegrees为奖品块的中间角度（最终停留都是以中间角度进行计算的）距离初始的startRadian的距离，distance就是当前奖品跑到指针位置要转动的距离。 let middleDegrees = 0, distance = 0; // 映射出每个奖品的middleDegrees let awardsToDegreesList = awards.map((data, index) =&gt; &#123; let awardRadian = (Math.PI * 2) / awards.length; return awardRadian * index + (awardRadian * (index + 1) - awardRadian * index) / 2 &#125;); // resultIndex索引值，来表示此次抽奖应该中的奖品 const currentPrizeIndex = this.state.resultIndex; middleDegrees = awardsToDegreesList[currentPrizeIndex]; // 因为指针是垂直向上的，相当坐标系的Math.PI/2,所以这里要进行判断来移动角度 distance = Math.PI * 3 / 2 - middleDegrees; distance = distance &gt; 0 ? distance : Math.PI * 2 + distance; // 这里额外加上后面的值，是为了让转盘多转动几圈，看上去更像是在抽奖 return distance + Math.PI * 1000 ; &#125; handleLotteryStart = async () =&gt; &#123; this.props.lotteryStart() &#125; render()&#123; const &#123; canBeClick, resultIndex, awards &#125; = this.state; const &#123; changeWidth &#125; = this.props; const styleC = &#123; width: changeWidth &#125; return &lt;div className=&#123; styleCss.wheel_container &#125;&gt; &lt;div className=&#123; styleCss.wheel_main&#125;&gt; &lt;div className=&#123; styleCss.wheel&#125;&gt; &#123;/* 转盘背景 */&#125; &lt;img props=\"\" alt=\"\" className=&#123; styleCss.wheel_circle&#125; src=&#123; require('@/assets/img/lottery/lottery_box.png') &#125;/&gt; &#123;/* 转盘 */&#125; &lt;canvas style=&#123; changeWidth &amp;&amp; styleC &#125; className=&#123; styleCss.item &#125; id=\"wheelcanvas\" height=&#123;422&#125; width=&#123;422&#125;/&gt; &#123;/* 开始按钮 */&#125; &lt;img props=\"\" alt=\"\" onClick=&#123; () =&gt; &#123; this.handleLotteryStart() &#125; &#125; className=&#123; `$&#123;styleCss.pointer&#125; $&#123; !canBeClick ? styleCss.dis : '' &#125;` &#125; src=&#123; require('@/assets/img/lottery/lottery_btn.png') &#125;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#125; &#125; export default Lottery; css123456789101112131415161718192021222324252627282930313233343536373839404142434445.wheel_container&#123; width: 100%; .wheel_main&#123; text-align: center; position: relative; background-size: auto 100%; background-position: center; margin: 0 auto; width: 100%; .wheel&#123; margin: 0 auto; width: 100%; position: relative; &amp;_circle&#123; position: relative; width: 8rem; &#125; .item&#123; position: absolute; width: 6rem; top: 49.3%; left: 50%; transform: translate(-50%, -50%); &#125; .pointer&#123; position: absolute; width: 45%; height: 45%; top: 50%; left: 50%; transform: translate(-50%, -50%); cursor: pointer; transition: all .3s; &#125; .dis&#123; opacity: .6; filter: grayscale(.8); &#125; &#125; &#125; img&#123; max-width: 100%; &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://wxmac.github.io/tags/react/"},{"name":"抽奖","slug":"抽奖","permalink":"https://wxmac.github.io/tags/抽奖/"}]},{"title":"三十、 H5摇一摇实现","slug":"30.H5摇一摇实现","date":"2020-09-01T16:00:00.000Z","updated":"2020-08-26T07:22:58.823Z","comments":true,"path":"2020/09/02/30.H5摇一摇实现/","link":"","permalink":"https://wxmac.github.io/2020/09/02/30.H5摇一摇实现/","excerpt":"","text":"最近有个需求，是要求和微信摇一摇一样，摇动手机，请求接口，完成抽奖领券效果。 注意的点： 部分手机不支持摇一摇，解决方法是加了一个点击按钮； ios13以上手机需要点击按钮授权； 摇动完成才能播放音效，微信内需在 wx.ready 中调用; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206import wx from 'weixin-js-sdk';/** * @description: 用户授权 调用摇一摇 */const [ authorization, setAuthorization ] = useState(false); // 是否授权const handleShakeStart = throttle(() =&gt; &#123; if( !isLogin )&#123; handleNeedLogin();return; &#125; // 抽奖结果 addShake(()=&gt;&#123; handleShakeInit() &#125;)&#125;, 5000)/** * @description: 按钮点击抽奖 */const handleBtnShakeStart = () =&gt; &#123; if( !isLogin )&#123; handleNeedLogin();return; &#125; handleShakeInit() &#125;/** * @description: 摇一摇 - 抽奖 */const handleShakeInit = () =&gt; &#123; const playV = document.querySelector('audio'); playV.load() if( isIos() &amp;&amp; isWx( ))&#123; wx.config(&#123; // 配置信息, 即使不正确也能使用 wx.ready debug: false, appId: '', timestamp: 1, nonceStr: '', signature: '', jsApiList: [] &#125;); wx.ready(function() &#123; playV.play() setTimeout(() =&gt; &#123; playV.currentTime = 0; playV.pause() &#125;,2000) &#125;); &#125; else &#123; playV.play(); setTimeout(() =&gt; &#123; playV.currentTime = 0; playV.pause() &#125;,2000) &#125; // 调用人物动画 setShowPeople(true) // 抽奖结果 handleLotteryResult()&#125;/** * @description: 抽奖结果 */const handleLotteryResult = () =&gt; &#123; // 抽奖结果 const params = &#123; funcId: 171521, lottery_no: lotteryNo &#125; loading.current.ShowLoading(true) getPostData(params).then((res) =&gt; &#123; loading.current.ShowLoading(false) if(res.data.success &amp;&amp; res.data.data &amp;&amp; res.data.data.length &gt; 0)&#123; const data = res.data.data[0]; setLotteryNum(data.limit_num) setIndexData(data) isStartShake = true if( data.is_lottery == 'YES' )&#123; // 抽中奖品 setShowDialog(true) setFlagDialog(1) &#125; else &#123; // 未抽中奖品 setShowDialog(true) setFlagDialog(2) &#125; &#125; else &#123; isStartShake = true if(res.data.msg)&#123; window.global.showMsg(res.data.msg, true, 5000) &#125; &#125; &#125;)&#125;/** * @description: 检测手机是否支持摇一摇 */const setDeviceMotion = (cb) =&gt; &#123; if(!window.DeviceMotionEvent)&#123; window.global.showMsg(\"设备不支持DeviceMotion\", true); return; &#125; if (typeof DeviceMotionEvent.requestPermission === 'function') &#123; // IOS 13 DeviceMotionEvent.requestPermission() .then(permissionState =&gt; &#123; if (permissionState === 'granted') &#123; // 必须在https环境才行 window.addEventListener('devicemotion',cb); setAuthorization(true) &#125; else &#123; // ios中，用户取消授权之后，把浏览器进程杀了，才能再次授权 window.global.showMsg(\"用户未允许权限\", true); &#125; &#125;) .catch((err)=&gt;&#123; window.global.showMsg(\"用户未允许权限\", true); &#125;); &#125; else &#123; // 其他支持加速度检测的系统 let timer = setTimeout(function()&#123; window.global.showMsg(\"用户未允许权限\", true); &#125;,1000); window.addEventListener(\"devicemotion\",(e)=&gt;&#123; clearTimeout(timer); &#125;,&#123;once:true&#125;); window.addEventListener(\"devicemotion\",cb); &#125;&#125; function throttleFn(fn,interval=200,start = true)&#123; if(typeof fn !== \"function\")&#123; return console.error(\"请传入一个函数\"); &#125; let timer = 0; return function(...arg)&#123; let _this = this; if(timer)&#123; return ; &#125; start&amp;&amp;fn.apply(_this,arg); timer = setTimeout(() =&gt; &#123; (!start)&amp;&amp;fn.apply(_this,arg); timer = 0; &#125;, interval); &#125;&#125; /** * @description: 添加摇一摇 * addShake 添加摇一摇功能 参数： cbShake 类型 fn 当用户进行了摇一摇之后要做的事情 返回值： shakeIndex 开启的第几个摇一摇功能的索引，用来删除监听 */const addShake = (cbShake) =&gt; &#123; function toShake(e)&#123; let motion = e.acceleration; let &#123;x,y,z&#125; = motion; let range = Math.abs(x - lastX) + Math.abs(y - lastY) + Math.abs(z - lastZ); if(range &gt; maxRange)&#123;//用户进行了摇一摇 isShake = true; &#125; if(range &lt; minRange&amp;&amp;isShake)&#123; // 停止摇一摇 cbShake(e); isShake = false; &#125; lastX = x; lastY = y; lastZ = z; &#125; if(!window.shakeEvent)&#123; //建立 shakeEvent 存储所有的摇一摇的处理函数，方便一会取消 window.shakeEvent = []; &#125; const newShake = throttleFn(toShake) window.shakeEvent.push(newShake); setDeviceMotion(newShake) return window.shakeEvent.length - 1;//返回该次摇一摇处理的索引&#125;/** * @description: 移除摇一摇 */const remveShake = (shakeIndex) =&gt; &#123; window.removeEventListener(\"devicemotion\", window.shakeEvent[shakeIndex]);&#125;","categories":[],"tags":[{"name":"shake","slug":"shake","permalink":"https://wxmac.github.io/tags/shake/"},{"name":"摇一摇","slug":"摇一摇","permalink":"https://wxmac.github.io/tags/摇一摇/"}]},{"title":"二十九、echarts配置说明","slug":"29.echarts配置说明","date":"2020-08-29T16:00:00.000Z","updated":"2020-08-26T07:13:52.233Z","comments":true,"path":"2020/08/30/29.echarts配置说明/","link":"","permalink":"https://wxmac.github.io/2020/08/30/29.echarts配置说明/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737theme = &#123; // 全图默认背景 // backgroundColor: 'rgba(0,0,0,0)', // 默认色板 color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed', '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0', '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700', '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'], // 图表标题 title: &#123; x: 'left', // 水平安放位置，默认为左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） //textAlign: null // 水平对齐方式，默认根据x设置自动调整 backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 标题边框颜色 borderWidth: 0, // 标题边框线宽，单位px，默认为0（无边框） padding: 5, // 标题内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 主副标题纵向间隔，单位px，默认为10， textStyle: &#123; fontSize: 18, fontWeight: 'bolder', color: '#333' // 主标题文字颜色 &#125;, subtextStyle: &#123; color: '#aaa' // 副标题文字颜色 &#125; &#125;, // 图例 legend: &#123; orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'center', // 水平安放位置，默认为全图居中，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 图例边框颜色 borderWidth: 0, // 图例边框线宽，单位px，默认为0（无边框） padding: 5, // 图例内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 图例图形宽度 itemHeight: 14, // 图例图形高度 textStyle: &#123; color: '#333' // 图例文字颜色 &#125; &#125;, // 值域 dataRange: &#123; orient: 'vertical', // 布局方式，默认为垂直布局，可选为： // 'horizontal' ¦ 'vertical' x: 'left', // 水平安放位置，默认为全图左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'bottom', // 垂直安放位置，默认为全图底部，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 值域边框颜色 borderWidth: 0, // 值域边框线宽，单位px，默认为0（无边框） padding: 5, // 值域内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 值域图形宽度，线性渐变水平布局宽度为该值 * 10 itemHeight: 14, // 值域图形高度，线性渐变垂直布局高度为该值 * 10 splitNumber: 5, // 分割段数，默认为5，为0时为线性渐变 color:['#1e90ff','#f0ffff'],//颜色 //text:['高','低'], // 文本，默认为数值文本 textStyle: &#123; color: '#333' // 值域文字颜色 &#125; &#125;, toolbox: &#123; orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'right', // 水平安放位置，默认为全图右对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） color : ['#1e90ff','#22bb22','#4b0082','#d2691e'], backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色 borderColor: '#ccc', // 工具箱边框颜色 borderWidth: 0, // 工具箱边框线宽，单位px，默认为0（无边框） padding: 5, // 工具箱内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemSize: 16, // 工具箱图形宽度 featureImageIcon : &#123;&#125;, // 自定义图片icon featureTitle : &#123; mark : '辅助线开关', markUndo : '删除辅助线', markClear : '清空辅助线', dataZoom : '区域缩放', dataZoomReset : '区域缩放后退', dataView : '数据视图', lineChart : '折线图切换', barChart : '柱形图切换', restore : '还原', saveAsImage : '保存为图片' &#125; &#125;, // 提示框 tooltip: &#123; trigger: 'item', // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis' showDelay: 20, // 显示延迟，添加显示延迟可以避免频繁切换，单位ms hideDelay: 100, // 隐藏延迟，单位ms transitionDuration : 0.4, // 动画变换时间，单位s backgroundColor: 'rgba(0,0,0,0.7)', // 提示背景颜色，默认为透明度为0.7的黑色 borderColor: '#333', // 提示边框颜色 borderRadius: 4, // 提示边框圆角，单位px，默认为4 borderWidth: 0, // 提示边框线宽，单位px，默认为0（无边框） padding: 5, // 提示内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css axisPointer : &#123; // 坐标轴指示器，坐标轴触发有效 type : 'line', // 默认为直线，可选为：'line' | 'shadow' lineStyle : &#123; // 直线指示器样式设置 color: '#48b', width: 2, type: 'solid' &#125;, shadowStyle : &#123; // 阴影指示器样式设置 width: 'auto', // 阴影大小 color: 'rgba(150,150,150,0.3)' // 阴影颜色 &#125; &#125;, textStyle: &#123; color: '#fff' &#125; &#125;, // 区域缩放控制器 dataZoom: &#123; orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' // x: &#123;number&#125;, // 水平安放位置，默认为根据grid参数适配，可选为： // &#123;number&#125;（x坐标，单位px） // y: &#123;number&#125;, // 垂直安放位置，默认为根据grid参数适配，可选为： // &#123;number&#125;（y坐标，单位px） // width: &#123;number&#125;, // 指定宽度，横向布局时默认为根据grid参数适配 // height: &#123;number&#125;, // 指定高度，纵向布局时默认为根据grid参数适配 backgroundColor: 'rgba(0,0,0,0)', // 背景颜色 dataBackgroundColor: '#eee', // 数据背景颜色 fillerColor: 'rgba(144,197,237,0.2)', // 填充颜色 handleColor: 'rgba(70,130,180,0.8)' // 手柄颜色 &#125;, // 网格 grid: &#123; x: 80, y: 60, x2: 80, y2: 60, // width: &#123;totalWidth&#125; - x - x2, // height: &#123;totalHeight&#125; - y - y2, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 1, borderColor: '#ccc' &#125;, // 类目轴 categoryAxis: &#123; position: 'bottom', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' boundaryGap: true, // 类目起始和结束两端空白策略 axisLine: &#123; // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' &#125; &#125;, axisTick: &#123; // 坐标轴小标记 show: true, // 属性show控制显示与否，默认不显示 interval: 'auto', // onGap: null, inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#333', width: 1 &#125; &#125;, axisLabel: &#123; // 坐标轴文本标签，详见axis.axisLabel show: true, interval: 'auto', rotate: 0, margin: 8, // formatter: null, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, splitLine: &#123; // 分隔线 show: true, // 默认显示，属性show控制显示与否 // onGap: null, lineStyle: &#123; // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' &#125; &#125;, splitArea: &#123; // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 // onGap: null, areaStyle: &#123; // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] &#125; &#125; &#125;, // 数值型坐标轴默认参数 valueAxis: &#123; position: 'left', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' nameTextStyle: &#123;&#125;, // 坐标轴文字样式，默认取全局样式 boundaryGap: [0, 0], // 数值起始和结束两端空白策略 splitNumber: 5, // 分割段数，默认为5 axisLine: &#123; // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' &#125; &#125;, axisTick: &#123; // 坐标轴小标记 show: false, // 属性show控制显示与否，默认不显示 inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#333', width: 1 &#125; &#125;, axisLabel: &#123; // 坐标轴文本标签，详见axis.axisLabel show: true, rotate: 0, margin: 8, // formatter: null, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, splitLine: &#123; // 分隔线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' &#125; &#125;, splitArea: &#123; // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 areaStyle: &#123; // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] &#125; &#125; &#125;, polar : &#123; center : ['50%', '50%'], // 默认全局居中 radius : '75%', startAngle : 90, splitNumber : 5, name : &#123; show: true, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, axisLine: &#123; // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#ccc', width: 1, type: 'solid' &#125; &#125;, axisLabel: &#123; // 坐标轴文本标签，详见axis.axisLabel show: false, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, splitArea : &#123; show : true, areaStyle : &#123; color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] &#125; &#125;, splitLine : &#123; show : true, lineStyle : &#123; width : 1, color : '#ccc' &#125; &#125; &#125;, // 柱形图默认参数 bar: &#123; barMinHeight: 0, // 最小高度改为0 // barWidth: null, // 默认自适应 barGap: '30%', // 柱间距离，默认为柱形宽度的30%，可设固定值 barCategoryGap : '20%', // 类目间柱形距离，默认为类目间距的20%，可设固定值 itemStyle: &#123; normal: &#123; // color: '各异', barBorderColor: '#fff', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125;, emphasis: &#123; // color: '各异', barBorderColor: 'rgba(0,0,0,0)', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125; &#125;, // 折线图默认参数 line: &#123; itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, lineStyle: &#123; width: 2, type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 &#125; &#125;, emphasis: &#123; // color: 各异, label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125;, //smooth : false, //symbol: null, // 拐点图形类型 symbolSize: 2, // 拐点图形大小 //symbolRotate : null, // 拐点图形旋转控制 showAllSymbol: false // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略） &#125;, // K线图默认参数 k: &#123; // barWidth : null // 默认自适应 // barMaxWidth : null // 默认自适应 itemStyle: &#123; normal: &#123; color: '#fff', // 阳线填充颜色 color0: '#00aa11', // 阴线填充颜色 lineStyle: &#123; width: 1, color: '#ff3200', // 阳线边框颜色 color0: '#00aa11' // 阴线边框颜色 &#125; &#125;, emphasis: &#123; // color: 各异, // color0: 各异 &#125; &#125; &#125;, // 散点图默认参数 scatter: &#123; //symbol: null, // 图形类型 symbolSize: 4, // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 图形旋转控制 large: false, // 大规模散点图 largeThreshold: 2000,// 大规模阀值，large为true且数据量&gt;largeThreshold才启用大规模模式 itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125;, emphasis: &#123; // color: '各异' label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125; &#125;, // 雷达图默认参数 radar : &#123; itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false &#125;, lineStyle: &#123; width: 2, type: 'solid' &#125; &#125;, emphasis: &#123; // color: 各异, label: &#123; show: false &#125; &#125; &#125;, //symbol: null, // 拐点图形类型 symbolSize: 2 // 可计算特性参数，空数据拖拽提示图形大小 //symbolRotate : null, // 图形旋转控制 &#125;, // 饼图默认参数 pie: &#123; center : ['50%', '50%'], // 默认全局居中 radius : [0, '75%'], clockWise : false, // 默认逆时针 startAngle: 90, minAngle: 0, // 最小角度改为0 selectedOffset: 10, // 选中是扇区偏移量 itemStyle: &#123; normal: &#123; // color: 各异, borderColor: '#fff', borderWidth: 1, label: &#123; show: true, position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, labelLine: &#123; show: true, length: 20, lineStyle: &#123; // color: 各异, width: 1, type: 'solid' &#125; &#125; &#125;, emphasis: &#123; // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, label: &#123; show: false // position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, labelLine: &#123; show: false, length: 20, lineStyle: &#123; // color: 各异, width: 1, type: 'solid' &#125; &#125; &#125; &#125; &#125;, map: &#123; mapType: 'china', // 各省的mapType暂时都用中文 mapLocation: &#123; x : 'center', y : 'center' // width // 自适应 // height // 自适应 &#125;, showLegendSymbol : true, // 显示图例颜色标识（系列标识的小圆点），存在legend时生效 itemStyle: &#123; normal: &#123; // color: 各异, borderColor: '#fff', borderWidth: 1, areaStyle: &#123; color: '#ccc'//rgba(135,206,250,0.8) &#125;, label: &#123; show: false, textStyle: &#123; color: 'rgba(139,69,19,1)' &#125; &#125; &#125;, emphasis: &#123; // 也是选中样式 // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, areaStyle: &#123; color: 'rgba(255,215,0,0.8)' &#125;, label: &#123; show: false, textStyle: &#123; color: 'rgba(139,69,19,1)' &#125; &#125; &#125; &#125; &#125;, force : &#123; // 数据map到圆的半径的最小值和最大值 minRadius : 10, maxRadius : 20, density : 1.0, attractiveness : 1.0, // 初始化的随机大小位置 initSize : 300, // 向心力因子，越大向心力越大 centripetal : 1, // 冷却因子 coolDown : 0.99, // 分类里如果有样式会覆盖节点默认样式 itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, nodeStyle : &#123; brushType : 'both', color : '#f08c2e', strokeColor : '#5182ab' &#125;, linkStyle : &#123; strokeColor : '#5182ab' &#125; &#125;, emphasis: &#123; // color: 各异, label: &#123; show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, nodeStyle : &#123;&#125;, linkStyle : &#123;&#125; &#125; &#125; &#125;, chord : &#123; radius : ['65%', '75%'], center : ['50%', '50%'], padding : 2, sort : 'none', // can be 'none', 'ascending', 'descending' sortSub : 'none', // can be 'none', 'ascending', 'descending' startAngle : 90, clockWise : false, showScale : false, showScaleText : false, itemStyle : &#123; normal : &#123; label : &#123; show : true // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, lineStyle : &#123; width : 0, color : '#000' &#125;, chordStyle : &#123; lineStyle : &#123; width : 1, color : '#666' &#125; &#125; &#125;, emphasis : &#123; lineStyle : &#123; width : 0, color : '#000' &#125;, chordStyle : &#123; lineStyle : &#123; width : 2, color : '#333' &#125; &#125; &#125; &#125; &#125;, island: &#123; r: 15, calculateStep: 0.1 // 滚轮可计算步长 0.1 = 10% &#125;, markPoint : &#123; symbol: 'pin', // 标注类型 symbolSize: 10, // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 标注旋转控制 itemStyle: &#123; normal: &#123; // color: 各异， // borderColor: 各异, // 标注边线颜色，优先于color borderWidth: 2, // 标注边线线宽，单位px，默认为1 label: &#123; show: true, position: 'inside' // 可选为'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125;, emphasis: &#123; // color: 各异 label: &#123; show: true // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125; &#125;, markLine : &#123; // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string symbol: ['circle', 'arrow'], // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 symbolSize: [2, 4], // 标线起始和结束的symbol旋转控制 //symbolRotate : null, itemStyle: &#123; normal: &#123; // color: 各异, // 标线主色，线色，symbol主色 // borderColor: 随color, // 标线symbol边框颜色，优先于color borderWidth: 2, // 标线symbol边框线宽，单位px，默认为2 label: &#123; show: false, // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom' position: 'inside', textStyle: &#123; // 默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, lineStyle: &#123; // color: 随borderColor, // 主色，线色，优先级高于borderColor和color // width: 随borderWidth, // 优先于borderWidth type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 &#125; &#125;, emphasis: &#123; // color: 各异 label: &#123; show: false // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, lineStyle : &#123;&#125; &#125; &#125; &#125;, textStyle: &#123; decoration: 'none', fontFamily: 'Arial, Verdana, sans-serif', fontFamily2: '微软雅黑', // IE8- 字体模糊并且不支持不同字体混排，额外指定一份 fontSize: 12, fontStyle: 'normal', fontWeight: 'normal' &#125;, // 默认标志图形类型列表 symbolList : [ 'circle', 'rectangle', 'triangle', 'diamond', 'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond' ], loadingText : 'Loading...', // 可计算特性配置，孤岛，提示颜色 calculable: false, // 默认关闭可计算特性 calculableColor: 'rgba(255,165,0,0.6)', // 拖拽提示边框颜色 calculableHolderColor: '#ccc', // 可计算占位提示颜色 nameConnector: ' &amp; ', valueConnector: ' : ', animation: true, animationThreshold: 2500, // 动画元素阀值，产生的图形原素超过2500不出动画 addDataAnimation: true, // 动态数据接口是否开启动画效果 animationDuration: 2000, animationEasing: 'ExponentialOut' //BounceOut","categories":[],"tags":[{"name":"echarts","slug":"echarts","permalink":"https://wxmac.github.io/tags/echarts/"}]},{"title":"二十八、手写实现","slug":"28.手写实现","date":"2020-08-09T16:00:00.000Z","updated":"2020-08-04T03:01:41.754Z","comments":true,"path":"2020/08/10/28.手写实现/","link":"","permalink":"https://wxmac.github.io/2020/08/10/28.手写实现/","excerpt":"","text":"1.手写reduce123456789101112131415Array.prototype.reduce = function(fn, val) &#123; // 很好理解，就判断val是否有传入值 for (let i = 0; i &lt; this.length; i++) &#123; // 没有传入值 if (typeof val === 'undefined') &#123; // total对应this[i], cur对应this[i + 1] // index当前索引i + 1, array数组本尊是this val = fn(this[i], this[i + 1], i + 1, this); &#125; else &#123; // 有传入val值 // total就是初始值val，之后的依次传入对应 val = fn(val, this[i], i, this); &#125; &#125; return val;&#125;; 手写call 和 apply 区别点是传递的第2个参数的形式，apply必须是数组，call则是任意类型而且可传多个参数。 123456789101112131415161718192021222324252627// call实现Function.prototype.call = function(context, ...args) &#123; // 执行上下文都保证是对象类型，如果不是就是window context = Object(context) || window; // 创建一个额外的变量当做context的属性 const fn = Symbol(); // 给这个fn属性赋值为当前的函数 context[fn] = this; // 执行函数把...args传入 const result = context[fn](...args); // 删除使用过的fn属性 delete context[fn]; // 返回函数执行结果 return result;&#125;;// apply实现Function.prototype.apply = function(context, arrArgs) &#123; context = Object(context) || window; const fn = Symbol(); context[fn] = this; // 需要把传入apply的数组进行展开运算 // 所以在这里性能会有些消耗相比call来讲 const result = context[fn](...arrArgs); delete context[fn]; return result;&#125; 手写bind123456789Function.prototype.bind = function(context, ...args) &#123; // context为要改变的执行上下文 // ...args为传入bind函数的其余参数 return (...newArgs) =&gt; &#123; // 这里返回一个新的函数 // 通过调用call方法改变this指向并且把老参和新参一并传入 return this.call(context, ...args, ...newArgs); &#125;&#125;; 手写New1234567891011121314// 手写newfunction New(Super, ...args) &#123; // 创建一个继承构造函数原型的对象 let obj = Object.create(Super.prototype); // res是表示构造函数返回的结果 let res = Super.call(obj, ...args); // 第一个条件是返回对象 // 第二个条件是返回函数 if ((res !== null &amp;&amp; typeof res === 'object') || typeof res === 'function') &#123; return res; &#125; // 返回新对象 return obj;&#125; 手写柯里化函数1234567891011// 柯里化函数function curry(fn, ...args) &#123; // 如果传递的参数还没有达到要执行的函数fn的个数 // 就继续返回新的函数(高阶函数) // 并且返回curry函数传递剩下的参数 if (args.length &lt; fn.length) &#123; return (...newArgs) =&gt; curry(fn, ...args, ...newArgs); &#125; else &#123; return fn(...args); &#125;&#125;","categories":[],"tags":[{"name":"手写实现","slug":"手写实现","permalink":"https://wxmac.github.io/tags/手写实现/"}]},{"title":"二十七、React hook系列","slug":"27.react hook系列","date":"2020-07-26T16:00:00.000Z","updated":"2020-07-29T03:00:25.785Z","comments":true,"path":"2020/07/27/27.react hook系列/","link":"","permalink":"https://wxmac.github.io/2020/07/27/27.react hook系列/","excerpt":"","text":"1.useEffect 使用useEffect获取验证码倒计时： 123456789101112131415161718192021/** * @description: 设置按钮状态 */import React, &#123; useEffect &#125; from \"react\";const [ btnConent, setBtnConent ] = useState('获取验证码') // 按钮文字const [ count, setCount ] = useState('') // // 秒数初始化为60秒const [ liked, setLiked ] = useState(true) // 文案默认为‘获取验证码‘useEffect(() =&gt; &#123; if (count &gt; 0 &amp;&amp; count &lt; 60) &#123; setBtnConent(`$&#123;count&#125;s后重发`); &#125; else &#123; clearInterval(timeChange); setLiked(true); setCount(60); setBtnConent('获取验证码'); &#125;&#125;, [count]);// 发送成功 执行倒计时let timeChange = setInterval(() =&gt; setCount(t =&gt; --t), 1000); 2.useContext 如果需要在组件之间共享状态，可以使用useContext()。 现在有俩个组件Navbar和Messages，我们希望它们之间共享状态。 1234&lt;div className=\"helloworld\"&gt; &lt;Page /&gt; &lt;HelloWorld /&gt;&lt;/div&gt; 第一步在它们的父组件上使用React的Context API，在组件外部建立一个Context。 123456789101112const TestContext = React.createContext(&#123;)&#125;;&lt;TestContext.Provider value=&#123;&#123; username: 'helloworld', &#125;&#125;&gt; &lt;div className=\"helloworld\"&gt; &lt;Page /&gt; &lt;HelloWorld /&gt; &lt;/div&gt;&lt;TestContext.Provider/&gt; TestContext.Provider提供了一个Context对象，这个对象是可以被子组件共享的。 1234567891011121314151617const Page = () =&gt; &#123; const &#123; username &#125; = useContext(TestContext); return ( &lt;div className=\"page\"&gt; &lt;p&gt;&#123; username &#125;&lt;/p&gt; &lt;/div&gt; )&#125;const HelloWorld = () =&gt; &#123; const &#123; username &#125; = useContext(TestContext); return ( &lt;div className=\"helloworld\"&gt; &lt;p&gt;1 message for &#123; username &#125;&lt;/p&gt; &lt;/div&gt; )&#125; 完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; useContext &#125; from \"react\";import ReactDOM from \"react-dom\";const TestContext= React.createContext(&#123;&#125;);// pageconst Page = () =&gt; &#123; const &#123; username &#125; = useContext(TestContext) return ( &lt;div className=\"page\"&gt; &lt;p&gt;&#123; username &#125;&lt;/p&gt; &lt;/div&gt; )&#125;// HelloWorldconst HelloWorld = () =&gt; &#123; const &#123; username &#125; = useContext(TestContext) return ( &lt;div className=\"helloworld\"&gt; &lt;p&gt;1 message for &#123; username &#125;&lt;/p&gt; &lt;/div&gt; )&#125;function App() &#123; return ( &lt;TestContext.Provider value=&#123;&#123; username: 'helloworld', &#125;&#125; &gt; &lt;div className=\"helloworld\"&gt; &lt;Page /&gt; &lt;HelloWorld /&gt; &lt;/div&gt; &lt;TestContext.Provider/&gt; );&#125;const rootElement = document.getElementById(\"root\");ReactDOM.render(&lt;App /&gt;, rootElement); 3.useReducer 对于复杂的state操作逻辑，嵌套的state的对象，推荐使用useReducer。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const initState = &#123; name: '', pwd: '', isLoading: false, error: '', isLoggedIn: false,&#125;function loginReducer(state, action) &#123; switch(action.type) &#123; case 'login': return &#123; ...state, isLoading: true, error: '', &#125; case 'success': return &#123; ...state, isLoggedIn: true, isLoading: false, &#125; case 'error': return &#123; ...state, error: action.payload.error, name: '', pwd: '', isLoading: false, &#125; default: return state; &#125;&#125;function LoginPage() &#123; const [state, dispatch] = useReducer(loginReducer, initState); const &#123; name, pwd, isLoading, error, isLoggedIn &#125; = state; const login = (event) =&gt; &#123; event.preventDefault(); dispatch(&#123; type: 'login' &#125;); login(&#123; name, pwd &#125;) .then(() =&gt; &#123; dispatch(&#123; type: 'success' &#125;); &#125;) .catch((error) =&gt; &#123; dispatch(&#123; type: 'error' payload: &#123; error: error.message &#125; &#125;); &#125;); &#125; return ( // 返回页面JSX Element )&#125;// 而使用 useState 会很混乱const [state, setState] = useState(&#123; name: '', pwd: '', isLoading: false, error: '', isLoggedIn: false,&#125;)","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://wxmac.github.io/tags/react/"},{"name":"react hook","slug":"react-hook","permalink":"https://wxmac.github.io/tags/react-hook/"}]},{"title":"二十六、Web Components","slug":"26.WebComponents","date":"2020-07-20T16:00:00.000Z","updated":"2020-07-21T03:04:26.922Z","comments":true,"path":"2020/07/21/26.WebComponents/","link":"","permalink":"https://wxmac.github.io/2020/07/21/26.WebComponents/","excerpt":"","text":"谷歌公司由于掌握了 Chrome 浏览器，一直在推动浏览器的原生组件，即 Web Components API。相比第三方框架，原生组件简单直接，符合直觉，不用加载任何外部模块，代码量小。目前，它还在不断发展，但已经可用于生产环境。兼容性不好 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width\"&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;user-card image=\"https://semantic-ui.com/images/avatar2/large/kristy.png\" name=\"User Name\" email=\"yourmail@some-email.com\" &gt;&lt;/user-card&gt; &lt;template id=\"userCardTemplate\"&gt; &lt;style&gt; :host &#123; display: flex; align-items: center; width: 450px; height: 180px; background-color: #d4d4d4; border: 1px solid #d5d5d5; box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1); border-radius: 3px; overflow: hidden; padding: 10px; box-sizing: border-box; font-family: 'Poppins', sans-serif; &#125; .image &#123; flex: 0 0 auto; width: 160px; height: 160px; vertical-align: middle; border-radius: 5px; &#125; .container &#123; box-sizing: border-box; padding: 20px; height: 160px; &#125; .container &gt; .name &#123; font-size: 20px; font-weight: 600; line-height: 1; margin: 0; margin-bottom: 5px; &#125; .container &gt; .email &#123; font-size: 12px; opacity: 0.75; line-height: 1; margin: 0; margin-bottom: 15px; &#125; .container &gt; .button &#123; padding: 10px 25px; font-size: 12px; border-radius: 5px; text-transform: uppercase; &#125; &lt;/style&gt; &lt;img class=\"image\"&gt; &lt;div class=\"container\"&gt; &lt;p class=\"name\"&gt;&lt;/p&gt; &lt;p class=\"email\"&gt;&lt;/p&gt; &lt;button class=\"button\"&gt;Follow John&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;/body&gt; &lt;script&gt; class UserCard extends HTMLElement &#123; constructor() &#123; super(); // 表示 Shadow DOM 是封闭的，不允许外部访问。 var shadow = this.attachShadow( &#123; mode: 'closed' &#125; ); var templateElem = document.getElementById('userCardTemplate'); var content = templateElem.content.cloneNode(true); content.querySelector('img').setAttribute('src', this.getAttribute('image')); content.querySelector('.container&gt;.name').innerText = this.getAttribute('name'); content.querySelector('.container&gt;.email').innerText = this.getAttribute('email'); shadow.appendChild(content); &#125; &#125; window.customElements.define('user-card', UserCard); &lt;/script&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"Web Components","slug":"Web-Components","permalink":"https://wxmac.github.io/tags/Web-Components/"},{"name":"组件化","slug":"组件化","permalink":"https://wxmac.github.io/tags/组件化/"}]},{"title":"二十五、二分法","slug":"25.二分法","date":"2020-06-30T16:00:00.000Z","updated":"2020-07-09T03:46:28.034Z","comments":true,"path":"2020/07/01/25.二分法/","link":"","permalink":"https://wxmac.github.io/2020/07/01/25.二分法/","excerpt":"","text":"二分法实现原理：二分查找可以解决已经排好序数组的查找问题：只要数组中包含target（即要查找的值），那么通过不断缩小包含target数组的范围，最终就可以找到它。 其算法流程如下： 开始，范围覆盖整个数组。 将数组的中间项与target进行比较，如果target比数组的中间项要小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。 如此，每次查找可以排除一半元素，范围缩小一半。就这样反复比较，反复缩小范围，最终就会在数组中找到target，或者确定原以为target所在的范围实际为空。 对于包含N个元素的表，整个查找过程大约要经过log(2)N次比较。 例：用递归二分法实现array.indexOf 功能（数组为正序排列）123456789101112131415161718192021function indexOf(arr,target,start,end)&#123; start = start || 0; end = end || arr.length - 1; if( start &gt; end )&#123; return -1; &#125; let mid = Math.floor((start + end) / 2); if(arr[mid] &gt; target) &#123; end = mid - 1; return indexOf(arr, target, start, end); &#125; else if(arr[mid] &lt; target)&#123; start = mid + 1; return indexOf(arr, target, start, end); &#125; else &#123; return mid; &#125;&#125;let a = [0,1,2,3,4,5,6,434,435];console.log(indexOf(a,12)); //打印结果为-1","categories":[],"tags":[{"name":"二分法","slug":"二分法","permalink":"https://wxmac.github.io/tags/二分法/"}]},{"title":"二十四、Code Helper进程占用大量CPU","slug":"24.Code Helper进程占用大量CPU","date":"2020-06-17T16:00:00.000Z","updated":"2020-06-17T06:15:39.608Z","comments":true,"path":"2020/06/18/24.Code Helper进程占用大量CPU/","link":"","permalink":"https://wxmac.github.io/2020/06/18/24.Code Helper进程占用大量CPU/","excerpt":"设备及软件： 设备：Mac 软件：VSCode 场景 在Mac中使用VSCode运行时发现项目编译非常卡顿，时间长达五六分钟以上，并且项目启动后访问页面，页面也会有明显的卡顿。","text":"设备及软件： 设备：Mac 软件：VSCode 场景 在Mac中使用VSCode运行时发现项目编译非常卡顿，时间长达五六分钟以上，并且项目启动后访问页面，页面也会有明显的卡顿。 解决方案：将以下代码插入到VSCode的setting.json中去，并退出重新启动VSCode和项目 12345678910111213141516171819\"files.exclude\": &#123; \"**/.git\": true, \"**/.svn\": true, \"**/.hg\": true, \"**/CVS\": true, \"**/.DS_Store\": true, \"**/tmp\": true, \"**/node_modules\": true, \"**/bower_components\": true, \"**/dist\": true&#125;,\"files.watcherExclude\": &#123; \"**/.git/objects/**\": true, \"**/.git/subtree-cache/**\": true, \"**/node_modules/**\": true, \"**/tmp/**\": true, \"**/bower_components/**\": true, \"**/dist/**\": true&#125; 最后CPU降下来了。","categories":[],"tags":[{"name":"vscdoe code Helper","slug":"vscdoe-code-Helper","permalink":"https://wxmac.github.io/tags/vscdoe-code-Helper/"}]},{"title":"二十三、执行上下文","slug":"23.执行上下文","date":"2020-04-30T16:00:00.000Z","updated":"2020-05-15T07:35:21.999Z","comments":true,"path":"2020/05/01/23.执行上下文/","link":"","permalink":"https://wxmac.github.io/2020/05/01/23.执行上下文/","excerpt":"执行上下文","text":"执行上下文 什么是执行上下文 当 JS 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 “准备工作”，就叫做 “执行上下文(execution context 简称 EC)” 或者也可以叫做执行环境。 执行上下文的类型 全局执行上下文——这是默认或者说是最基础的执行上下文，一个程序中只会存在一个全局上下文，它在整个 javascript 脚本的生命周期内都会存在于执行堆栈的最底部不会被栈弹出销毁。全局上下文会生成一个全局对象（以浏览器环境为例，这个全局对象是 window），并且将 this 值绑定到这个全局对象上。 函数执行上下文——每当一个函数被调用时，都会创建一个新的函数执行上下文（不管这个函数是不是被重复调用的） Eval 函数执行上下文—— 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于并不经常使用 eval，所以在这里不做分析。 作用域链 作用域 规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做 作用域链。 执行上下文和作用域有什么区别? 作用域是在声明时就已经确定了，但是执行上下文是在运行的时候才能确定的。比如函数声明时其中this的指向是不确定的，由它最终的调用时环境确定(不确定) 相关题目 第一题： 123456789101112var foo = function () &#123; console.log('foo1');&#125;foo();var foo = function () &#123; console.log('foo2');&#125;foo();// foo1 foo2 第二题： 12345678910111213foo();var foo = function foo() &#123; console.log('foo1');&#125;function foo() &#123; console.log('foo2');&#125;foo();// 由于函数声明提升更加靠前，且如果 var 定义变量的时候发现已有同名函数定义则跳过变量定义， 第三题： 12345678910111213var foo = 1;function bar () &#123; console.log(foo); var foo = 10; console.log(foo);&#125;bar();/** * bar 函数运行，内部变量申明提升，当执行代码块中有访问变量时，先查找本地作用域，找到了 foo 为 undefined ，打印出来。然后 foo 被赋值为 10 ，打印出 10。 */ // undefined 10 第四题： 123456789var foo = 1;function bar () &#123; console.log(foo); foo = 2;&#125;bar();console.log(foo);// 这题也是考察的作用域链查找，bar 里操作的 foo 本地没有定义，所以应该是上层作用域的变量。// 1 2 第五题： 12345678910var foo = 1;function bar (foo) &#123; console.log(foo); foo = 234;&#125;bar(123);console.log(foo);// 运行 bar 函数的时候将 123 数字作为实参传入，所以操作的还是本地作用域的 foo// 123 1 第六题： 12345678910111213141516171819var a = 1;function foo () &#123; var a = 2; return function () &#123; console.log(a); &#125;&#125;var bar = foo();bar();/** 这道题目主要考察闭包和函数作用域的概念，我们只要记住：函数能够访问到的上层作用域， 是在函数声明时候就已经确定了的，函数声明在哪里，上层作用域就在哪里，和拿到哪里执行没有关系。这道题目中，匿名函数被作为闭包返回并在外部调用，但它内部的作用域链引用到了父函数的变量对象中的 a ，所以作用域链查找时，打印出来的是 2。 */ // 2 第七题： 12345678910111213141516var a = 1;function foo () &#123; var a = 2; return function () &#123; console.log(this.a); &#125;&#125;var bar = foo().bind(this);//此时的this是windowbar();/** 这题考察的是执行环境中的 this 指向的问题，由于闭包内明确指定访问 this 中的 a 属性， 并且闭包被 bind 绑定在全局环境下运行，所以打印出的是全局对象中的 a。 */ // 1","categories":[],"tags":[{"name":"执行上下文","slug":"执行上下文","permalink":"https://wxmac.github.io/tags/执行上下文/"}]},{"title":"二十二、刮刮乐效果","slug":"22.刮刮乐效果","date":"2020-03-31T16:00:00.000Z","updated":"2020-03-25T05:52:35.409Z","comments":true,"path":"2020/04/01/22.刮刮乐效果/","link":"","permalink":"https://wxmac.github.io/2020/04/01/22.刮刮乐效果/","excerpt":"刮刮乐效果","text":"刮刮乐效果 模拟刮刮乐效果，自己可以配置参数 参考链接 html 123&lt;div class=\"card\"&gt; &lt;canvas id=\"canvas\" width=\"750\" height=\"280\"&gt;&lt;/canvas&gt;&lt;/div&gt; css 12345678910.card &#123; width: 375px; height: 140px; background: url('./img/ggl.png'); // 这个是刮完之后的奖品图片 background-size: 375px 140px;&#125;.card canvas &#123; width: 375px; height: 140px;&#125; js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/** @description 刮刮乐组件 * @param canvas -- canvas元素 * @param showAllPercent -- 直接全部刮开的百分 * @param coverImg -- 图片图层 -- 遮罩层 * @param coverColor -- 纯色图层，如果图片图层值不为null，则纯色图层无效 * @param doneCallback -- 全部刮开回调 * @param radius -- 擦除半径 * @param pixelRatio -- 屏幕倍数 * @param fadeOut -- 展现全部的淡出效果时间（ms） * */ class ScratchCard&#123; // 默认配置 constructor(&#123; // canvas元素 canvas = null, // 直接全部刮开的百分比 showAllPercent = 65, // 图片图层 coverImg = null, // 纯色图层，如果图片图层值不为null，则纯色图层无效 coverColor = '#ccc', // 全部刮开回调 doneCallback = () =&gt; &#123;&#125;, // 擦除半径 radius = 20, // 屏幕倍数 pixelRatio = 1, // 展现全部的淡出效果时间（ms） fadeOut = 1000 &#125;)&#123; Object.assign(this, &#123; canvas, showAllPercent, coverImg, coverColor, doneCallback, radius, pixelRatio, pixelRatio, fadeOut &#125;) this.ctx = null; this.offsetX = null; this.offsetY = null; // 是否在画布上处于按下状态 this.isDown = false; // 是否已完成刮刮卡 this.done = false; this._init(); &#125; _init()&#123; var that = this; this.ctx = this.canvas.getContext('2d'); this.offsetX = this.canvas.offsetLeft; this.offsetY = this.canvas.offsetTop; this._addEvent(); if (this.coverImg) &#123; // 如果设置的图片涂层 var coverImg = new Image(); coverImg.src = this.coverImg; // 读取图像 coverImg.onload = function() &#123; // 绘制图像 that.ctx.drawImage(coverImg, 0, 0); that.ctx.globalCompositeOperation = 'destination-out'; &#125; &#125; else &#123; // 如果没设置图片涂层，则使用纯色涂层 this.ctx.fillStyle = this.coverColor; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.globalCompositeOperation = 'destination-out'; &#125; &#125; _addEvent()&#123; this.canvas.addEventListener('touchstart', this._eventDown.bind(this), &#123; passive: false &#125;); this.canvas.addEventListener('touchend', this._eventUp.bind(this), &#123; passive: false &#125;); this.canvas.addEventListener('touchmove', this._scratch.bind(this), &#123; passive: false &#125;); this.canvas.addEventListener('mousedown', this._eventDown.bind(this), &#123; passive: false &#125;); this.canvas.addEventListener('mouseup', this._eventUp.bind(this), &#123; passive: false &#125;); this.canvas.addEventListener('mousemove', this._scratch.bind(this), &#123; passive: false &#125;); &#125; _eventDown(e)&#123; e.preventDefault(); this.isDown = true; &#125; _eventUp(e) &#123; e.preventDefault(); this.isDown = false; &#125; // 刮涂层 _scratch(e) &#123; e.preventDefault(); var that = this; if (!this.done &amp;&amp; this.isDown) &#123; if (e.changedTouches) &#123; e = e.changedTouches[e.changedTouches.length - 1]; &#125; var x = (e.clientX + document.body.scrollLeft || e.pageX) - this.offsetX || 0; var y = (e.clientY + document.body.scrollTop || e.pageY) - this.offsetY || 0; this.ctx.beginPath() this.ctx.arc(x * this.pixelRatio, y * this.pixelRatio, this.radius * this.pixelRatio, 0, Math.PI * 2); this.ctx.fill(); if (this._getFilledPercentage() &gt; this.showAllPercent) &#123; this._scratchAll() &#125; &#125; &#125; // 刮开全部涂层 _scratchAll() &#123; var that = this; this.done = true; if (this.fadeOut &gt; 0) &#123; // 先使用CSS opacity清除，再使用canvas清除 this.canvas.style.transition = 'all ' + this.fadeOut / 1000 + 's linear'; this.canvas.style.opacity = '0'; setTimeout(function() &#123; that._clear(); &#125;, this.fadeOut) &#125; else &#123; // 直接使用canvas清除 that._clear(); &#125; // 执行回调函数 this.doneCallback &amp;&amp; this.doneCallback(); &#125; // 清除全部涂层 _clear() &#123; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); &#125; // 获取刮开区域百分比 _getFilledPercentage() &#123; var imgData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height); // 存储当前cavnas画布的全部像素点信息 var pixels = imgData.data; // 存储当前canvas画布的透明像素信息 var transPixels = []; // 遍历全部像素点信息 for (var i = 0; i &lt; pixels.length; i += 4) &#123; // 把透明的像素点添加到transPixels里 if (pixels[i + 3] &lt; 128) &#123; transPixels.push(pixels[i + 3]); &#125; &#125; // 计算透明像素点的占比 return (transPixels.length / (pixels.length / 4) * 100).toFixed(2) &#125; &#125; 调用 123456789101112window.addEventListener('touchmove', function(e) &#123; e.preventDefault();&#125;, &#123;passive: false&#125;);new ScratchCard(&#123; canvas: document.getElementById('canvas'), // coverImg: './img/covimg.png', coverImg不存在则使用纯色图层 pixelRatio: 2, doneCallback: function() &#123; console.log('done') &#125;&#125;);","categories":[],"tags":[{"name":"刮刮乐","slug":"刮刮乐","permalink":"https://wxmac.github.io/tags/刮刮乐/"}]},{"title":"二十一、添加水印","slug":"21.添加水印","date":"2020-03-19T16:00:00.000Z","updated":"2020-03-25T05:52:54.395Z","comments":true,"path":"2020/03/20/21.添加水印/","link":"","permalink":"https://wxmac.github.io/2020/03/20/21.添加水印/","excerpt":"页面添加水印","text":"页面添加水印 在掘金看了一篇文章，是给页面添加水印吗，并且无法删除dom结构。很有趣。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111 /** @description 水印组件* @param container -- 添加水印容器* @param width -- canvas宽* @param height -- canvas高* @param textAlign -- 文字水平居中* @param textBaseline -- 文字垂直居中* @param font -- 字体* @param fillStyle -- 文字颜色* @param content -- 文字内容* @param rotate -- 旋转角度* @param zIndex -- 层级 * * */ class Watermark&#123; constructor(&#123; container = document.body, width = '300px', height = '200px', textAlign = 'center', textBaseline = 'middle', font = \"20px Microsoft Yahei\", fillStyle = 'rgba(184, 184, 184, 0.6)', content = '请勿外传', rotate = 30, zIndex = 1000 &#125;)&#123; Object.assign(this, &#123; container, width, height, textAlign, textBaseline, font, fillStyle, content, rotate, zIndex &#125;) this.arg = arguments[0] this.init() &#125; init()&#123; const canvas = document.createElement('canvas'); const &#123; container, width, height, textAlign, textBaseline, font, fillStyle, rotate, content, zIndex &#125; = this; canvas.setAttribute('width', width); canvas.setAttribute('height', height); const ctx = canvas.getContext(\"2d\"); ctx.textAlign = textAlign; ctx.textBaseline = textBaseline; ctx.font = font; ctx.fillStyle = fillStyle; ctx.rotate(Math.PI / 180 * rotate); ctx.fillText(content, parseFloat(width) / 2, parseFloat(height) / 2); const base64Url = canvas.toDataURL(); const __wm = document.querySelector('.__wm'); const watermarkDiv = __wm || document.createElement(\"div\"); const styleStr = ` position:absolute; top:0; left:0; width:100%; height:100%; z-index:$&#123;zIndex&#125;; pointer-events:none; background-repeat:repeat; background-image:url('$&#123;base64Url&#125;')`; this.styleStr = styleStr; watermarkDiv.setAttribute('style', styleStr); watermarkDiv.classList.add('__wm'); if (!__wm) &#123; container.style.position = 'relative'; container.insertBefore(watermarkDiv, container.firstChild); &#125; this.handleMutationObserver() &#125; /** * Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。 * */ handleMutationObserver()&#123; const &#123; container &#125; = this; const _this = this; const MutationObserver = window.MutationObserver || window.WebKitMutationObserver; if (MutationObserver) &#123; let mo = new MutationObserver(function () &#123; const __wm = document.querySelector('.__wm'); // 只在__wm元素变动才重新调用 watermark if ((__wm &amp;&amp; __wm.getAttribute('style') !== this.styleStr) || !__wm) &#123; // 避免一直触发 mo.disconnect(); mo = null; new Watermark(JSON.parse(JSON.stringify(_this.arg))); &#125; &#125;); mo.observe(container, &#123; attributes: true, subtree: true, childList: true &#125;) &#125; &#125; &#125; // 调用 new Watermark(&#123; content: '测试' &#125;)","categories":[],"tags":[{"name":"水印","slug":"水印","permalink":"https://wxmac.github.io/tags/水印/"}]},{"title":"二十、疑难问题归纳","slug":"20.疑难问题归纳","date":"2020-02-29T16:00:00.000Z","updated":"2020-09-11T10:01:40.704Z","comments":true,"path":"2020/03/01/20.疑难问题归纳/","link":"","permalink":"https://wxmac.github.io/2020/03/01/20.疑难问题归纳/","excerpt":"疑难问题归纳 – 更新中","text":"疑难问题归纳 – 更新中 一.双iframe问题 最近遇到一个需求，点击title，切换页面，但是第一个title是已有页面，第二个是新写的，于是想到了iframe。写了两个iframe，对应下面的的写法，点击title，显示对应的页面，一切都很完美。 12345678&lt;div className=&#123; `$&#123;welfaretitleIndex == 0 ? styleCss.welafreMain : ''&#125;` &#125;&gt; &lt;iframe className=&#123; styleCss.welfare_iframe &#125; title=\"1\" src=&#123; urlOne &#125; frameBorder=\"0\"&gt; &lt;/iframe&gt;&lt;/div&gt;&lt;div className=&#123; `$&#123; styleCss.blobkWelafreMain &#125; $&#123;welfaretitleIndex == 1 ? styleCss.welafreMain : ''&#125;` &#125;&gt; &lt;iframe className=&#123; styleCss.welfare_iframe &#125; title=\"2\" src=&#123; urlTwo &#125; frameBorder=\"0\"&gt; &lt;/iframe&gt;&lt;/div&gt; 但是在ios真机中，第一个已有页面没问题，当切换到第二个页面的时候，只剩title了，页面死活显示不出来，单独打开第二个页面也是没问题的。找不到原因，只能修改成点击title切换iframe的url链接，就没问题了。 1234&lt;div className=&#123; `$&#123; styleCss.blobkWelafreMain &#125; $&#123;welfaretitleIndex == 1 ? styleCss.welafreMain : ''&#125;` &#125;&gt; &lt;iframe ref=\"ifm\" className=&#123; styleCss.welfare_iframe &#125; title=\"1\" src=&#123; this.url &#125; frameBorder=\"0\"&gt; &lt;/iframe&gt; &lt;/div&gt; 二.react白屏问题 新项目是我用react重构的，刚开始很好，没出现问题。后来运营集中反馈，vivo、oppo手机在app中打开活动页面出现白屏，但是很难复现。只能去问度娘了。 解决方法一： 给打包的资源加时间戳。这个是最常用的方法，没生效。 解决方法二： 在index.js中引入’babel-polyfill’。依然没生效。 解决方法三： 在index.js中引入’core-js/stable’。在前两种没去处的情况下，目前运营还没反馈白屏问题，不知道是用户少了，还是解决了。 12import 'babel-polyfill';import 'core-js/stable'; // 解决react兼容问题。 三.微信二次分享问题 微信分享的时候，第一次分享是好的。但是通过别人分享的链接再进行分享，会出现分享失效的情况。经过排查，发现是分享的时候，微信自动给链接加上了 &amp;isappinstalled=0&amp;&amp;from=groupmessage 参数，导致分享失败，为啥失败咱也不知道。 于是采用以下解决方法：如果链接带这两个参数，encodeURIComponent一下就好了。123456let params = '';if(window.location.href.indexOf('from') != -1 || window.location.href.indexOf('isappinstalled') != -1)&#123; params = encodeURIComponent(window.location.href);&#125; else &#123; params = window.location.href;&#125; 四.ios 视频无法自动播放问题 这个之前没有遇到过，在谷歌模拟器里是好的，但是在ios微信里面，视频无法自动播放，需要做一下判断，在wx.ready调用就好了。 1234567const u = navigator.userAgent;const isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);if(isiOS)&#123; document.addEventListener(\"WeixinJSBridgeReady\",function()&#123; video.play(); &#125;,false);&#125; 或者 123456789101112131415161718const u = navigator.userAgent;const isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);if(isiOS)&#123; const video = this.refs.videoEl; // config必须存在 wx.config(&#123; // 配置信息, 即使不正确也能使用 wx.ready debug: false, appId: '', timestamp: 1, nonceStr: '', signature: '', jsApiList: [] &#125;); wx.ready(function() &#123; video.play(); &#125;)&#125; 四.html2canvas 生成 ios无法显示问题 在使用html2canvas的时候，在模拟器上显示完美，但是在ios上，图片就会显示不出来。onLoad的什么都加了，最后发现是less中rem的问题。canvas在ios中不支持rem；所以把所有的rem写死，换成了px。 new Array(10).fill({ status: 0, id: ‘’ }) 改变下标属性问题 fill()每次都是创建一个对象，指的是同一内存地址的对象，简单来说就是浅拷贝，所以会同时变更数据。 123456let initSelectArr = [...Array(10).keys()];initSelectArr = initSelectArr.map((item) =&gt; Object.assign(item, &#123; status: 0, id: ''&#125;))","categories":[],"tags":[{"name":"归纳问题","slug":"归纳问题","permalink":"https://wxmac.github.io/tags/归纳问题/"}]},{"title":"十九、父子页面通信","slug":"19.父子页面通信","date":"2020-02-19T16:00:00.000Z","updated":"2020-02-26T07:59:45.269Z","comments":true,"path":"2020/02/20/19.父子页面通信/","link":"","permalink":"https://wxmac.github.io/2020/02/20/19.父子页面通信/","excerpt":"父子页面通信","text":"父子页面通信 做了一个需求，套了一个iframe，但是iframe里面的弹窗遮罩覆盖不戴父页面，导致显示遮罩的时候，页面仍然可以滚动，试了几个方法，还是 postMessage 靠谱，可以实现即时通信。 子页面 12345678910111213141516171819 // 拓展门店handleShowOpenStore()&#123; this.setState(&#123; showOpenStore: true &#125;) window.location.href = '#container'; stopScroll(); window.parent.postMessage('stopScroll', '*');&#125;/** * 注意事项： 1.需要禁止滚动的地方 window.parent.postMessage('stopScroll', '*'); 2.恢复滚动 window.parent.postMessage('autoScroll', '*');**/ 父页面 12345678 // 防止滚动window.addEventListener('message', (e) =&gt; &#123; if(e.data &amp;&amp; e.data === 'autoScroll')&#123; autoScroll() &#125; else if(e.data &amp;&amp; e.data === 'stopScroll')&#123; stopScroll() &#125;&#125;); 后记 123/** 但是个人感觉这个方法不是很好，无奈之举，后续可以找新方法。**/","categories":[],"tags":[{"name":"postMessage","slug":"postMessage","permalink":"https://wxmac.github.io/tags/postMessage/"},{"name":"父子页面通信","slug":"父子页面通信","permalink":"https://wxmac.github.io/tags/父子页面通信/"}]},{"title":"十八、手写Promise","slug":"18.手写Promise","date":"2020-02-09T16:00:00.000Z","updated":"2020-01-17T06:20:45.646Z","comments":true,"path":"2020/02/10/18.手写Promise/","link":"","permalink":"https://wxmac.github.io/2020/02/10/18.手写Promise/","excerpt":"手写Promise","text":"手写Promise 暂未实现链式调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Promise(callback)&#123; const _this = this; this.status = 'pending'; this.value = null; this.reason = null; this.onSuccess = []; this.onFail = []; function resolve(value)&#123; if(_this.status === 'pending')&#123; _this.onSuccess.forEach((fn) =&gt; &#123; return fn(value) &#125;) _this.status = 'resolve'; &#125; &#125;; function reject(reason)&#123; if(_this.status === 'pending')&#123; _this.onFail.forEach((fn) =&gt; &#123; return fn(reason) &#125;) _this.status = 'reject'; &#125; &#125; callback(resolve,reject )&#125;;Promise.prototype.then = function ( onresolve, onreject )&#123; if(this.status === 'resolve')&#123; if( typeof onresolve === 'function' )&#123; onresolve(this.value) &#125; &#125; if(this.status === 'reject')&#123; if( typeof onreject === 'function' )&#123; onreject(this.reason) &#125; &#125; if(this.status === 'pending')&#123; if( typeof onresolve === 'function' )&#123; this.onSuccess.push(onresolve) &#125; if( typeof onreject === 'function' )&#123; this.onFail.push(onreject) &#125; &#125;&#125;;var t = new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 500);&#125;);t.then(data =&gt; &#123; console.log(data);&#125;); 参考链接","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://wxmac.github.io/tags/设计模式/"}]},{"title":"十七、四种常见的设计模式","slug":"17.四种常见的设计模式","date":"2020-02-09T16:00:00.000Z","updated":"2020-07-29T06:13:27.763Z","comments":true,"path":"2020/02/10/17.四种常见的设计模式/","link":"","permalink":"https://wxmac.github.io/2020/02/10/17.四种常见的设计模式/","excerpt":"设计模式","text":"设计模式 1.工厂模式 简单的工厂模式可以理解为解决多个相似的问题;123456789101112131415161718192021function CreatePerson(name,age,sex) &#123; let obj = new Object(); obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function()&#123; return this.name; &#125; return obj;&#125;let p1 = new CreatePerson(\"longen\",'28','男');let p2 = new CreatePerson(\"tugenhua\",'27','女');console.log(p1.name); // longenconsole.log(p1.age); // 28console.log(p1.sex); // 男console.log(p1.sayName()); // longenconsole.log(p2.name); // tugenhuaconsole.log(p2.age); // 27console.log(p2.sex); // 女console.log(p2.sayName()); // tugenhua 2.单例模式 只能被实例化(构造函数给实例添加属性与方法)一次;1234567891011121314151617181920// 单体模式let Singleton = function(name)&#123; this.name = name;&#125;;Singleton.prototype.getName = function()&#123; return this.name;&#125;// 获取实例对象let getInstance = (function() &#123; let instance = null; return function(name) &#123; if(!instance) &#123;//相当于一个一次性阀门,只能实例化一次 instance = new Singleton(name); &#125; return instance; &#125;&#125;)();// 测试单体模式的实例,所以a===blet a = getInstance(\"aa\");let b = getInstance(\"bb\"); 3.沙箱模式 只能被实例化(构造函数给实例添加属性与方法)一次;12345678let sandboxModel=(function()&#123; function sayName()&#123;&#125;; function sayAge()&#123;&#125;; return&#123; sayName:sayName, sayAge:sayAge &#125; &#125;)() 4.发布者订阅模式12345678910111213141516171819202122const EventEmit = function ()&#123; this.event = &#123;&#125;; // 定义发布者 this.event['list'] = []; this.listen = function(fn) &#123; this.event['list'].push(fn); // 订阅消息添加到缓存列表 &#125; this.trigger = function ()&#123; this.event['list'].forEach(eventListener =&gt; &#123; eventListener(...arguments); &#125;); &#125;&#125;const emit = new EventEmit();emit.listen(function(color, size) &#123; console.log(\"颜色是：\" + color); console.log(\"尺码是：\" + size);&#125;)emit.trigger(\"红色\", 40);","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://wxmac.github.io/tags/设计模式/"}]},{"title":"十六、自己实现map、indexOf、concat，来自jquery源码","slug":"16.实现map、indexOf、concat","date":"2020-01-31T16:00:00.000Z","updated":"2020-01-13T01:50:35.019Z","comments":true,"path":"2020/02/01/16.实现map、indexOf、concat/","link":"","permalink":"https://wxmac.github.io/2020/02/01/16.实现map、indexOf、concat/","excerpt":"看了jq源码，受益良多。","text":"看了jq源码，受益良多。 1.map123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const map = ( elems, callback, arg ) =&gt; &#123; let length, value, ret = []; if ( Array.isArray(elems) ) &#123; // 数组 length = elems.length; for ( let i = 0 ; i &lt; length; i++ ) &#123; value = callback( elems[ i ], i, arg ); if ( value != null ) &#123; ret.push( value ); &#125; &#125; &#125; else &#123; for ( let i in elems ) &#123; value = callback( elems[ i ], i, arg ); if ( value != null ) &#123; ret.push( value ); &#125; &#125; &#125; return ret;&#125;// 1.数组 /** const arr1 = ['a','b','c','d','e','f']; map(arr1, (item,i) =&gt; &#123; console.log(item, i) &#125;) 输出： a 0 b 1 c 2 d 3 e 4 f 5* **/ // 2.对象 /** const obj = &#123; 'a':1111, 'b':2222 &#125;; map(obj, (item,i) =&gt; &#123; console.log(item, i) &#125;) // 输出 a \"111\" b \"222\" * **/ 2.indexOf1234567891011121314151617181920const indexOf = ( list, elem ) =&gt; &#123; let len = list.length; for ( let i = 0 ; i &lt; len; i++ ) &#123; if ( list[i] === elem ) &#123; return i; &#125; &#125; return -1;&#125;;/*** * let arr = [1,2,3,4,5,6]; * console.log( indexOf(arr,2) ) * // 返回下标 1 * * * let obj = 'abcdefg'; * console.log( indexOf(obj,c) ) * // 返回下标 2*/ 3.concat12345678910111213141516const merge = ( first, second ) =&gt; &#123; let len = second.length, i = first.length; for (let j = 0 ; j &lt; len; j++ ) &#123; first[ i++ ] = second[ j ]; &#125; first.length = i; return first;&#125;;/** * let arr1 = [1,2,3,4,5,6]; * let arr2 = ['a','b','c','d','e','f']; * console.log( merge(arr1,arr2) ) * 输出： [1, 2, 3, 4, 5, 6, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] * **/","categories":[],"tags":[{"name":"map","slug":"map","permalink":"https://wxmac.github.io/tags/map/"}]},{"title":"十五、利用less实现一个雪花❄️","slug":"15.利用less实现一个雪花❄️","date":"2020-01-29T16:00:00.000Z","updated":"2020-01-06T06:37:17.737Z","comments":true,"path":"2020/01/30/15.利用less实现一个雪花❄️/","link":"","permalink":"https://wxmac.github.io/2020/01/30/15.利用less实现一个雪花❄️/","excerpt":"利用less实现一个雪花 看了一篇文章，里面用less实现了一个雪花，里面less的用法让我眼前一亮，该看看less的其他用法了。","text":"利用less实现一个雪花 看了一篇文章，里面用less实现了一个雪花，里面less的用法让我眼前一亮，该看看less的其他用法了。 html - 实现雪花，html结构是很重要的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;figure className=&#123; styleCss.snowflake &#125;&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/figure&gt; less - 实现雪花的核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243.snowflake&#123; font-size: 100px; color: snow; width: 4em; height: 4em; outline: 1px dashed yellow; position: relative; display: flex; justify-content: center; div &#123; width: 0.1em; height: 2em; background-color: currentColor; border-radius: 0.05em; position: absolute; transform-origin: bottom; transform: rotate(calc(var(--n) * 60deg)); display: flex; flex-direction: column; align-items: center; span:nth-child(1),span:nth-child(2),span:nth-child(3),span:nth-child(4) &#123; width: calc(var(--slide-width)); height: calc(var(--slide-width)); border: 0.1em solid; border-width: 0.1em; border-style: none solid solid none; border-radius: 0.05em; transform: rotate(45deg); &#125; span:nth-child(1)&#123;--slide-width:0.2rem;&#125; span:nth-child(2)&#123;--slide-width:0.5rem;&#125; span:nth-child(3)&#123;--slide-width:0.4rem;&#125; span:nth-child(4)&#123;--slide-width:0.3rem;&#125; &#125; div:nth-child(1) &#123;--n: 1;&#125; div:nth-child(2) &#123;--n: 2;&#125; div:nth-child(3) &#123;--n: 3;&#125; div:nth-child(4) &#123;--n: 4;&#125; div:nth-child(5) &#123;--n: 5;&#125; div:nth-child(6) &#123;--n: 6;&#125;&#125;","categories":[],"tags":[{"name":"less","slug":"less","permalink":"https://wxmac.github.io/tags/less/"},{"name":"雪花","slug":"雪花","permalink":"https://wxmac.github.io/tags/雪花/"}]},{"title":"十四、eventloop事件循环","slug":"14.eventloop事件循环","date":"2020-01-24T16:00:00.000Z","updated":"2020-07-22T08:04:49.996Z","comments":true,"path":"2020/01/25/14.eventloop事件循环/","link":"","permalink":"https://wxmac.github.io/2020/01/25/14.eventloop事件循环/","excerpt":"","text":"eventloop事件循环 js是单线程执行的，eventloop事件循环就是解决javaScript单线程运行阻塞的一种机制。 消息队列12345678910111213141516const bar = () =&gt; console.log('bar')const baz = () =&gt; console.log('baz')const foo = () =&gt; &#123; console.log('foo') setTimeout(bar, 0) baz()&#125;foo()该代码会打印：foobazbar 当调用 setTimeout() 时，浏览器或 Node.js 会启动定时器。 当定时器到期时（在此示例中会立即到期，因为将超时值设为 0），则回调函数会被放入“消息队列”中。 在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 onLoad 这样的 DOM 事件也如此。 事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。 ES6 作业队列 ECMAScript 2015 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。 当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。 有个游乐园中过山车的比喻很好：消息队列将你排在队列的后面（在所有其他人的后面），你不得不等待你的回合，而工作队列则是快速通道票，这样你就可以在完成上一次乘车后立即乘坐另一趟车。 1234567891011121314151617181920const bar = () =&gt; console.log('bar')const baz = () =&gt; console.log('baz')const foo = () =&gt; &#123; console.log('foo') setTimeout(bar, 0) new Promise((resolve, reject) =&gt; resolve('应该在 baz 之后、bar 之前') ).then(resolve =&gt; console.log(resolve)) baz()&#125;foo()这会打印：foobaz应该在 baz 之后、bar 之前bar 这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。 一、宏任务和微任务 在 js 中，任务分为宏任务(macrotask)和微任务(microtask)，这两个任务分别维护一个队列，均采用先进先出(类似放盘子)的策略进行执行，同步执行的任务都在宏任务上执行。 1. 宏任务主要有：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)。 2. 微任务主要有：Promise.then、 MutationObserver、 process.nextTick(Node.js 环境)。 宏任务是由多个微任务组成的，先执行微任务，后执行宏任务。 二、运行机制 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 1. 执行一个宏任务（栈中没有就从事件队列中获取） 2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）三、🌰 按消息队列 和 作业队列 思路更简单。先执行作业队列， 后执行 作业队列。 1.尝试输出以下代码12345678910111213141516171819console.log(1);setTimeout(function() &#123; console.log(2);&#125;, 0);new Promise(function(resolve) &#123; console.log(3); resolve(Date.now());&#125;).then(function() &#123; console.log(4);&#125;);console.log(5);setTimeout(function() &#123; new Promise(function(resolve) &#123; console.log(6); resolve(Date.now()); &#125;).then(function() &#123; console.log(7); &#125;);&#125;, 0); 那么以上代码的执行过程是什么样的呢？ - 1 3 5 4 2 6 7 1. 代码从上往下执行，首先输出 1， 2. 遇到setTimeout，推入宏任务，待后面执行， 3. 遇到Promise，首先打印 3，把then后面的推入微任务， 4. 直接打印 5， 6. 遇到setTimeout，推入宏任务，待后面执行， 7. 微任务按顺序执行，打印 4， 8. 宏任务按顺序执行，打印 2，任务队列中没有微任务，下一步， 9. 执行宏任务，打印 6，把then后面的推入微任务， 10. 执行微任务，打印 7，完成。2.尝试输出以下代码 123456789101112131415161718192021222324252627async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');/** await async2()等价于 async2().then(() =&gt; &#123; console.log('async1 end'); &#125;)**/ 12345678910/* script start async1 start async2 promise1 script end async1 end promise2 setTimeout*/ 解析 1.首先定义了两个async，没调用，直接下一步， 2.执行 script start， 3.遇到setTimeout， 推入宏任务， 3.执行 async1函数,在await之前的代码是立即执行的，所以会立即输出 async1 start,遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2,打印async2， 4.往下走，遇到Promise，打印promise1， then推入微任务， 5.往下走，打印script end， 6.继续按顺序执行之前任务队列中的微任务，先打印async1 end， 再打印 promise2， 7.执行宏任务，打印setTimeout。","categories":[],"tags":[{"name":"eventloop","slug":"eventloop","permalink":"https://wxmac.github.io/tags/eventloop/"},{"name":"事件循环","slug":"事件循环","permalink":"https://wxmac.github.io/tags/事件循环/"}]},{"title":"十三、数组和字符串相关方法","slug":"13.数组和字符串相关方法","date":"2020-01-19T16:00:00.000Z","updated":"2020-01-02T01:48:57.442Z","comments":true,"path":"2020/01/20/13.数组和字符串相关方法/","link":"","permalink":"https://wxmac.github.io/2020/01/20/13.数组和字符串相关方法/","excerpt":"一：数组方法","text":"一：数组方法 1.splice() – 拼接数组 1234567891011121314151617181920212223242526272829// 使用1： 删除元素const arr = [1,2,3];arr.splice(0,1); // [1]/** 第一个参数（0）定义了删除元素的位置（下标）; 第二个参数（1）定义应删除多少元素; 该方法返回一个包含已删除项的数组,改变原数组 [2,3]**/// 使用2： 向指定位置添加元素const arr = [1,2,3];arr.splice(2,0,5,6); // []/** 第一个参数（2）定义了应添加新元素的位置（下标）; 第二个参数（0）定义应删除多少元素; 其余参数（'5','6'）定义要添加的新元素. 该方法返回一个包含已删除项的数组,改变原数组 [1, 2, 5, 6, 3]**/// 使用3： 向指定位置替换元素const arr = [1,2,3];arr.splice(2,1,5,6); // [3]/** 第一个参数（2）定义了应添加新元素的位置（下标）; 第二个参数（1）定义应删除多少元素; 其余参数（'5','6'）定义要添加的新元素. 该方法返回一个包含已删除项的数组,改变原数组 [1, 2, 5, 6]**/ 2.slice() – 裁剪数组 12345678910 // 使用1： 只有一个参数 -- 从下标 1 开始切出一段数组，结束参数被省略，则 slice() 会切出数组的剩余部分 const arr = [1,2,3,4,5]; arr.slice(1); // [2,3,4,5]; // 使用1： 两个参数 -- 从下标 1 到 3 切出一段数组（不包括结束参数） const arr = [1,2,3,4,5]; arr.slice(1,3); // [2,3]; // 该方法创建新数组,不会改变原数组 3.toString()、join() – 把数组转换为字符串 123const arr = [1,2,3];arr.toString(); // 1,2,3arr.join('-'); // 1-2-3 join() 可以规定分隔符 - 4.pop() – 方法从数组中删除最后一个元素 123456789101112131415161718192021 const arr = [1,2,3]; arr.pop(); // 3 // 该方法返回被删除的元素, 改变原数组 [1,2]/** 使用栈的思想扁平化数组： const flat = (arr) =&gt; &#123; const stack = [...arr]; const res = []; while( stack.length )&#123; const next = stack.pop(); if(Array.isArray(next))&#123; stack.push(...next); &#125; else &#123; res.push(next) &#125; &#125; return res.reverse();&#125;*/ 5.push() – 向数组末尾添加一个新的元素 123const arr = [1,2,3];arr.push(4); // 4// 该方法返回新数组的长度 length, 改变原数组 [1,2,3,4] 6.shift() – 删除首个数组元素 123const arr = [1,2,3];arr.shift(); // 1// 该方法返回被删除的元素, 改变原数组 [2,3] 7.unshift() – 向数组头部添加新元素 123const arr = [1,2,3];arr.unshift(9); // 4// 该方法返回新数组的长度 length, 改变原数组 [9,1,2,3] 8.concat() – 合并数组 1234const arr = [1,2,3];const newArr = [4,5,6];arr.concat(newArr); // [1,2,3,4,5,6]// 该方法不会更改现有数组，它总是返回一个新数组 [1,2,3,4,5,6] 9.sort() – 数组排序 1234567891011121314151617181920212223242526const arr = [2,1,3];arr.sort(); // [1,2,3]arr.sort((a,b) =&gt; b - a) // [3,2,1]// 该方法不会更改现有数组，它总是返回一个新数组 [1,2,3,4,5,6]/** // 1.排序 const compare = (property,desc) =&gt; &#123; return function (a, b) &#123; var value1 = a[property]; var value2 = b[property]; if(desc)&#123; // 升序排列 return value1 - value2; &#125;else&#123; // 降序排列 return value2 - value1; &#125; &#125; &#125; 2. 查找最大值 Math.max.apply(null, arr); 3. 查找最小值 Math.min.apply(null, arr);*/ 9.reverse() – 反转数组 12const arr = [1,2,3];arr.reverse(arr); // [3,2,1] 二：字符串方法1.indexOf() – 返回字符串中指定文本 首次 出现的索引（位置） 123const str = 'indexOf';str.indexOf('index'); // 0// 如果未找到文本， 返回 -1 2.lastIndexOf() – 返回指定文本在字符串中 最后 一次出现的索引 123const str = 'lastIndexOf';str.lastIndexOf('last'); // 0// 如果未找到文本， 返回 -1 3.slice()、substring()、substr() – 裁剪字符串 1234//有三种提取部分字符串的方法： - slice(start, end) - substring(start, end) - substr(start, length) slice() – 提取字符串的某个部分并在新字符串中返回被提取的部分 12345678const str = '提取字符串';str.slice(2,3); // '字'// 如果某个参数为负，则从字符串的结尾开始计数。str.slice(-3,-2); // '字'// 如果省略第二个参数，则该方法将裁剪字符串的剩余部分：str.slice(1); // '取字符串' substring() – 类似于 slice(), 但是无法接受负的索引 12const str = '提取字符串';str.substring(2,3); // '字' substr() – 类似于 slice(), 但是第二个参数规定被提取部分的长度 1234567const str = '提取字符串';str.substring(2,3); // '字符串'// 如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分。 str.substring(2); // '取字符串'//如果首个参数为负，则从字符串的结尾计算位置。第二个参数不能为负，因为它定义的是长度。 4.replace() – 用另一个值替换在字符串中指定的值 123const str = 'hello world';str.replace(/l/ig,'替换'); // \"he替换替换o wor替换d\" // 返回的是新字符串。 5.toUpperCase() – 把字符串转换为大写 12const str = 'hello world';str.toUpperCase(); // \"HELLO WORLD\" 6.toLowerCase() – 把字符串转换为小写 12const str = 'HELLO WORLD';str.toLowerCase(); // \"hello world\" 7.concat() – 连接两个或多个字符串 123const str = 'hello';const str2 = 'world';str.concat(str2); // \"helloworld\" 8.trim() – 删除字符串两端的空白符： 12const str = ' hello world ';str.trim(); // \"hello world\" 9.split() – 将字符串转换为数组 12const str = '1,2,3,4';str.split(','); // [\"1\", \"2\", \"3\", \"4\"]","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://wxmac.github.io/tags/字符串/"},{"name":"字符串方法","slug":"字符串方法","permalink":"https://wxmac.github.io/tags/字符串方法/"},{"name":"数组","slug":"数组","permalink":"https://wxmac.github.io/tags/数组/"},{"name":"数组方法","slug":"数组方法","permalink":"https://wxmac.github.io/tags/数组方法/"}]},{"title":"十二、数组去重","slug":"12.数组去重","date":"2020-01-14T16:00:00.000Z","updated":"2020-01-17T06:35:21.535Z","comments":true,"path":"2020/01/15/12.数组去重/","link":"","permalink":"https://wxmac.github.io/2020/01/15/12.数组去重/","excerpt":"数组去重","text":"数组去重 reduce + find 1234567891011121314const data = [1,2,3,4,5,1,2,6,7];const distinct = (arr) =&gt; &#123; return arr.reduce((total,curr, index) =&gt; &#123; // find返回数组中满足提供的测试函数的第一个元素的值 const exist = total.find((item) =&gt; item === curr ); if(!exist)&#123; total.push(curr) &#125; return total &#125;,[]) &#125;console.log(distinct(data)); // // [1, 2, 3, 4, 5, 6, 7]// 利用find查找是否存在相同元素，如果不存在就push到数组里 1.filter + indexOf 123456789const arr = [1,2,3,4,5,1,2];const distinct = (arr) =&gt; &#123; return arr.filter((item,index) =&gt; &#123; return arr.indexOf(item) === index &#125;)&#125;;console.log(distinct(arr));// [1, 2, 3, 4, 5]// 利用indexOf检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素 双重for循环 123456789101112131415const data = [1,2,3,4,5,1,2];const distinct = (arr) =&gt; &#123; for( let i = 0; i &lt; arr.length; i++ )&#123; for(let j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] === arr[j])&#123; arr.splice(j, 1); j--; &#125; &#125; &#125; return arr;&#125;; console.log(distinct(data)); // [1, 2, 3, 4, 5] // 先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组 ES6 中的 Set 去重 12345const data = [1,2,3,4,5,1,2];const distinct = (arr) =&gt; &#123; return [...new Set(arr)]&#125;;console.log(distinct(data)); // [1, 2, 3, 4, 5] 例子🌰 12345678910111213141516171819202122232425262728293031/** （携程）算法手写题 已知如下数组： var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 编写一个程序将数组扁平化并去除其中重复部分数据，最终得到一个升序且不重复的数组**/var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];const flat = (arr) =&gt; &#123; // 扁平化数组 return arr.reduce((total, curr) =&gt; &#123; return Array.isArray(curr) ? total.concat(flat(curr)) : total.concat(curr) &#125;,[])&#125;const newArr = flat(arr);const removeRepeat = (arr) =&gt; &#123; // 数组去重 return arr.filter((item,index) =&gt; &#123; return arr.indexOf(item) === index &#125;)&#125;const res = removeRepeat(newArr)console.log(res.sort((a,b) =&gt; a - b))// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]/** 简便解法： Array.from( new Set( arr.flat(Infinity)) ).sort(( a, b )=&gt;a - b)**/","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"https://wxmac.github.io/tags/数组/"},{"name":"数组去重","slug":"数组去重","permalink":"https://wxmac.github.io/tags/数组去重/"}]},{"title":"十一、九宫格抽奖","slug":"11.九宫格抽奖","date":"2020-01-09T16:00:00.000Z","updated":"2019-12-26T05:56:43.066Z","comments":true,"path":"2020/01/10/11.九宫格抽奖/","link":"","permalink":"https://wxmac.github.io/2020/01/10/11.九宫格抽奖/","excerpt":"九宫格抽奖","text":"九宫格抽奖 1.js实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130class Lottery&#123; constructor(&#123; startBtnEl, giftAllEl, prizeIndex, delayTime, animateTime, clearActive, _luckyTimes, haveChange, successCallback = () =&gt; &#123;&#125; &#125;)&#123; Object.assign(this,&#123; startBtnEl, // 开始按钮 giftAllEl, // 所有奖品公共class prizeIndex: prizeIndex || '谢谢参与', // 抽中奖品下标 _luckyTimes: _luckyTimes || 0, // 抽奖次数 delayTime: delayTime || 3000, // 延时多少秒得到结果 animateTime: animateTime || 200, // 动画时间 clearActive: clearActive || true, // 清除状态 haveChange: haveChange || false, // 是否还有抽奖机会 successCallback // 抽中奖品回调 &#125;) this.$prizeItemsEl = null, // 奖品 this.lotteryPrizeIndex = 0, // 九宫格对应下标 this.timer = null, // 定时器 this.init() &#125; init()&#123; this.$lotteryStartEl = document.querySelector(this.startBtnEl) this.$prizeItemsEl = document.querySelectorAll(this.giftAllEl) // 🏅奖品 this.initStartEvent() &#125; initStartEvent()&#123; let haveChange = this.haveChange; const el = this.$lotteryStartEl el.onclick = () =&gt; &#123; if (!el.classList.contains('disabled') ) &#123; this.setStartBtnStatus(true) if (haveChange) &#123; // 有抽奖机会，得到抽奖结果 this.getTargetPrize() this.handleStartAnimate() &#125; else &#123; // 没有抽奖机会了 console.log('没有抽奖机会了') &#125; &#125; &#125; &#125; // 开始抽奖动画 handleStartAnimate()&#123; this.lotteryPrizeIndex = 0 this.timer = setInterval(() =&gt; &#123; this.lotteryPrizeIndex = this.lotteryPrizeIndex === 8 ? 1 : this.lotteryPrizeIndex + 1; this.addPrizeMask(); // 这里很巧妙，lottery-prize_item_index 和html一致 document.querySelector(`.lottery-prize_item_$&#123;this.lotteryPrizeIndex&#125;`).classList.remove('mask') &#125;, this.animateTime) return this.timer &#125; // 添加所有奖品的遮罩状态 addPrizeMask()&#123; for (let i = 0, l = this.$prizeItemsEl.length; i &lt; l; i++) &#123; this.$prizeItemsEl[i].classList.add('mask') &#125; &#125; // 清除所有奖品的遮罩状态 clearPrizeActive () &#123; for (let i = 0, l = this.$prizeItemsEl.length; i &lt; l; i++) &#123; this.$prizeItemsEl[i].classList.remove('mask') &#125; &#125; // 抽奖结果 getTargetPrize()&#123; // 模拟随机得到一个结果 let prizeIndex = this.prizeIndex; if(prizeIndex == '谢谢参与')&#123; return &#125; if(prizeIndex == 0 || prizeIndex == 9)&#123; prizeIndex = 1 &#125; // 延时几秒得到结果 setTimeout(() =&gt; &#123; typeof this.successCallback === 'function' &amp;&amp; this.successCallback(prizeIndex) this.stopPrizeAnimate(prizeIndex) &#125;, this.delayTime) &#125; // 关闭抽奖动画 stopPrizeAnimate(index)&#123; if (index) &#123; let stopTimer = null stopTimer = setInterval(() =&gt; &#123; if (index === this.lotteryPrizeIndex ) &#123; clearInterval(stopTimer) clearInterval(this.timer) this.setStartBtnStatus() if (this.clearActive) &#123; //this.clearPrizeActive() &#125; &#125; &#125;, 100) &#125; else &#123; this.setStartBtnStatus() clearInterval(this.timer) this.clearPrizeActive() &#125; &#125; // 按钮状态 setStartBtnStatus (status) &#123; if (status) &#123; this.$lotteryStartEl.classList.add('disabled') &#125; else if (this._luckyTimes) &#123; this.$lotteryStartEl.classList.remove('disabled') &#125; &#125;&#125;new Lottery(&#123; startBtnEl: '.J_lottery-start', giftAllEl: '.lottery-prize_item', prizeIndex:2 , haveChange: true, _luckyTimes: 2, successCallback(prizeIndex)&#123; console.log('prizeIndex---&gt;',prizeIndex) &#125;&#125;) 2.html结构 123456789101112131415161718192021222324252627&lt;div class=\"lottery-prize_items\"&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_1\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_2\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_3\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_8\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-start J_lottery-start \"&gt;GO! &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_4\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_7\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_6\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"lottery-prize_item lottery-prize_item_5\"&gt; &lt;img src=\"./下载.jpeg\" alt=\"\"&gt; &lt;/div&gt;&lt;/div&gt; 3.css 1234567891011121314151617181920212223242526272829303132333435363738394041424344*&#123;margin: 0; padding: 0;&#125; .lottery-prize_items&#123; width: 430px; height:400px; display: flex; flex-wrap: wrap; justify-content: space-between; align-content: space-between; padding: 20px; background-color: #446CD3; border-radius: 5px; &#125; .lottery-prize_items .lottery-prize_item, .lottery-prize_items .lottery-start&#123; width: 120px; height: 120px; background: #D2DAFF; background: #fff; border-radius: 5px; position: relative; display: flex; align-items: center; justify-content: center; user-select: none; overflow: hidden; &#125; .lottery-prize_items .mask:after&#123; display: block; content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 120px; background: rgba(94, 139, 255, 0.4); border-radius: 5px; &#125; .lottery-prize_items .disabled&#123; background: #C4C6CA; color: #fff; &#125; .lottery-prize_items .lottery-prize_item img&#123; width: 120px; height: 120px; &#125;","categories":[],"tags":[{"name":"lottery","slug":"lottery","permalink":"https://wxmac.github.io/tags/lottery/"},{"name":"抽奖","slug":"抽奖","permalink":"https://wxmac.github.io/tags/抽奖/"}]},{"title":"十、节日头像小挂件","slug":"10.节日头像小挂件","date":"2020-01-04T16:00:00.000Z","updated":"2019-12-26T05:18:57.621Z","comments":true,"path":"2020/01/05/10.节日头像小挂件/","link":"","permalink":"https://wxmac.github.io/2020/01/05/10.节日头像小挂件/","excerpt":"实现思路：参考大佬链接 上传的头像和小挂件要匹配到一起，利用canvas生成图片，并下载。","text":"实现思路：参考大佬链接 上传的头像和小挂件要匹配到一起，利用canvas生成图片，并下载。 实现代码 首先把html写好，再加上一顿CSS操作，样式如下12345678910111213// htmlconst &#123; targetUrl, loading &#125; = this.state;&lt;div className=&#123; `$&#123;styleCss.avatarBox&#125; ` &#125;&gt;&lt;div className=&#123; `$&#123;styleCss.avatar_main&#125; $&#123;loading ? styleCss.loader : ''&#125;` &#125;&gt; &lt;img onClick=&#123; () =&gt; this.handleArrowChange('LEFT') &#125; className=&#123; styleCss.arrowLeft &#125; src=&#123; require('@/assets/img/avatar/arrowLeft.svg') &#125; alt=\"\"/&gt; &lt;img onClick=&#123; () =&gt; this.handleArrowChange('RIGHT') &#125; className=&#123; styleCss.arrowRight &#125; src=&#123; require('@/assets/img/avatar/arrowRight.svg') &#125; alt=\"\"/&gt;&lt;/div&gt;&lt;input type=\"file\" accept=\"image/*\" onChange=&#123; (e) =&gt; this.handleUploadImgInit(e) &#125;/&gt;&lt;img src=&#123; targetUrl &#125; alt=\"\" className=&#123; styleCss.avatar_target &#125;/&gt;&lt;/div&gt;&lt;canvas className=&#123; styleCss.canvas &#125; ref=\"canvas\" /&gt; 核心代码 1、定义相关变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const CANVANS_SIZE = 256;// 小挂件数组,style位置和大小信息需要自己试验一下const imgSourceList = [&#123; source: require('@/assets/img/avatar/1.png'), style: &#123; width: 108, height: 88, top: `$&#123;CANVANS_SIZE - 88&#125;`, left: `$&#123;CANVANS_SIZE - 108&#125;` &#125;&#125;, &#123; source: require('@/assets/img/avatar/2.png'), style: &#123; width: 128, height: 128, top: `$&#123;CANVANS_SIZE - 108&#125;`, left: `$&#123;CANVANS_SIZE - 118&#125;` &#125;&#125;, &#123; source: require('@/assets/img/avatar/3.png'), style: &#123; width: 96, height: 108, top: `$&#123;CANVANS_SIZE - 128&#125;`, left: `$&#123;CANVANS_SIZE - 86&#125;` &#125;&#125;, &#123; source: require('@/assets/img/avatar/4.png'), style: &#123; width: CANVANS_SIZE, height: 226, top: -38, left: 0 &#125;&#125;, &#123; source: require('@/assets/img/avatar/5.png'), style: &#123; width: 100, height: 126, top: 0, left: CANVANS_SIZE / 3 &#125;&#125;];this.state=&#123; decorationCurrent: imgSourceList[0], // 小挂件1 decorationList: imgSourceList, // 小挂件数组 currentIndex:0, // 当前挂件下标 loading:false // 是否显示加载&#125; 2、初始化canvas 1234567891011121314151617 componentDidMount()&#123; const &#123; decorationCurrent &#125; = this.state; // 初始化挂载小挂件 this.handleMakeImage(null, decorationCurrent).then(targetUrl =&gt; &#123; this.setState(&#123; targetUrl &#125;); &#125;);// 挂载canvas this.initCanvas(); &#125; initCanvas() &#123; const &#123; canvas &#125; = this.refs; canvas.width = CANVANS_SIZE; canvas.height = CANVANS_SIZE; &#125; 3、上传图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 async handleUploadImgInit(e)&#123; const _this = this; const target = e.target; const &#123; canvas &#125; = this.refs; const &#123; decorationCurrent &#125; = this.state; const context = canvas.getContext('2d'); const files = e.target.files[0]; // 上传的图片 const base64Url = await this.handleBase64Img(files); const imgObj = await this.createImage(base64Url);// 调整用户图片尺寸// 无论宽大于高还是宽小于高，都会进行等比缩放 const type = imgObj.width - imgObj.height; if (type &gt; 0) &#123; // 宽 &gt; 高 const w = imgObj.width * CANVANS_SIZE / imgObj.height; context.drawImage(imgObj, 0, 0, w, CANVANS_SIZE); &#125; else if (type &lt; 0) &#123; // 宽 &lt; 高 const h = imgObj.height * CANVANS_SIZE / imgObj.width; context.drawImage(imgObj, 0, 0, CANVANS_SIZE, h); &#125; else &#123; context.drawImage(imgObj, 0, 0, CANVANS_SIZE, CANVANS_SIZE);&#125;// canvas转图片 const imgUrl = canvas.toDataURL('image/png'); this.setState(&#123; imgUrl:imgUrl &#125;,() =&gt; &#123; target.value = ''; // 可以重复上传同一张图片 &#125;) this.handleMakeImage(imgUrl, decorationCurrent).then(targetUrl =&gt; &#123; this.setState(&#123; targetUrl &#125;); &#125;); &#125; // 上传图片base64转化 handleBase64Img(files)&#123; return new Promise((resolve,reject) =&gt; &#123; let reads = new FileReader(); reads.readAsDataURL(files); reads.onload = function(e) &#123; resolve(this.result); &#125;; &#125;) &#125; // 创建图片 createImage(imgUrl) &#123; return new Promise((resolve, rejest) =&gt; &#123; const imgObj = new Image(); imgObj.src = imgUrl; imgObj.onload = (e) =&gt; &#123; resolve(imgObj); &#125;; &#125;); &#125; 4、把头像和挂件组合在一起，生成图片链接（关键） 123456789101112131415161718192021222324252627/** * @param &#123; string &#125; imgUrl -- 处理的用户图片url * @param &#123; object &#125; decorationCurrent -- 小挂件 * */ async handleMakeImage(imgUrl, decorationCurrent)&#123; if (!(imgUrl || decorationCurrent)) &#123; return ''; &#125; const &#123; source, style &#125; = decorationCurrent; const &#123; width, height, top, left &#125; = style; const &#123; canvas &#125; = this.refs; this.clearCanvas(canvas); const context = canvas.getContext('2d'); if (imgUrl) &#123; const bgImg = await this.createImage(imgUrl); context.drawImage(bgImg, 0, 0, bgImg.width, bgImg.height); &#125; if (decorationCurrent &amp;&amp; source) &#123; const imgObj = await this.createImage(source); context.drawImage(imgObj, left, top, width, height); &#125; const targetUrl = canvas.toDataURL('image/png'); return targetUrl;&#125;clearCanvas(targetCanvans) &#123; let ctx = targetCanvans.getContext('2d'); ctx.clearRect(0, 0, targetCanvans.width, targetCanvans.height);&#125; 5、左右切换小挂件 12345678910111213141516171819202122232425handleArrowChange(type)&#123; const &#123; decorationList &#125; = this.state; const length = decorationList.length - 1; let index = 0; this.setState((prvState) =&gt;&#123; if(type === 'LEFT')&#123; // 左 index = --prvState.currentIndex &lt; 0 ? length : prvState.currentIndex; &#125; else &#123; // 右 index = ++prvState.currentIndex &gt; length ? 0 : prvState.currentIndex; &#125; return &#123; loading:true, currentIndex:index, decorationCurrent: imgSourceList[index], &#125; &#125;, () =&gt; &#123; const &#123; imgUrl, decorationCurrent&#125; = this.state; this.handleMakeImage(imgUrl, decorationCurrent).then(targetUrl =&gt; &#123; this.setState(&#123; targetUrl, loading:false, &#125;); &#125;); &#125;) &#125;","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://wxmac.github.io/tags/canvas/"},{"name":"小挂件","slug":"小挂件","permalink":"https://wxmac.github.io/tags/小挂件/"}]},{"title":"九、将具有相同属性的对象合并到一个数组中","slug":"9.属性合并","date":"2019-12-31T16:00:00.000Z","updated":"2020-03-05T03:07:29.053Z","comments":true,"path":"2020/01/01/9.属性合并/","link":"","permalink":"https://wxmac.github.io/2020/01/01/9.属性合并/","excerpt":"将具有相同属性的对象合并到一个数组中","text":"将具有相同属性的对象合并到一个数组中 新年新气象，新的一年，继续加油。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let data = [ &#123; 'group_name':'A', 'type': 'apple' &#125;, &#123; 'group_name':'A', 'type': 'almond' &#125;, &#123; 'group_name':'B', 'type': 'banana' &#125;, &#123; 'group_name':'B', 'type': 'bennet' &#125;];//代码实现// &#123; group_name, type &#125; = currValueconst res = data.reduce( (prv, currValue ) =&gt; &#123; const exist = prv.find(item =&gt; item.type == currValue.group_name); if (exist) &#123; exist[\"data\"].push( currValue ); &#125; else &#123; prv.push(&#123; type: currValue.group_name, data: [ currValue ]&#125;) &#125; return prv;&#125;, []);console.log(res)// 打印结果如下：[ &#123; 'type':A, data:[ &#123; 'group_name':'A', 'type': 'apple' &#125;, &#123; 'group_name':'A', 'type': 'almond' &#125;, ] &#125;, &#123; 'type':B, data:[ &#123; 'group_name':'B', 'type': 'banana' &#125;, &#123; 'group_name':'B', 'type': 'bennet' &#125; ] &#125;]","categories":[],"tags":[{"name":"reduce","slug":"reduce","permalink":"https://wxmac.github.io/tags/reduce/"},{"name":"数组","slug":"数组","permalink":"https://wxmac.github.io/tags/数组/"}]},{"title":"八、扁平化数组","slug":"8.扁平化数组","date":"2019-12-29T16:00:00.000Z","updated":"2020-02-26T08:45:10.151Z","comments":true,"path":"2019/12/30/8.扁平化数组/","link":"","permalink":"https://wxmac.github.io/2019/12/30/8.扁平化数组/","excerpt":"一：Array.prototype.flat()","text":"一：Array.prototype.flat() 12345678910111213141516171819202122const arr = [1,2,3,[4,5,6,[7,8]],9,10];// 不传参数时，默认“拉平”一层arr.flat();// // [1, 2, 3, 4, 5, 6, [7,8], 9, 10]// 传入一个整数参数，整数即“拉平”的层数arr.flat(2);// // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// Infinity 关键字作为参数时，无论多少层嵌套，都会转为一维数组// Infinity(无穷大)在 JS 中是一个特殊的数字，它的特性是：它比任何有限的数字都大。arr.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// 传入 &lt;=0 的整数将返回原数组，不“拉平”arr.flat(0);arr.flat(-10); // [1,2,3,[4,5,6,[7,8]],9,10]//如果原数组有空位，flat()方法会过滤空位[1,2,3,,].flat()// [1, 2, 3] 二：其他方法实现1.reduce12345const flat = (arr) =&gt; &#123; return arr.reduce((prv,cur) =&gt; &#123; return Array.isArray(cur) ? prv.concat(flat(cur)) : prv.concat(cur) &#125;,[])&#125; 2.使用栈的思想实现 flat 函数12345678910111213const flat = (arr) =&gt; &#123; const stack = [...arr]; const res = []; while( stack.length )&#123; const next = stack.pop(); if(Array.isArray(next))&#123; stack.push(...next); &#125; else &#123; res.push(next) &#125; &#125; return res.reverse();&#125; 3.通过传入整数参数控制“拉平”层数 123456789const flat = (arr, num = 1) =&gt; &#123; return num &gt; 0 ? arr.reduce( (pre, cur) =&gt; pre.concat(Array.isArray(cur) ? flat(cur, num - 1) : cur),[]) : arr.slice()&#125;#const arr = [1,2,3,[1,2,3,4, [2,3,4]]];#flat(arr,Infinity) MDN参考链接 其他参考","categories":[],"tags":[{"name":"flat","slug":"flat","permalink":"https://wxmac.github.io/tags/flat/"},{"name":"扁平化数组","slug":"扁平化数组","permalink":"https://wxmac.github.io/tags/扁平化数组/"}]},{"title":"七、不刷新修改url链接","slug":"7.不刷新修改url链接","date":"2019-12-24T16:00:00.000Z","updated":"2020-02-26T08:44:44.253Z","comments":true,"path":"2019/12/25/7.不刷新修改url链接/","link":"","permalink":"https://wxmac.github.io/2019/12/25/7.不刷新修改url链接/","excerpt":"有一个这样的需求，点击分页，不刷新页面。 123//我们的page参数是记录在url里的： https://xxx.html?page=1//如果采取硬拼接的方式，无疑会刷新页面window.location.href = window.location.pathname + `?page=$&#123;page&#125;`","text":"有一个这样的需求，点击分页，不刷新页面。 123//我们的page参数是记录在url里的： https://xxx.html?page=1//如果采取硬拼接的方式，无疑会刷新页面window.location.href = window.location.pathname + `?page=$&#123;page&#125;` 1.pushState() 方法MDN链接 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL. 让我们来解释下这三个参数详细内容：： 状态对象 — 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本 标题 — Firefox 目前忽略这个参数，但未来可能会用到。在此处传一个空字符串应该可以安全的防范未来这个方法的更改。或者，你可以为跳转的state传递一个短标题 URL — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL 2.pushState使用123const pageSize = 2;const url = `$&#123;window.location.pathname&#125;?page=$&#123;pageSize&#125;`window.history.pushState(&#123;url: url&#125;, '', url); 以上就能实现页面无刷新修改url链接。 3.获取和修改url的函数： 顺便放上获取和修改url的函数：↓ 获取url参数12345function getParams (name) &#123; let reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); let r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 更改url参数123456789101112function replaceParamVal(paramName,replaceWith) &#123; var oUrl = window.location.href.toString(); var re = evil('/('+ paramName+'=)([^&amp;]*)/gi'); var nUrl = oUrl.replace(re,paramName+'='+replaceWith); this.location = nUrl; window.location.href=nUrl&#125;function evil(fn) &#123; let Fn = Function; //一个变量指向Function，防止有些前端编译工具报错 return new Fn('return ' + fn)();&#125;","categories":[],"tags":[{"name":"pushState","slug":"pushState","permalink":"https://wxmac.github.io/tags/pushState/"},{"name":"url","slug":"url","permalink":"https://wxmac.github.io/tags/url/"}]},{"title":"六、函数节流和防抖","slug":"6.函数节流和防抖","date":"2019-12-22T16:00:00.000Z","updated":"2020-02-26T08:43:29.378Z","comments":true,"path":"2019/12/23/6.函数节流和防抖/","link":"","permalink":"https://wxmac.github.io/2019/12/23/6.函数节流和防抖/","excerpt":"1.节流 核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动下一个定时器任务。","text":"1.节流 核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动下一个定时器任务。 123456789101112const throttle = (fn, delay) =&gt; &#123; let flag = true; return (...args) =&gt; &#123; let context = this; if (!flag) return; flag = false; setTimeout(() =&gt; &#123; fn.apply(context, args); flag = true; &#125;, delay); &#125;;&#125;; 2.防抖 核心思想: 每次事件触发都删除原来的定时器，建立新的定时器，反复触发函数，那么从最后一次触发开始计时。 123456789101112const debounce = (fn, delay) =&gt; &#123; let timer = null; return (...args) =&gt; &#123; let context = this; if(timer)&#123; clearTimeout(timer) &#125;; timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125;&#125; 3.合并 现在我们可以把防抖和节流放到一起，有时候触发的太频繁会导致一次响应都没有，我们希望到了固定的时间必须给用户一个响应。 12345678910111213const throttle = (fn, delay) =&gt; &#123; let flag = true, timer = null; return function (...args) &#123; let context = this; if( !flag )&#123; return &#125;; clearTimeout(timer); flag = false; timer = setTimeout(function() &#123; flag = true; fn.apply(context, args); &#125;, delay); &#125;&#125; 4.实践 – 图片懒加载clientHeight 、scrollTop 、 offsetTop 思路： 给img一个默认图片，以及data-src属性，当页面滚动到对应img元素的时候，把data-src赋值给src。12345678910111213141516171819202122232425//给img一个默认图片&lt;img src=\"default.png\" data-src=\"xxx/img.png\" /&gt;//通过监听 scroll 事件来判断图片是否到达视口:let img = document.getElementsByTagName(\"img\");let num = img.length;let count = 0; //计数器，从第一张图片开始计lazyload(); //首次加载window.addEventListener('scroll', throttle(lazyload, 200)); //节流function lazyload() &#123; let viewHeight = document.documentElement.clientHeight;// 视口高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//滚动条滚动的高度 for(let i = count; i &lt; num; i++) &#123; //元素现在已经出现在视口中 if( img[i].offsetTop &lt; scrollHeight + viewHeight ) &#123; if(img[i].getAttribute('src') !== 'default.png') continue; //如果src不是default.png'，跳过循环，继续往下循环 img[i].src = img[i].getAttribute(\"data-src\"); count ++; &#125; &#125;&#125;//scrollTop + clientHeight === scrollHeight 即触发下拉加载的条件","categories":[],"tags":[{"name":"函数","slug":"函数","permalink":"https://wxmac.github.io/tags/函数/"},{"name":"节流/防抖","slug":"节流-防抖","permalink":"https://wxmac.github.io/tags/节流-防抖/"}]},{"title":"五、js 深拷贝与浅拷贝","slug":"5.js 深拷贝与浅拷贝","date":"2019-12-17T16:00:00.000Z","updated":"2020-02-26T08:43:12.573Z","comments":true,"path":"2019/12/18/5.js 深拷贝与浅拷贝/","link":"","permalink":"https://wxmac.github.io/2019/12/18/5.js 深拷贝与浅拷贝/","excerpt":"1.基本数据类型和引用数据类型 数据分为基本数据类型和引用数据类型 基本数据类型: 1String、Number、Boolean、Null、Undefined、Symbol、BigInt(?) 引用数据类型: 1Array、Object","text":"1.基本数据类型和引用数据类型 数据分为基本数据类型和引用数据类型 基本数据类型: 1String、Number、Boolean、Null、Undefined、Symbol、BigInt(?) 引用数据类型: 1Array、Object 2.概念 浅拷贝： 1仅仅复制对象的引用，而不是对象本身 深拷贝： 1把复制的对象所引用的全部对象都复制一遍 简单来说，浅拷贝就是这个人的影子，深拷贝就是复制了这个人。 3.方法浅拷贝 123456789const shallowClone = (obj) =&gt; &#123; const result = []; for (let i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; result[i] = obj[i]; &#125; &#125; return result;&#125; Object的 hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性,hasOwnProperty()方法来忽略继承属性.。 object.assign() 把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象 Array.prototype.concat() 数组的一个内置方法，用户合并两个或者多个数组，不会改变现有数组，而是返回一个新数组 Array.prototype.slice() 数组的一个内置方法，该方法会返回一个新的对象，不会改变原数组 obj展开运算符 […]以上几种方式也可以深拷贝 1234567891011121314const deepClone = (obj) =&gt; &#123; let result = Array.isArray(obj) ? [] : &#123;&#125;; for( let i in obj )&#123; if( obj.hasOwnProperty(i) )&#123; if( typeof obj[i] === 'object' &amp;&amp; obj[i] !== null)&#123; result[i] = deepClone(obj[i]) //递归复制 &#125; else &#123; result[i] = obj[i] &#125; &#125; &#125; return result;&#125;//Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。hasOwnProperty()方法来忽略继承属性 JSON.stringfy()和JSON.parse()会忽略undefined、function、symbol，导致属性丢失。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"小技巧","slug":"小技巧","permalink":"https://wxmac.github.io/tags/小技巧/"},{"name":"拷贝","slug":"拷贝","permalink":"https://wxmac.github.io/tags/拷贝/"}]},{"title":"四、react & html2canvas 生成图片下载实践","slug":"4.react & html2canvas实践","date":"2019-12-15T16:00:00.000Z","updated":"2020-03-20T05:50:29.347Z","comments":true,"path":"2019/12/16/4.react & html2canvas实践/","link":"","permalink":"https://wxmac.github.io/2019/12/16/4.react & html2canvas实践/","excerpt":"html2canvas的选择 现在一般生成图片有前端处理和后端处理两种方式，后端生成的方案不需要前端出力，只需要拿路径渲染，但是会出现数据延时，模板更换困难等问题，出于灵活性和减少后端工作量考虑，我们采取 html2canvas 绘制页面。 注意！！！！！ – html2canvas在ios中不支持rem和em，会出现渲染不上图片的情况。建议使用px。 html2canvas npm html2canvas 介绍","text":"html2canvas的选择 现在一般生成图片有前端处理和后端处理两种方式，后端生成的方案不需要前端出力，只需要拿路径渲染，但是会出现数据延时，模板更换困难等问题，出于灵活性和减少后端工作量考虑，我们采取 html2canvas 绘制页面。 注意！！！！！ – html2canvas在ios中不支持rem和em，会出现渲染不上图片的情况。建议使用px。 html2canvas npm html2canvas 介绍 1.在react中的使用123456789101112131415//安装npm install --save html2canvasoryarn add html2canvas//引入import html2canvas from 'html2canvas';//使用html2canvas(document.body).then(function(canvas) &#123; document.body.appendChild(canvas);&#125;);//如果想生成一部分页面的话，html2canvas可以换成 this.refs.demo//&lt;div ref=\"demo\"&gt;&lt;/div&gt; 上面就会把页面简单的绘制出来。 2.canvas 下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051handleRenderCanvas()&#123; const _this = this; var copyDom = this.refs.canvasBox; //要保存的dom var width = copyDom.offsetWidth; //dom宽 var height = copyDom.offsetHeight; //dom高 var scale = 3; //放大倍数 html2canvas(copyDom, &#123; dpi: window.devicePixelRatio , scale: scale , width: width, heigth: height, useCORS: true // 【重要】开启跨域配置 &#125;).then(function(canvas) &#123; const imgUrl = canvas.toDataURL(\"image/png\"); // 获取图片的url _this.setState(&#123; imgUrl, load:false &#125;) // const elA = document.createElement(\"a\"); // elA.download = +new Date() + \".png\"; // elA.href = imgUrl ; // elA.click(); // elA.remove(); &#125;); &#125;//微信中不能下载图片，可以展示图片并提示用户长按保存图片// css用px&#123; this.state.imgUrl ? &lt;img src=&#123; this.state.imgUrl &#125; alt=\"\"/&gt; : &lt;div className=&#123; styleCss.canvas &#125; ref=\"canvasBox\"&gt; &lt;div className=&#123; styleCss.canvasImg &#125;&gt; &lt;img ref=\"img1\" src=&#123; this.state.dataURL &#125; alt=\"\"/&gt; &lt;/div&gt; &lt;div className=&#123; `$&#123;styleCss.qrCode&#125; ` &#125;&gt; &lt;QRCode value=&#123; qrUrl &#125; //value参数为生成二维码的链接 size=&#123; 60 &#125; //二维码的宽高尺寸 fgColor=\"#000000\" //二维码的颜色 /&gt; &lt;/div&gt; &lt;/div&gt;&#125; 3.参考 参考1 4.canvas添加图片12345678910111213141516171819202122const SIZE = 300;/** @type &#123;HTMLCanvasElement&#125; */ const canvas = this.refs.canvas;const ctx = canvas.getContext('2d');const img = new Image()img.crossOrigin = \"anonymous\";img.src = '图片路径';img.onload = () =&gt; &#123; const w = img.width; const h = img.height; const type = w - h if(type &gt; 0)&#123; const width = w * ( SIZE / h ) ctx.drawImage(img, 0, 0, width , SIZE) &#125; else if(type &lt; 0) &#123; const hieght = h * ( SIZE / w ) ctx.drawImage(img, 0, 0, SIZE , hieght) &#125; else &#123; ctx.drawImage(img, 0, 0, SIZE , SIZE) &#125;&#125;","categories":[],"tags":[{"name":"html2canvas","slug":"html2canvas","permalink":"https://wxmac.github.io/tags/html2canvas/"},{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"react","slug":"react","permalink":"https://wxmac.github.io/tags/react/"}]},{"title":"三、一些自己在使用的css技巧","slug":"3.一些自己在使用css技巧","date":"2019-12-11T16:00:00.000Z","updated":"2020-09-04T03:08:28.882Z","comments":true,"path":"2019/12/12/3.一些自己在使用css技巧/","link":"","permalink":"https://wxmac.github.io/2019/12/12/3.一些自己在使用css技巧/","excerpt":"一、CSS – 更新中","text":"一、CSS – 更新中 省略123456789101112131415//单行省略width: 100px;white-space: nowrap;text-overflow: ellipsis;overflow: hidden;//多行省略width: 100px;height:50px;line-height: 30px;overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3; //块元素显示的文本的行数。-webkit-box-orient: vertical; ios关闭输入框内部阴影1-webkit-appearance: none; 用户设置字号放大或者缩小导致页面布局错误 – 设置字体禁止缩放123-webkit-text-size-adjust: 100% !important;text-size-adjust: 100% !important;-moz-text-size-adjust: 100% !important; 下箭头 12345width: 7px;height: 7px;border-bottom: 2px solid #bdbdbd;border-right: 2px solid #bdbdbd;transform: rotate(45deg); 实心三角123456789 width: 0; height: 0;border-width: .1rem;border-style: solid;border-color:#ccc transparent transparent transparent;position: absolute;right: -.3rem;top: 60%;transform: translateY(-50%) 更换谷歌滚动条样式：12::-webkit-scrollbar-thumb&#123;&#125; //更改谷歌滚动条样式::-webkit-scrollbar&#123;&#125; //更改谷歌滚动条背景样式 改变placeholder的颜色123::-moz-placeholder &#123; color: #CDCDCD; &#125;::-webkit-input-placeholder &#123; color:#CDCDCD; &#125;:-ms-input-placeholder &#123; color:#CDCDCD; &#125; 阴影：12345678//左box-shadow: -7px 0 5px -5px #333;//右box-shadow: 7px 0 5px -5px #333;//上box-shadow: 0px -7px 5px -5px #333;//下box-shadow: 0px 7px 5px -5px #333; 按钮下立体阴影1234 box-shadow: inset rgba(253, 163, 125, 1) 0 -0.02rem .06rem,hsla(18, 97%, 75%, .8) 0 .08rem .02rem, hsla(18, 97%, 75%, .8) 0 .08rem .01rem, rgba(253, 163, 125, .3) 0 .05rem .2rem; 字体描边1text-shadow: #000 1px 0 0, #000 0 1px 0, #000 -1px 0 0, #000 0 -1px 0; 单行文字居中，多行文字居左1234.text&#123; display: flex; justify-content: center;&#125; less实现loading1234567891011121314151617181920212223242526272829303132.loader &#123; position: relative; transition: background-color .3s; pointer-events: none; &amp;:after &#123; content: ''; position: absolute; width: 20px; height: 20px; animation: loadingCircle infinite .75s linear; border: 2px solid #888; border-top-color: transparent; border-radius: 50%; z-index: 10; top: 0; bottom: 0; left: 0; right: 0; margin: auto; &#125;&#125;.hideLoader&#123; display: none;&#125;@keyframes loadingCircle &#123; 0% &#123; transform: rotate(0); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; input 功能 弹出数字键盘 1234// 有\"#\" \"*\"符号输入 &lt;input type=\"tel\" /&gt;// 纯数字 &lt;input pattern=\"\\d*\" /&gt; 调用系统的某些功能 12345678910111213// 多选 &lt;input type=\"file\" multiple /&gt;// 选择视频或者拍摄视频 &lt;input type=\"file\" accept=\"video/*\" /&gt;// 选择照片或者拍摄照片&lt;input type=\"file\" accept=\"image/*\" /&gt;// 附加// 发送邮件&lt;a href=\"mailto:839626987@qq.com\"&gt;发邮件给：13116700755@163.com&lt;/a&gt;// 发送短信 &lt;a href=\"sms:10086\"&gt;发短信给: 10086&lt;/a&gt;// 拨号&lt;a href=\"tel:10086\"&gt;打电话给: 10086&lt;/a&gt; 切换title超出滑动123456789101112131415161718192021222324&lt;div class=\"box\"&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;/div&gt;.box&#123; display: flex; overflow: auto; justify-content: space-between;&#125;.box span&#123; flex-shrink: 0; margin-right: 0.5rem; color: #666; font-size: 0.3rem; padding-bottom: 0.3rem;&#125;.box::-webkit-scrollbar &#123; display: none;&#125; flex布局最后一行列表左对齐的方法12345678910111213.container &#123; display: flex; justify-content: space-between; flex-wrap: wrap; .list &#123; background-color: skyblue; margin: 10px; &#125; &amp;::after &#123; content: ''; flex: auto; /* 或者flex: 1 */ &#125;&#125; 圆锥渐变1234width: 5em;height: 5em;border-radius: 50%;background: conic-gradient(red, 70%, #111 0); //圆锥渐变 障眼法：1234567891011&amp;:after&#123; content: ''; position: absolute; width: 90%; height: 90%; background: #111; border-radius: inherit; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; css波浪效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758.waveBox&#123; .wave&#123; width: 100%; height:100%; background: skyblue; margin: 2rem auto; position: relative; overflow: hidden; &amp;:after, &amp;:before&#123; content: ''; position: absolute; width: 5rem; height: 5rem; left: 50%; background: #fff; animation-name: rotate; animation-iteration-count: infinite; animation-timing-function: linear; &#125; &amp;:after&#123; top: -4.5rem; border-radius: 45%; animation-duration: 10s; &#125; &amp;:before&#123; top: -4.4rem; border-radius: 47%; opacity: .5; animation-duration: 10s; &#125; &#125; @keyframes rotate &#123; 0% &#123; transform: translate(-50%, 0) rotateZ(0deg); &#125; 50% &#123; transform: translate(-50%, -5%) rotateZ(180deg); &#125; 100% &#123; transform: translate(-50%, 0%) rotateZ(360deg); &#125; &#125;&#125;/*const height = 4;const top = height &gt; 4 ? height - 4 : 0;const res = &#123; width: '2rem', height: `$&#123;height&#125;rem`, position: 'absolute', top: `-$&#123;top&#125;rem`,&#125;*/// html&lt;div style=&#123; res &#125; className=&#123;styleCss.waveBox&#125;&gt; &lt;div className=&#123;styleCss.wave&#125;&gt;&lt;/div&gt;&lt;/div&gt; css无缝滚动1234567891011121314151617181920212223242526272829303132333435363738394041html:&lt;div className=&#123; styleCss.commentListBox &#125;&gt; &lt;ul className=&#123; `$&#123;styleCss.commentList&#125; $&#123; commentToggleIndex == 0 ? styleCss.show: '' &#125;`&#125;&gt; &#123; handleRenderCommentList() &#125; &#123; handleRenderCommentList() &#125; &lt;/ul&gt; &lt;div className=&#123; styleCss.commentBottom &#125;&gt; &lt;div onClick=&#123; () =&gt; handleLinkOrderList() &#125; className=&#123; styleCss.commentBottom_c &#125;&gt; 评价得&lt;span&gt;&#123; 25 &#125;&lt;/span&gt;积分&lt;i&gt;&lt;/i&gt; &lt;/div&gt; &lt;div onClick=&#123; () =&gt; handleLinkAllCommentList() &#125; className=&#123; styleCss.commentBottom_c &#125;&gt; 查看全部&lt;span&gt;&#123; commentCount &#125;&lt;/span&gt;条评价&lt;i&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; .commentListBox&#123; overflow: hidden; .commentList&#123; box-sizing: border-box; display: none; height: 6rem; animation: scrollT 20s linear infinite normal; &#125;&#125;@keyframes scrollT &#123; 0% &#123; transform: translateY(-10%); &#125; 100% &#123; // 控制台查看元素高度 // 每个元素高度 / 纯父元素高度 * 数据长度 // Math.floor( 140.75 / 300 * 100 ) * 10 transform :translateY(-460%); &#125;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://wxmac.github.io/tags/css/"},{"name":"小技巧","slug":"小技巧","permalink":"https://wxmac.github.io/tags/小技巧/"}]},{"title":"三(一)、一些自己在使用的js技巧","slug":"3-1.一些自己在js技巧","date":"2019-12-11T16:00:00.000Z","updated":"2020-09-15T08:22:55.086Z","comments":true,"path":"2019/12/12/3-1.一些自己在js技巧/","link":"","permalink":"https://wxmac.github.io/2019/12/12/3-1.一些自己在js技巧/","excerpt":"","text":"一、JS – 更新中判断 val 是否存在1234567891011121314151. for(let item in data)&#123; if(!data[item])&#123; data[item] = '--'; &#125;&#125;2. const page = &#123; user:'111', cityInfo:&#123; city:'hz', code:'111' &#125;&#125;;const name = ( (page || &#123;&#125;).cityInfo || &#123;&#125; ).city || '111';console.log(name) 滑动固定距离显示123456789101112var oNav = document.getElementById(\"Q-nav\");window.onscroll = function()&#123; var h = 168; var sTop = document.body.scrollTop || document.documentElement.scrollTop; if( sTop &gt; h )&#123; //吸顶 固定定位 并且 top 设置为 0 oNav.style.position = \"fixed\"; oNav.style.top = 0; &#125;else&#123; oNav.style.position = \"static\"; &#125;&#125; 数组添加新属性123456789const [ selectArr , setSelectArr ] = useState([]); // 选中的数据let initSelectArr = [...data];initSelectArr = initSelectArr.map((item) =&gt; Object.assign(item, &#123; status: 0, id: item.id, dis: item.nopass&#125;))setSelectArr(initSelectArr) every、map、filter常用123const isFilter = selectArr.filter((item) =&gt; item.status == 1); // 选择数量const isEveryAllFlag = selectArr.every((item) =&gt; item.status == 1); // 全选const ids = isFilter.map( (item) =&gt; &#123; return item.id &#125; ); // 获取数组里所有的id 上传图片回填12345let reads = new FileReader();reads.readAsDataURL(files);reads.onload = function(e) &#123; document.getElementById('ID').src = this.result;&#125;; 获取url参数12345function getParams (name) &#123; let reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); let r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 更改url参数123456789101112function replaceParamVal(paramName,replaceWith) &#123; var oUrl = window.location.href.toString(); var re = evil('/('+ paramName+'=)([^&amp;]*)/gi'); var nUrl = oUrl.replace(re,paramName+'='+replaceWith); this.location = nUrl; window.location.href=nUrl&#125;function evil(fn) &#123; let Fn = Function; //一个变量指向Function，防止有些前端编译工具报错 return new Fn('return ' + fn)();&#125; ios window.history.back() 致使 localStorage不同步123456window.onpageshow = function(event) &#123; if (event.persisted || (window.performance &amp;&amp; window.performance.navigation.type == 2)) &#123; window.location.reload(); &#125;&#125; textatea 高度自适应123456789101112//jq:el.on('input', function () &#123; const height = $(this).scrollTop() + $(this).prop(\"scrollHeight\") + \"px\"; $(this).height(height)&#125;)//react :const el = this.refs.remark;el.style.height = 'auto'; if(el.scrollHeight &gt;= el.offsetHeight )&#123; //如果高度不够，再重新设置 el.style.height = el.scrollHeight + 'px'&#125; 监控页面大小变化123456789101112131415161718192021222324const u = navigator.userAgent;const isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);if( isiOS )&#123; document.body.addEventListener('focusin', () =&gt; &#123; //软键盘弹出的事件处理 &#125;) document.body.addEventListener('focusout', () =&gt; &#123; window.scrollTo(0, 20) &#125;) &#125; else &#123; window.οnresize=function()&#123; //键盘弹起与隐藏都会引起窗口的高度发生变化 var resizeHeight=document.documentElement.clientHeight || document.body.clientHeight; if(resizeHeight-0 &lt;originalHeight-0)&#123; //当软键盘弹起，在此处操作 &#125;else&#123; //当软键盘收起，在此处操作 window.scrollTo(0, 20) &#125; &#125; &#125; 解决安卓端键盘挡住按钮 ———1234567891011handleGetResize()&#123; const innerHeight = window.innerHeight; window.addEventListener('resize', () =&gt; &#123; const newInnerHeight = window.innerHeight; // innerHeight &gt; newInnerHeight 弹起键盘 const flag = innerHeight &gt; newInnerHeight ? true : false; this.setState(&#123; changeStatus: flag &#125;) &#125;);&#125; 列表title使居中显示1234567891011121314151617// 原生版本：const tabsEl = document.getElementById('tabsEl')let allWidth = tabsEl.offsetWidthlet currentWidth = e.target.offsetWidthlet currentLeft = e.target.offsetLefttabsEl.scrollLeft = currentLeft + currentWidth / 2 - allWidth / 2// react版本：const tabsEl = this.tabsEllet allWidth = tabsEl.offsetWidthlet currentWidth = e.target.offsetWidthlet currentLeft = e.target.offsetLeftconst left = currentLeft + currentWidth / 2 - allWidth / 2;localStorage.left = left;tabsEl.scrollLeft = left;// tabsEl 是滚动列表的容器， e 是当前点击的元素// ref=&#123; (item) =&gt; &#123; this.tabsEl = item &#125; &#125; 查找重复字符123456let red= 'hjqjbsaxhhhh'; let obj = &#123;&#125;;for (var i = 0; i&lt;red.length; i++) &#123; obj[red[i]] = ++obj[red[i]] || 1 ; console.log(red[i]) &#125; 手机号自动添加空格1\"13116700755\".replace(/(?&lt;=^\\d&#123;3&#125;(\\d&#123;4&#125;)*)(?!$)/g, ' ') ---&gt; \"131 1670 0755\" 获取key和val，组成新对象123456789101112131415161718192021222324252627282930313233343536const cities = [ &#123; name: 'Paris', visited: 'no' &#125;, &#123; name: 'Lyon', visited: 'no' &#125;, &#123; name: 'Marseille', visited: 'yes' &#125;, &#123; name: 'Rome', visited: 'yes' &#125;, &#123; name: 'Milan', visited: 'no' &#125;, &#123; name: 'Palermo', visited: 'yes' &#125;, &#123; name: 'Genoa', visited: 'yes' &#125;, &#123; name: 'Berlin', visited: 'no' &#125;, &#123; name: 'Hamburg', visited: 'yes' &#125;, &#123; name: 'New York', visited: 'yes' &#125;]; const result = cities.reduce((prv, item) =&gt; &#123; return &#123; ...prv, [item.name]: item.visited &#125;&#125;, &#123;&#125;);console.log(result);/** 打印结果： &#123; Paris: \"no\", Lyon: \"no\", Marseille: \"yes\", Rome: \"yes\", Milan: \"no\", Palermo: \"yes\", Genoa: \"yes\", Berlin: \"no\", Hamburg: \"yes\", New York: \"yes\" &#125;**/ react多个倒计时1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 初始化倒计时handleTimeInit(data)&#123; data.map((item,index) =&gt; &#123; let timer = ''; if(Number(item.lost_dttm_second) &gt; 0)&#123; this.handleResetTime(timer, Number(item.lost_dttm_second),index ) &#125; &#125;) &#125;handleResetTime(timer, delay, index)&#123; const _this = this; let time = Math.floor(delay); timer = setInterval( function () &#123; let _time = --time; _this.handleFormatTime(_time,index); if(time &lt;= 0)&#123; clearInterval(timer) &#125; &#125;,1000);&#125;handleFormatTime(time,index)&#123; var hour = parseInt(time / 3600, 10); var day = parseInt(hour/24); var min = parseInt((time - (hour * 3600)) / 60, 10); // var sec = time % 60; min = min &lt; 10 ? ('0' + min) : min; hour = hour &lt; 10 ? ('0' + hour) : hour; day = day &lt; 10 ? ('0' + day) : day; // sec = sec &lt; 10 ? ('0' + sec) : sec; // 重新设置时间 const &#123; couponList &#125; = this.state; couponList[index].day = day couponList[index].hour = parseInt(hour % 24); // ！！！ couponList[index].min = min this.setState(&#123; couponList: couponList &#125;)&#125;/*** * 毫秒倒计时小技巧 -- 毫秒值跟在倒计时后面 * */ let newTime = 99;setInterval(() =&gt; &#123; const newTime2 = newTime--; if(newTime2 &lt;= 0)&#123; newTime = 99 &#125; this.setState(&#123; newTime: newTime2 &#125;)&#125;,10) 利用数组获取当前时间123456789101112131415 const showTime = () =&gt; &#123; let date = new Date();let h = date.getHours();let m = date.getMinutes(); let s = date.getSeconds(); let arrTime = [ h &lt; 10 ? 0 : parseInt( h/10 ), h % 10, m &lt; 10 ? 0 : parseInt( m/10 ), m % 10, s &lt; 10 ? 0 : parseInt( s/10 ), s % 10, ]; return arrTime; // 返回的是时间数组，例[ 1,2,0,0,0,0 ] 就是12:00:00 &#125; 处理图片出错，替换默认图片123456document.addEventListener(\"error\", function (e) &#123; let elem = e.target; if (elem.tagName.toLowerCase() === 'img') &#123; elem.src = 'https://res.youbeichefu.com/upload/head/default.png'; &#125;&#125;, true); 获取元素类型1const dataType = obj =&gt; Object.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, '$1').toLowerCase(); 判断是否是移动端1const isMobile = () =&gt; 'ontouchstart' in window fade动画1234567891011121314151617 const fade = (el, type = 'in') &#123; el.style.opacity = (type === 'in' ? 0 : 1) let last = +new Date() const tick = () =&gt; &#123; const opacityValue = (type === 'in' ? (new Date() - last) / 400 : -(new Date() - last) / 400) el.style.opacity = +el.style.opacity + opacityValue last = +new Date() if (type === 'in' ? (+el.style.opacity &lt; 1) : (+el.style.opacity &gt; 0)) &#123; requestAnimationFrame(tick) &#125; &#125; tick()&#125; 将指定格式的字符串解析为日期字符串12345678910 const dataPattern = (str, format = '-') =&gt; &#123; if (!str) &#123; return new Date() &#125; const dateReg = new RegExp(`^(\\\\d&#123;2&#125;)$&#123;format&#125;(\\\\d&#123;2&#125;)$&#123;format&#125;(\\\\d&#123;4&#125;)$`) const [, month, day, year] = dateReg.exec(str) return new Date(`$&#123;month&#125;, $&#123;day&#125; $&#123;year&#125;`)&#125; console.log(dataPattern('12-25-1995')) // Mon Dec 25 1995 00:00:00 GMT+0800 (中国标准时间) 禁止网页复制粘贴123const html = document.querySelector('html')html.oncopy = () =&gt; falsehtml.onpaste = () =&gt; false 去除字符串中的html代码12const removeHTML = (str = '') =&gt; str.replace(/&lt;[\\/\\!]*[^&lt;&gt;]*&gt;/ig, '')console.log(removeHTML('&lt;h1&gt;哈哈哈哈&lt;呵呵呵&lt;/h1&gt;')) // 哈哈哈哈&lt;呵呵呵 js判断日期是否为今天12345678910function isToday(str)&#123; var d = new Date(str.replace(/-/g,\"/\")); var todaysDate = new Date(); if(d.setHours(0,0,0,0) == todaysDate.setHours(0,0,0,0))&#123; return true; &#125; else &#123; return false; &#125; &#125; isToday('2020-08-14') 笛卡尔积算法 1234567891011function cartesianProductOf() &#123; return Array.prototype.reduce.call(arguments, function(a, b) &#123; var ret = []; a.forEach(function(a) &#123; b.forEach(function(b) &#123; ret.push(a.concat([b])); &#125;); &#125;); return ret; &#125;, [[]]);&#125; 函数柯里化123456789101112131415161718function currie(...argument)&#123; const params = [...argument]; function currieItem(...arg)&#123; params.push(...arg) if(arg.length)&#123; return currieItem &#125; return params[0](...params.slice(1)) &#125; return currieItem&#125;const sum = currie( (...arg) =&gt; &#123; return arg.reduce( (total, curr) =&gt; &#123; return total + curr &#125;, 0)&#125;)(1)(1)(1)(1,1,1)()console.log( sum ) 监听页面离开返回并且刷新页面1234567handleHidePageReload()&#123; document.addEventListener(\"visibilitychange\", function() &#123; if( document.hidden )&#123; window.location.reload() &#125; &#125;)&#125; 在线直播的队列动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778html:&lt;div className=&#123;styleCss.animateWrap&#125;&gt; &#123; user.map((item, i) =&gt; &#123; return &lt;div className=&#123; `$&#123;styleCss.animate&#125; $&#123;user.length &gt; 2 &amp;&amp; i === 0 ? styleCss.hidden : ''&#125;`&#125; key=&#123;item&#125;&gt;&lt;div className=&#123;styleCss.tx&#125;&gt;&lt;img src=&#123;bgImg&#125; alt=\"\"/&gt;&lt;/div&gt;&lt;span&gt;李老师&#123;item&#125;上线&lt;/span&gt;&lt;/div&gt; &#125;) &#125;&lt;/div&gt;css: .animateWrap &#123; position: absolute; top: .3rem; left: .3rem; .animate &#123; margin-bottom: .2rem; border-radius: .6rem; background-color: rgba(0,0,0, .3); animation: moveIn 1.2s; .tx &#123; display: inline-block; width: .48rem; height: .48rem; border-radius: 50%; overflow: hidden; vertical-align: middle; margin-right: .12rem; img &#123; width: 100%; height: 100%; object-fit: cover; &#125; &#125; span &#123; margin-right: .12rem; line-height: .5rem; font-size: .24rem; color: #fff; &#125; &#125; .hidden &#123; opacity: 0; animation: moveOut 1.2s; &#125; @keyframes moveIn &#123; 0% &#123; transform: translateX(calc(-100% - 12px)); &#125; 100% &#123; transform: translateX(0); &#125; &#125; @keyframes moveOut &#123; 0% &#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125; &#125;&#125;js:const [user, setUser] = useState([])useEffect(() =&gt; &#123; let MAX_USER_COUNT = 2; let timer = setInterval(() =&gt; &#123; setUser(prev =&gt; &#123; prev.push(Date.now() + '') if(prev.length &gt; MAX_USER_COUNT + 1)&#123; prev.shift() return [...prev] &#125;else &#123; return [...prev] &#125; &#125;) &#125;, 3000)&#125;, []) if 判断的优化 – 策略模式 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。它提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。1234567891011const commodity = new Map([ ['phone', 1999], ['computer', 9999], ['television', 2999], ['gameBoy', 3999],])const price = (name) =&gt; &#123; return commodity.get(name)&#125;price('phone') // 1999 react 图片裁剪1- react-cropper","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"小技巧","slug":"小技巧","permalink":"https://wxmac.github.io/tags/小技巧/"}]},{"title":"二、vsCode终端打开问题","slug":"2.vsCode终端打开问题","date":"2019-12-08T16:00:00.000Z","updated":"2020-02-26T08:41:35.749Z","comments":true,"path":"2019/12/09/2.vsCode终端打开问题/","link":"","permalink":"https://wxmac.github.io/2019/12/09/2.vsCode终端打开问题/","excerpt":"之前打开vscode时，报 终端进程命令”/bin/bash -l”无法启动 (退出代码: 1)；","text":"之前打开vscode时，报 终端进程命令”/bin/bash -l”无法启动 (退出代码: 1)； 其他报错也可以参考一下： 有以下几个解决思路 重装vscode；（我是这个方法解决的） 因为 VSCode 工作区的文件夹有变更（删除、移动等），导致 VSCode 打开终端时，找不到此文件夹而报错； 配置下 git 路径不对，重新配置一下git；在设置里修改 “terminal.integrated.shell.windows”: “git路径base.exe”； 用管理员的权限来执行vscode，要不然它没有权限使用cmd;右击快捷键点击属性然后选择以管理员的身份运行 github解决思路","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://wxmac.github.io/tags/vscode/"}]},{"title":"一、React 多页面打包","slug":"1.react 多页面打包","date":"2019-12-05T16:00:00.000Z","updated":"2020-07-14T07:12:39.107Z","comments":true,"path":"2019/12/06/1.react 多页面打包/","link":"","permalink":"https://wxmac.github.io/2019/12/06/1.react 多页面打包/","excerpt":"缘由 之前我们用的是react单页面打包，方便是方便，开包即用。但是因为我们做的是活动页面，一般每次都只有一个页面，不仅要建大量的路由，而且资源冗杂，即使已经做了资源分割。还有做多页面最重要的原因是：单页面打包，会影响所有的页面，如果一个页面报错，那么其他的页面也无法访问。下面开始配置: 一.webpack及react版本12\"webpack\": \"^4.19.1\",\"react\": \"^16.8.3\",","text":"缘由 之前我们用的是react单页面打包，方便是方便，开包即用。但是因为我们做的是活动页面，一般每次都只有一个页面，不仅要建大量的路由，而且资源冗杂，即使已经做了资源分割。还有做多页面最重要的原因是：单页面打包，会影响所有的页面，如果一个页面报错，那么其他的页面也无法访问。下面开始配置: 一.webpack及react版本12\"webpack\": \"^4.19.1\",\"react\": \"^16.8.3\", 二.文件夹基本构造1234567891011121314151617181920212223242526272829303132333435config - path.js | - webpack.config.jspublic - index.htmlsrc - page - maintenance // 对应path.js的entriesPathFile - home - component.js | - index.js | - index.less - my - component.js | - index.js | - index.less - washstation // 对应path.js的entriesPathFile - home - component.js | - index.js | - index.less - my - component.js | - index.js | - index.lessindex.js //必不可少，可以为空 1.page下的index.js home是一个单独的页面，包括 component.js: 1234567891011121314151617class Home extends Component&#123; constructor(props)&#123; super(props) this.state = &#123; &#125; &#125; componentDidMount()&#123;&#125; render() &#123; return( &lt;div&gt; ... &lt;/div&gt; ) &#125;&#125;export default Home; index.js: 123456import 'core-js/stable';import 'babel-polyfill'import React from 'react';import ReactDOM from 'react-dom';import Home from './component';ReactDOM.render(&lt;Home /&gt;, document.getElementById('root')); index.less是页面相关的样式 2.config下的path.js12345678910111213const globby = require('globby');const entriesPathFile = 'maintenance';const entriesPath = globby.sync([resolveApp('src/page/' + entriesPathFile) + '/*/index.js']);/** 注意事项： - 1.entriesPath就是打包 maintenance 下面对应文件所有的index.js; - 2.有多个项目的话，就新建多个文件夹,如 washstation， - 3.启动项目或者打包项目只需要更改 entriesPathFile就可以了，如 const entriesPathFile = 'washstation' - 4.新建文件夹或者更换entriesPathFile必须要重新启动项目;*/ module.exports = &#123; ... entriesPath&#125; 下面这里是关键，东西有点多，配错了就没效果了：⬇️3.config下的webpack.config.js 获取指定路径下的入口文件 12345678910111213function getEntries()&#123; const entries = &#123;&#125;; const files = paths.entriesPath; files.forEach(filePath =&gt; &#123; let tmp = filePath.split('/'); let name = tmp[tmp.length - 2]; entries[name] = [ require.resolve('react-dev-utils/webpackHotDevClient'), filePath, ]; &#125;); return entries;&#125; 入口文件对象 1const entries = getEntries(); 有多少个页面就new 多少个HtmlWebpackPlugin 12345678const htmlPlugin = Object.keys(entries).map(item =&gt; &#123; return new HtmlWebpackPlugin(&#123; inject: true, template: paths.appHtml, // pulblic/index.html 公共html模板 filename: item + '/' + item + '.html', // 这里是关键,访问入口由这里决定 http://localhost:3000/home/home.html chunks: [item] &#125;);&#125;); 更换入口 12345678entry: &#123; /* devtool: isEnvProduction ? shouldUseSourceMap ? 'source-map' : false : isEnvDevelopment &amp;&amp; 'eval-source-map', entries&#125; 出口也顺便更改一下 123456789101112131415161718192021222324252627282930output:&#123; /*把对应资源放到对应页面下面,这里[name] 就是home isEnvDevelopment 对应的内容一定要配，不然本地开发只能找到一个页面 version 是时间戳 const version = +new Date();*/ filename: isEnvProduction ? '[name]/static/js/[name].[chunkhash:8].'+version+'.js' : isEnvDevelopment &amp;&amp; '[name]/static/js/bundle.js', chunkFilename: isEnvProduction ? '[name]/static/js/[name].[chunkhash:8].'+version+'.chunk.js' : isEnvDevelopment &amp;&amp; '[name]/static/js/[name].chunk.'+version+'.js',&#125;//上面是js，css也改一下，全局搜索 MiniCssExtractPluginnew MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: '[name]/static/css/[name].[contenthash:8].'+version+'.css', chunkFilename: '[name]/static/css/[name].[contenthash:8].chunk.'+version+'.css',&#125;),// 图片资源 全局搜索 .png ,图片是独立的&#123; test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/], loader: require.resolve('url-loader') , options: &#123; limit: 10000, name: 'static/media/[name].[hash:8].'+version+'.[ext]', &#125;,&#125;, 4.打包效果123456789101112131415dist - 1 // 打包出的公共的js文件 - 2 // 打包出的公共的js文件 - assets // 本地静态资源 - static //打包的静态图片资源 - media - xxxx.png - home - home.html - static - css - xxx.css - js - xxx.js xxx 如果多个页面的话，其他页面效果和home文件一样。 4.最后一点 打完包，可能会出现资源访问不到，在 package.json 配置一下homepage (1).我的是下面，根据项目路径来写： 1\"homepage\": \"../\", (1)：顺便提一下，本地跨域，同样在 package.json 配置一下 proxy就可以了： 1\"proxy\": \"域名\", (2)：2020/7/15 更新 – 跨域配置 - 在src下新建 setupProxy.js 12345678910111213141516171819202122const &#123; createProxyMiddleware &#125; = require(\"http-proxy-middleware\");const targetUrl = \"https://wechattest.youbeichefu.com\"; // 配置域名 -- 测试// const targetUrl = \"https://prewechat.youbeichefu.com\"; // 配置域名 -- 预发布// const targetUrl = \"https://wechat.youbeichefu.com\"; // 配置域名 -- 线上const regArr = [ // 配置匹配的请求链接 '/func', '/userApi', '/washstation', '/app', '/parkingLot', '/static/web', '/file']; module.exports = function(app) &#123; app.use( createProxyMiddleware(regArr, &#123; target: targetUrl, changeOrigin: true, // needed for virtual hosted sites &#125;) );&#125;; (2).打完包之后，放到服务器上，跳转访问路径也要配置的 123456789101112 //比如本地 http://localhost:3000/home/home.html;//线上:https:www.baidu.com/dist/demo/home/home.html//那么当你跳转链接的时候，就要这样：//跳转const param = window.location.href.includes('baidu') ? '/dist/demo' : '';window.location.href = param + '/home/home.html';","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://wxmac.github.io/tags/js/"},{"name":"react","slug":"react","permalink":"https://wxmac.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://wxmac.github.io/tags/webpack/"}]}]}